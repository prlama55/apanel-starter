This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-07T15:22:01.474Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
admin/
  src/
    components/
      ComponentCard/
        ComponentIcon/
          index.ts
        index.ts
      ContentTypeBuilderNav/
        tests/
          mockData.ts
        useContentTypeBuilderMenu.ts
      CustomRadioGroup/
        index.ts
      DataManagerProvider/
        tests/
          data.ts
          reducerAddAttributeAction.test.ts
          reducerAddCustomFieldAttributeAction.test.ts
          reducerBasicActions.test.ts
          reducerEditAttributeAction.test.ts
          reducerEditCustomFieldAttributeAction.test.ts
          reducerRemoveFieldAction.test.ts
        utils/
          tests/
            cleanData.test.ts
            createModifiedDataSchema.test.ts
            expectedFormattedData.ts
            formatSchemas.test.ts
            rawData.ts
            retrieveComponentsFromSchema.test.ts
            retrieveComponentsThatHaveComponents.test.ts
            retrieveNestedComponents.test.ts
          cleanData.ts
          createDataObject.ts
          createModifiedDataSchema.ts
          formatSchemas.ts
          retrieveComponentsFromSchema.ts
          retrieveComponentsThatHaveComponents.ts
          retrieveNestedComponents.ts
          retrieveSpecificInfoFromComponents.ts
          serverRestartWatcher.ts
          validateSchema.ts
        constants.ts
        reducer.ts
        selectors.ts
      FormModal/
        attributes/
          validation/
            common.ts
          advancedForm.ts
          attributeOptions.ts
          baseForm.ts
          commonBaseForm.ts
          form.ts
          nameField.ts
          types.ts
        category/
          createCategorySchema.ts
          form.ts
          regex.ts
        component/
          componentField.ts
          componentForm.ts
          createComponentSchema.ts
        contentType/
          contentTypeForm.ts
          createContentTypeSchema.ts
        forms/
          tests/
            customField.test.ts
          utils/
            tests/
              addItemsToFormSections.test.ts
            addItemsToFormSection.ts
            createCollectionName.ts
            getUsedAttributeNames.ts
          forms.ts
        tests/
          reducer.set-custom-field-data-schema.test.ts
          reducer.test.ts
        utils/
          tests/
            canEditContentType.test.ts
            rawData.ts
          canEditContentType.ts
          createUid.ts
          customFieldDefaultOptionsReducer.ts
          getAttributesToDisplay.ts
          getFormInputNames.ts
          relations.ts
        constants.ts
        dynamiczoneForm.ts
        reducer.ts
        selectors.ts
      FormModalNavigationProvider/
        tests/
          formModalNavigationProvider.test.ts
          index.test.ts
        constants.ts
      IconPicker/
        constants.ts
        index.ts
    contexts/
      DataManagerContext.ts
      FormModalNavigationContext.ts
    hooks/
      useDataManager.ts
      useFormModalNavigation.ts
    translations/
      tests/
        plural.test.ts
    utils/
      tests/
        formAPI.test.ts
        getMaxDepth.test.ts
        getRelationType.test.ts
        getYupInnerErrors.test.ts
        isAllowedContentTypesForRelations.test.ts
        makeUnique.test.ts
        parseDateValue.test.ts
        prefixPluginTranslations.test.ts
        timeFormat.test.ts
      findAttribute.ts
      formAPI.ts
      getAttributeDisplayedType.ts
      getMaxDepth.ts
      getRelationType.ts
      getTrad.ts
      getYupInnerErrors.ts
      index.ts
      isAllowedContentTypesForRelations.ts
      makeUnique.ts
      nameToSlug.ts
      parseDateValue.ts
      prefixPluginTranslations.ts
      startsWithANumber.ts
      timeFormat.ts
      toRegressedEnumValue.ts
    constants.ts
    exports.ts
    index.ts
    pluginId.ts
    reducers.ts
    types.ts
  .eslintrc.js
server/
  src/
    controllers/
      validation/
        __tests__/
          common.test.ts
          component.test.ts
          content-type.test.ts
          data-transform.test.ts
          types.test.ts
        common.ts
        component-category.ts
        component.ts
        content-type.ts
        data-transform.ts
        model-schema.ts
        relations.ts
        types.ts
      builder.ts
      component-categories.ts
      components.ts
      content-types.ts
      index.ts
    routes/
      admin.ts
      content-api.ts
      index.ts
    services/
      __tests__/
        content-types.test.ts
      schema-builder/
        component-builder.ts
        content-type-builder.ts
        index.ts
        schema-handler.ts
      api-handler.ts
      builder.ts
      component-categories.ts
      components.ts
      constants.ts
      content-types.ts
      index.ts
    utils/
      attributes.ts
      helpers.ts
      index.ts
      typeguards.ts
    bootstrap.ts
    config.ts
    index.ts
jest.config.front.js
jest.config.js
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="admin/src/components/ComponentCard/ComponentIcon/index.ts">
/* eslint-disable check-file/no-index */
export * from './ComponentIcon';
</file>

<file path="admin/src/components/ComponentCard/index.ts">
/* eslint-disable check-file/no-index */
export * from './ComponentCard';
</file>

<file path="admin/src/components/ContentTypeBuilderNav/tests/mockData.ts">
export const mockData = [
  {
    name: 'models',
    title: {
      id: 'content-type-builder.menu.section.models.name.',
      defaultMessage: 'Collection Types',
    },
    customLink: {
      id: 'content-type-builder.button.model.create',
      defaultMessage: 'Create new collection type',
    },
    links: [
      {
        visible: true,
        name: 'application::address.address',
        title: 'address',
        plugin: null,
        uid: 'application::address.address',
        to: '/plugins/content-type-builder/content-types/application::address.address',
        kind: 'collectionType',
        restrictRelationsTo: null,
      },
      {
        visible: true,
        name: 'application::category.category',
        title: 'category',
        plugin: null,
        uid: 'application::category.category',
        to: '/plugins/content-type-builder/content-types/application::category.category',
        kind: 'collectionType',
        restrictRelationsTo: null,
      },
    ],
    linksCount: 2,
  },
  {
    name: 'singleTypes',
    title: {
      id: 'content-type-builder.menu.section.single-types.name.',
      defaultMessage: 'Single Types',
    },
    customLink: {
      id: 'content-type-builder.button.single-types.create',
      defaultMessage: 'Create new single type',
    },
    links: [
      {
        visible: true,
        name: 'application::homepage.homepage',
        title: 'Homepage',
        plugin: null,
        uid: 'application::homepage.homepage',
        to: '/plugins/content-type-builder/content-types/application::homepage.homepage',
        kind: 'singleType',
        restrictRelationsTo: null,
      },
    ],
    linksCount: 1,
  },
  {
    name: 'components',
    title: {
      id: 'content-type-builder.menu.section.components.name.',
      defaultMessage: 'Components',
    },
    customLink: {
      id: 'content-type-builder.button.component.create',
      defaultMessage: 'Create a new component',
    },
    links: [
      {
        name: 'basic',
        title: 'basic',
        isEditable: true,
        links: [
          {
            name: 'basic.simple',
            to: '/plugins/content-type-builder/component-categories/basic/basic.simple',
            title: 'simple',
          },
        ],
      },
      {
        name: 'default',
        title: 'default',
        isEditable: true,
        links: [
          {
            name: 'default.closingperiod',
            to: '/plugins/content-type-builder/component-categories/default/default.closingperiod',
            title: 'closingperiod',
          },
          {
            name: 'default.dish',
            to: '/plugins/content-type-builder/component-categories/default/default.dish',
            title: 'dish',
          },
        ],
      },
    ],
    linksCount: 3,
  },
];
</file>

<file path="admin/src/components/ContentTypeBuilderNav/useContentTypeBuilderMenu.ts">
import { useState, MouseEvent } from 'react';

import { useTracking, useNotification } from '@strapi/admin/strapi-admin';
import { useCollator, useFilter } from '@strapi/design-system';
import isEqual from 'lodash/isEqual';
import { useIntl } from 'react-intl';

import { useDataManager } from '../../hooks/useDataManager';
import { useFormModalNavigation } from '../../hooks/useFormModalNavigation';
import { pluginId } from '../../pluginId';
import { getTrad } from '../../utils/getTrad';

import type { Internal } from '@strapi/types';

export const useContentTypeBuilderMenu = () => {
  const {
    components,
    componentsGroupedByCategory,
    contentTypes,
    isInDevelopmentMode,
    sortedContentTypesList,
    modifiedData,
    initialData,
  } = useDataManager();
  const { toggleNotification } = useNotification();
  const { formatMessage } = useIntl();
  const { trackUsage } = useTracking();
  const [search, setSearch] = useState('');
  const { onOpenModalCreateSchema, onOpenModalEditCategory } = useFormModalNavigation();
  const { locale } = useIntl();

  const { startsWith } = useFilter(locale, {
    sensitivity: 'base',
  });

  const formatter = useCollator(locale, {
    sensitivity: 'base',
  });

  const canOpenModalCreateCTorComponent =
    !Object.keys(contentTypes).some((ct) => contentTypes[ct].isTemporary === true) &&
    !Object.keys(components).some(
      (component) => components[component as Internal.UID.Component].isTemporary === true
    ) &&
    isEqual(modifiedData, initialData);

  const handleClickOpenModalCreateCollectionType = () => {
    if (canOpenModalCreateCTorComponent) {
      trackUsage(`willCreateContentType`);

      const nextState = {
        modalType: 'contentType',
        kind: 'collectionType',
        actionType: 'create',
        forTarget: 'contentType',
      };

      onOpenModalCreateSchema(nextState);
    } else {
      toggleNotificationCannotCreateSchema();
    }
  };

  const handleClickOpenModalCreateSingleType = () => {
    if (canOpenModalCreateCTorComponent) {
      trackUsage(`willCreateSingleType`);

      const nextState = {
        modalType: 'contentType',
        kind: 'singleType',
        actionType: 'create',
        forTarget: 'contentType',
      };

      onOpenModalCreateSchema(nextState);
    } else {
      toggleNotificationCannotCreateSchema();
    }
  };

  const handleClickOpenModalCreateComponent = () => {
    if (canOpenModalCreateCTorComponent) {
      trackUsage('willCreateComponent');

      const nextState = {
        modalType: 'component',
        kind: null,
        actionType: 'create',
        forTarget: 'component',
      };

      onOpenModalCreateSchema(nextState);
    } else {
      toggleNotificationCannotCreateSchema();
    }
  };

  const toggleNotificationCannotCreateSchema = () => {
    toggleNotification({
      type: 'info',
      message: formatMessage({
        id: getTrad('notification.info.creating.notSaved'),
        defaultMessage: 'Please save your work before creating a new collection type or component',
      }),
    });
  };

  const componentsData = Object.entries(componentsGroupedByCategory)
    .map(([category, components]) => ({
      name: category,
      title: category,
      isEditable: isInDevelopmentMode,
      onClickEdit(e: MouseEvent, data: any) {
        e.stopPropagation();

        if (canOpenModalCreateCTorComponent) {
          onOpenModalEditCategory(data.name);
        } else {
          toggleNotificationCannotCreateSchema();
        }
      },
      links: components
        .map((component) => ({
          name: component.uid,
          to: `/plugins/${pluginId}/component-categories/${category}/${component.uid}`,
          title: component.schema.displayName,
        }))
        .sort((a, b) => formatter.compare(a.title, b.title)),
    }))
    .sort((a, b) => formatter.compare(a.title, b.title));

  const displayedContentTypes = sortedContentTypesList.filter((obj) => obj.visible);

  const data = [
    {
      name: 'models',
      title: {
        id: `${getTrad('menu.section.models.name')}`,
        defaultMessage: 'Collection Types',
      },
      customLink: isInDevelopmentMode && {
        id: `${getTrad('button.model.create')}`,
        defaultMessage: 'Create new collection type',
        onClick: handleClickOpenModalCreateCollectionType,
      },
      links: displayedContentTypes.filter((contentType) => contentType.kind === 'collectionType'),
    },
    {
      name: 'singleTypes',
      title: {
        id: `${getTrad('menu.section.single-types.name')}`,
        defaultMessage: 'Single Types',
      },
      customLink: isInDevelopmentMode && {
        id: `${getTrad('button.single-types.create')}`,
        defaultMessage: 'Create new single type',
        onClick: handleClickOpenModalCreateSingleType,
      },
      links: displayedContentTypes.filter((singleType) => singleType.kind === 'singleType'),
    },
    {
      name: 'components',
      title: {
        id: `${getTrad('menu.section.components.name')}`,
        defaultMessage: 'Components',
      },
      customLink: isInDevelopmentMode && {
        id: `${getTrad('button.component.create')}`,
        defaultMessage: 'Create a new component',
        onClick: handleClickOpenModalCreateComponent,
      },
      links: componentsData,
    },
  ].map((section) => {
    const hasChild = section.links.some((l) => Array.isArray(l.links));

    if (hasChild) {
      let filteredLinksCount = 0;

      return {
        ...section,
        links: section.links
          .map((link) => {
            const filteredLinks = link.links.filter((link: any) => startsWith(link.title, search));

            if (filteredLinks.length === 0) {
              return null;
            }

            filteredLinksCount += filteredLinks.length;

            return {
              ...link,
              links: filteredLinks.sort((a: any, b: any) => formatter.compare(a.title, b.title)),
            };
          })
          .filter(Boolean),
        linksCount: filteredLinksCount,
      };
    }

    const filteredLinks = section.links
      .filter((link) => startsWith(link.title, search))
      .sort((a, b) => formatter.compare(a.title, b.title));

    return {
      ...section,
      links: filteredLinks,
      linksCount: filteredLinks.length,
    };
  });

  return {
    menu: data,
    searchValue: search,
    onSearchChange: setSearch,
  };
};
</file>

<file path="admin/src/components/CustomRadioGroup/index.ts">
/* eslint-disable */
export * from './CustomRadioGroup';
</file>

<file path="admin/src/components/DataManagerProvider/tests/data.ts">
export const data = {
  components: {
    'default.closingperiod': {
      uid: 'default.closingperiod',
      category: '',
      schema: {
        icon: 'angry',
        name: 'closingperiod',
        description: '',
        connection: 'default',
        collectionName: 'components_closingperiods',
        attributes: [
          {
            name: 'label',
            type: 'string',
          },

          {
            name: 'start_date',
            type: 'date',
            required: true,
          },
          {
            name: 'end_date',
            type: 'date',
            required: true,
          },
          {
            name: 'media',
            type: 'media',
            multiple: false,
            required: false,
          },
          { name: 'dish', component: 'default.dish', type: 'component' },
        ],
      },
    },
    'default.dish': {
      uid: 'default.dish',
      category: 'default',
      schema: {
        icon: 'book',
        name: 'dish',
        description: '',
        connection: 'default',
        collectionName: 'components_dishes',
        attributes: [
          {
            name: 'name',
            type: 'string',
            required: true,
            default: 'My super dish',
          },
          {
            name: 'description',
            type: 'text',
          },
          {
            name: 'price',
            type: 'float',
          },
          {
            name: 'picture',
            type: 'media',
            multiple: false,
            required: false,
          },
          {
            name: 'very_long_description',
            type: 'richtext',
          },
          {
            name: 'category',
            relation: 'oneToOne',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
          },
        ],
      },
    },
    'default.openingtimes': {
      uid: 'default.openingtimes',
      category: 'default',
      schema: {
        icon: 'calendar',
        name: 'openingtimes',
        description: '',
        connection: 'default',
        collectionName: 'components_openingtimes',
        attributes: [
          {
            name: 'label',
            type: 'string',
            required: true,
            default: 'something',
          },
          {
            name: 'time',
            type: 'string',
          },
        ],
      },
    },
    'default.restaurantservice': {
      uid: 'default.restaurantservice',
      category: 'default',
      schema: {
        icon: 'strapi',
        name: 'restaurantservice',
        description: '',
        connection: 'default',
        collectionName: 'components_restaurantservices',
        attributes: [
          {
            name: 'name',
            type: 'string',
            required: true,
            default: 'something',
          },
          {
            name: 'media',
            type: 'media',
            multiple: false,
            required: false,
          },
          { name: 'is_available', type: 'boolean', required: true, default: true },
        ],
      },
    },
  },
  contentTypes: {
    'plugin::myplugin.test': {
      uid: '',
      plugin: 'myplugin',
      schema: {
        name: 'test',
        description: '',
        connection: 'default',
        collectionName: 'myplugin_test',
        attributes: [
          {
            name: 'type',
            type: 'string',
            required: true,
            unique: true,
            configurable: true,
          },
        ],
      },
    },
    'plugin::users-permissions.role': {
      uid: 'plugin::users-permissions.role',
      plugin: 'users-permissions',
      schema: {
        name: 'role',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          {
            name: 'name',
            type: 'string',
            minLength: 3,
            required: true,
            configurable: false,
          },
          { type: 'string', configurable: false, name: 'description' },
          { name: 'type', type: 'string', unique: true, configurable: false },
          {
            name: 'permissions',
            relation: 'oneToMany',
            target: 'plugin::users-permissions.permission',
            plugin: 'users-permissions',
            targetAttribute: 'role',
            configurable: false,
            type: 'relation',
          },
          {
            name: 'users',
            relation: 'oneToMany',
            target: 'plugin::users-permissions.user',
            plugin: 'users-permissions',
            type: 'relation',
            targetAttribute: 'role',
          },
        ],
      },
    },
    'api::address.address': {
      uid: 'api::address.address',
      schema: {
        name: 'address',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          { name: 'geolocation', type: 'json', required: true },
          { name: 'city', type: 'string', required: true },
          { name: 'postal_coder', type: 'string' },
          {
            name: 'category',
            relation: 'oneToOne',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
          },
          { name: 'cover', type: 'media', multiple: false, required: false },
          { name: 'images', type: 'media', multiple: true, required: false },
          { name: 'full_name', type: 'string', required: true },
        ],
      },
    },
    'api::menusection.menusection': {
      uid: 'api::menusection.menusection',
      schema: {
        name: 'menusection',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          { name: 'name', type: 'string', required: true, minLength: 6 },
          {
            name: 'dishes',
            component: 'default.dish',
            type: 'component',
            repeatable: true,
          },
          {
            name: 'menu',
            relation: 'manyToOne',
            target: 'api::menu.menu',
            targetAttribute: 'menusections',
            type: 'relation',
          },
        ],
      },
    },
    'api::country.country': {
      uid: 'api::country.country',
      schema: {
        name: 'country',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          { name: 'name', type: 'string', required: true, minLength: 3 },
          { name: 'code', type: 'string', maxLength: 3, unique: true, minLength: 2 },
        ],
      },
    },
    'plugin::users-permissions.user': {
      uid: 'plugin::users-permissions.user',
      plugin: 'users-permissions',
      schema: {
        name: 'users',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          {
            name: 'username',
            type: 'string',
            minLength: 3,
            unique: true,
            configurable: false,
            required: true,
          },
          {
            name: 'email',
            type: 'email',
            minLength: 6,
            configurable: false,
            required: true,
          },
          { name: 'provider', type: 'string', configurable: false },
          {
            name: 'password',
            type: 'password',
            minLength: 6,
            configurable: false,
            private: true,
          },
          {
            name: 'resetPasswordToken',
            type: 'string',
            configurable: false,
            private: true,
          },
          { name: 'confirmed', type: 'boolean', default: false, configurable: false },
          { name: 'blocked', type: 'boolean', default: false, configurable: false },
          {
            name: 'role',
            relation: 'manyToOne',
            target: 'plugin::users-permissions.role',
            plugin: 'users-permissions',
            targetAttribute: 'users',
            type: 'relation',
          },
          { name: 'picture', type: 'media', multiple: false, required: false },
        ],
      },
    },
    'api::review.review': {
      uid: 'api::review.review',
      schema: {
        name: 'review',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          { name: 'comment', type: 'text', required: true },
          { name: 'rating', type: 'integer', required: true, min: 1, max: 5 },
          {
            name: 'likes',
            relation: 'oneToMany',
            target: 'api::like.like',
            targetAttribute: 'review',
            type: 'relation',
          },
          {
            name: 'author',
            relation: 'oneToOne',
            target: 'plugin::users-permissions.user',
            targetAttribute: null,
            plugin: 'users-permissions',
            type: 'relation',
          },
          {
            name: 'restaurant',
            relation: 'oneToOne',
            target: 'api::restaurant.restaurant',
            targetAttribute: null,
            type: 'relation',
          },
        ],
      },
    },
    'api::like.like': {
      uid: 'api::like.like',
      schema: {
        name: 'like',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          {
            name: 'author',
            relation: 'oneToOne',
            target: 'plugin::users-permissions.user',
            targetAttribute: null,
            plugin: 'users-permissions',
            type: 'relation',
          },
          {
            name: 'review',
            relation: 'manyToOne',
            target: 'api::review.review',
            targetAttribute: 'likes',
            type: 'relation',
          },
        ],
      },
    },
    'api::category.category': {
      uid: 'api::category.category',
      schema: {
        name: 'category',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [{ name: 'name', type: 'string' }],
      },
    },
    'plugin::users-permissions.permission': {
      uid: 'plugin::users-permissions.permission',
      plugin: 'users-permissions',
      schema: {
        name: 'permission',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          { name: 'type', type: 'string', required: true, configurable: false },
          { name: 'controller', type: 'string', required: true, configurable: false },
          { name: 'action', type: 'string', required: true, configurable: false },
          { name: 'enabled', type: 'boolean', required: true, configurable: false },
          { name: 'policy', type: 'string', configurable: false },
          {
            name: 'role',
            relation: 'manyToOne',
            target: 'plugin::users-permissions.role',
            plugin: 'users-permissions',
            targetAttribute: 'permissions',
            type: 'relation',
          },
        ],
      },
    },
    'api::menu.menu': {
      uid: 'api::menu.menu',
      schema: {
        name: 'menu',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          { name: 'description', type: 'text' },
          {
            name: 'menusections',
            relation: 'oneToMany',
            target: 'api::menusection.menusection',
            targetAttribute: 'menu',
            type: 'relation',
          },
          {
            name: 'restaurant',
            relation: 'oneToOne',
            target: 'api::restaurant.restaurant',
            targetAttribute: 'menu',
            type: 'relation',
          },
        ],
      },
    },
    'api::restaurant.restaurant': {
      uid: 'api::restaurant.restaurant',
      schema: {
        name: 'restaurant',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          {
            name: 'price_range',
            enum: ['very_cheap', 'cheap', 'average', 'expensive', 'very_expensive'],
            type: 'enumeration',
          },
          {
            name: 'closing_period',
            component: 'default.closingperiod',
            type: 'component',
          },
          { name: 'name', maxLength: 50, required: true, minLength: 5, type: 'string' },
          {
            name: 'address',
            relation: 'oneToOne',
            target: 'api::address.address',
            targetAttribute: null,
            type: 'relation',
          },
          { name: 'cover', type: 'media', multiple: false, required: false },
          { name: 'images', type: 'media', multiple: true, required: false },
          { name: 'short_description', type: 'text' },
          { name: 'since', type: 'date' },
          {
            name: 'categories',
            relation: 'oneToMany',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
          },
          { name: 'description', type: 'richtext', required: true },
          {
            name: 'services',
            component: 'default.restaurantservice',
            repeatable: true,
            type: 'component',
          },
          {
            name: 'menu',
            nature: 'oneToOne',
            target: 'api::menu.menu',
            dominant: false,
            targetAttribute: 'restaurant',
            unique: false,
          },
          {
            name: 'opening_times',
            component: 'default.openingtimes',
            type: 'component',
            repeatable: true,
            min: 1,
            max: 10,
          },
          {
            name: 'dz',
            type: 'dynamiczone',
            components: [
              'default.closingperiod',
              'default.dish',
              'default.openingtimes',
              'default.restaurantservice',
            ],
          },
        ],
      },
    },
    'api::homepage.homepage': {
      uid: 'api::homepage.homepage',
      schema: {
        name: 'homepage',
        attributes: [
          { name: 'title', type: 'string' },
          { name: 'description', type: 'string' },
          { name: 'homepageuidfield', type: 'uid', targetField: 'description' },
        ],
      },
    },
  },
};
</file>

<file path="admin/src/components/DataManagerProvider/tests/reducerAddAttributeAction.test.ts">
import { ADD_ATTRIBUTE } from '../constants';
import { initialState, reducer } from '../reducer';

import type { Component, ContentType } from '../../../types';

describe('CTB | components | DataManagerProvider | reducer | ADD_ATTRIBUTE', () => {
  describe('Adding a common field that is not a relation', () => {
    it('Should add a text field to a content type correctly', () => {
      const contentType = {
        uid: 'api::category.category',
        schema: {
          name: 'category',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [{ name: 'test', type: 'string' }],
        },
      };
      const state: any = {
        ...initialState,
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        attributeToSet: {
          type: 'string',
          name: 'name',
          default: 'something',
          private: true,
          required: true,
          unique: true,
          maxLength: 3,
          minLength: 1,
        },
        forTarget: 'contentType',
        targetUid: 'api::address.address',
        initialAttribute: {},
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        modifiedData: {
          components: {},
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [
                ...contentType.schema.attributes,
                {
                  name: 'name',
                  type: 'string',
                  default: 'something',
                  private: true,
                  required: true,
                  unique: true,
                  maxLength: 3,
                  minLength: 1,
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should add an integer field to a component that is an attribute of a content type', () => {
      const compoSchema: Component = {
        uid: 'default.dish',
        category: 'default',
        schema: {
          icon: 'book',
          name: 'dish',
          description: '',
          connection: 'default',
          collectionName: 'components_dishes',
          attributes: [
            {
              name: 'name',
              type: 'string',
              required: true,
              default: 'My super dish',
            },
            {
              name: 'description',
              type: 'text',
            },
            {
              name: 'price',
              type: 'float',
            },
            {
              name: 'picture',
              type: 'media',
              multiple: false,
              required: false,
            },
            {
              name: 'very_long_description',
              type: 'richtext',
            },
            {
              name: 'category',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              type: 'relation',
            },
          ],
        },
      };
      const contentType: ContentType = {
        uid: 'api::country.country',
        schema: {
          name: 'country',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [
            { name: 'name', type: 'string', required: true, minLength: 3 },
            { name: 'code', type: 'string', maxLength: 3, unique: true, minLength: 2 },
            { name: 'compo_field', type: 'component', component: 'default.dish' },
          ],
        },
      };

      const state: any = {
        ...initialState,
        components: {
          'default.dish': compoSchema,
        },
        modifiedData: {
          components: {
            'default.dish': compoSchema,
          },
          contentType,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        attributeToSet: {
          name: 'test',
          type: 'integer',
          default: 2,
          private: true,
          required: true,
          min: null,
        },
        forTarget: 'components',
        targetUid: 'default.dish',
        initialAttribute: {},
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        components: {
          'default.dish': compoSchema,
        },
        modifiedData: {
          components: {
            'default.dish': {
              ...compoSchema,

              schema: {
                ...compoSchema.schema,
                attributes: [
                  ...compoSchema.schema.attributes,
                  {
                    name: 'test',
                    type: 'integer',
                    default: 2,
                    private: true,
                    required: true,
                    min: null,
                  },
                ],
              },
            },
          },
          contentType,
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('Adding a component field attribute', () => {
    it('Should create the component attribute and add the component to the modifiedData.components if the component is not in the object', () => {
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [
            { name: 'geolocation', type: 'json', required: true },
            { name: 'city', type: 'string', required: true },
            { name: 'postal_coder', type: 'string' },
            {
              name: 'category',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              type: 'relation',
            },
            { name: 'cover', type: 'media', multiple: false, required: false },
            { name: 'images', type: 'media', multiple: true, required: false },
            { name: 'full_name', type: 'string', required: true },
          ],
        },
      };
      const componentToAddUID = 'default.dish';
      const componentSchema: Component = {
        uid: 'default.dish',
        category: 'default',
        schema: {
          icon: 'book',
          name: 'dish',
          description: '',
          connection: 'default',
          collectionName: 'components_dishes',
          attributes: [
            {
              name: 'name',
              type: 'string',
              required: true,
              default: 'My super dish',
            },
            {
              name: 'description',
              type: 'text',
            },
            {
              name: 'price',
              type: 'float',
            },
            {
              name: 'picture',
              type: 'media',
              multiple: false,
              required: false,
            },
            {
              name: 'very_long_description',
              type: 'richtext',
            },
            {
              name: 'category',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              type: 'relation',
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        components: {
          [componentToAddUID]: componentSchema,
        },
        initialComponents: {
          [componentToAddUID]: componentSchema,
        },
        contentTypes: {},
        initialContentTypes: {},
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        attributeToSet: {
          type: 'component',
          repeatable: true,
          name: 'compoField',
          component: componentToAddUID,
          required: true,
          max: 2,
          min: 1,
        },
        forTarget: 'contentType',
        targetUid: 'api::address.address',
        initialAttribute: {},
        shouldAddComponentToData: true,
      };

      const expected = {
        ...initialState,
        components: {
          [componentToAddUID]: componentSchema,
        },
        initialComponents: {
          [componentToAddUID]: componentSchema,
        },
        contentTypes: {},
        initialContentTypes: {},
        modifiedData: {
          components: {
            [componentToAddUID]: componentSchema,
          },
          contentType: {
            ...contentType,

            schema: {
              ...contentType.schema,
              attributes: [
                ...contentType.schema.attributes,
                {
                  name: 'compoField',
                  type: 'component',
                  repeatable: true,
                  component: componentToAddUID,
                  required: true,
                  max: 2,
                  min: 1,
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should create the component attribute and add the component to the modifiedData.components and its nested components if none of the added components are in the object', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [
            { name: 'geolocation', type: 'json', required: true },
            { name: 'city', type: 'string', required: true },
            { name: 'postal_coder', type: 'string' },
            {
              name: 'category',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              type: 'relation',
            },
            { name: 'cover', type: 'media', multiple: false, required: false },
            { name: 'images', type: 'media', multiple: true, required: false },
            { name: 'full_name', type: 'string', required: true },
          ],
        },
      };
      const componentToAddUID = 'default.closingperiod';
      const componentSchema = {
        uid: 'default.closingperiod',
        category: '',
        schema: {
          icon: 'angry',
          name: 'closingperiod',
          description: '',
          connection: 'default',
          collectionName: 'components_closingperiods',
          attributes: [
            {
              name: 'label',
              type: 'string',
            },
            {
              name: 'start_date',
              type: 'date',
              required: true,
            },
            {
              name: 'end_date',
              type: 'date',
              required: true,
            },
            {
              name: 'media',
              type: 'media',
              multiple: false,
              required: false,
            },
            { name: 'dish', component: 'default.dish', type: 'component' },
          ],
        },
      };

      const dishComponentSchema = {
        uid: 'default.dish',
        category: 'default',
        schema: {
          icon: 'book',
          name: 'dish',
          description: '',
          connection: 'default',
          collectionName: 'components_dishes',
          attributes: [
            {
              name: 'name',
              type: 'string',
              required: true,
              default: 'My super dish',
            },
            {
              name: 'description',
              type: 'text',
            },
            {
              name: 'price',
              type: 'float',
            },
            {
              name: 'picture',
              type: 'media',
              multiple: false,
              required: false,
            },
            {
              name: 'very_long_description',
              type: 'richtext',
            },
            {
              name: 'category',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              type: 'relation',
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        components: {
          [componentToAddUID]: componentSchema,
          'default.dish': dishComponentSchema,
        },
        initialComponents: {
          [componentToAddUID]: componentSchema,
          'default.dish': dishComponentSchema,
        },
        initialContentTypes: {
          [contentTypeUID]: contentType,
        },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        attributeToSet: {
          type: 'component',
          repeatable: true,
          name: 'compoField',
          component: componentToAddUID,
          required: true,
          max: 2,
          min: 1,
        },
        forTarget: 'contentType',
        targetUid: 'api::address.address',
        initialAttribute: {},
        shouldAddComponentToData: true,
      };

      const expected = {
        ...initialState,
        components: {
          [componentToAddUID]: componentSchema,
          'default.dish': dishComponentSchema,
        },
        initialComponents: {
          [componentToAddUID]: componentSchema,
          'default.dish': dishComponentSchema,
        },
        initialContentTypes: {
          [contentTypeUID]: contentType,
        },
        modifiedData: {
          components: {
            [componentToAddUID]: componentSchema,
            'default.dish': dishComponentSchema,
          },
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [
                ...contentType.schema.attributes,
                {
                  name: 'compoField',
                  type: 'component',
                  repeatable: true,
                  component: componentToAddUID,
                  required: true,
                  max: 2,
                  min: 1,
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should create the component attribute and add the component to the modifiedData.components and only add the nested components that are not in the modifiedData.components object to keep previous the modifications', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [
            { name: 'geolocation', type: 'json', required: true },
            { name: 'city', type: 'string', required: true },
            { name: 'postal_coder', type: 'string' },
            {
              name: 'category',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              type: 'relation',
            },
            { name: 'cover', type: 'media', multiple: false, required: false },
            { name: 'images', type: 'media', multiple: true, required: false },
            { name: 'full_name', type: 'string', required: true },
          ],
        },
      };
      const componentToAddUID = 'default.closingperiod';
      const componentSchema = {
        uid: 'default.closingperiod',
        category: '',
        schema: {
          icon: 'angry',
          name: 'closingperiod',
          description: '',
          connection: 'default',
          collectionName: 'components_closingperiods',
          attributes: [
            {
              name: 'label',
              type: 'string',
            },

            {
              name: 'start_date',
              type: 'date',
              required: true,
            },
            {
              name: 'end_date',
              type: 'date',
              required: true,
            },
            {
              name: 'media',
              type: 'media',
              multiple: false,
              required: false,
            },
            { name: 'dish', component: 'default.dish', type: 'component' },
          ],
        },
      };

      const dishComponentSchema = {
        uid: 'default.dish',
        category: 'default',
        schema: {
          icon: 'book',
          name: 'dish',
          description: '',
          connection: 'default',
          collectionName: 'components_dishes',
          attributes: [
            {
              name: 'name',
              type: 'string',
              required: true,
              default: 'My super dish',
            },
            {
              name: 'description',
              type: 'text',
            },
            {
              name: 'price',
              type: 'float',
            },
            {
              name: 'picture',
              type: 'media',
              multiple: false,
              required: false,
            },
            {
              name: 'very_long_description',
              type: 'richtext',
            },
            {
              name: 'category',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              type: 'relation',
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        components: {
          [componentToAddUID]: componentSchema,
          'default.dish': dishComponentSchema,
        },
        initialComponents: {
          [componentToAddUID]: componentSchema,
          'default.dish': dishComponentSchema,
        },
        initialContentTypes: {
          [contentTypeUID]: contentType,
        },
        modifiedData: {
          components: {
            'default.dish': {
              ...dishComponentSchema,
              schema: {
                ...dishComponentSchema.schema,
                attributes: [
                  ...dishComponentSchema.schema.attributes,
                  { name: 'test', type: 'string' },
                ],
              },
            },
          },
          contentType,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        attributeToSet: {
          type: 'component',
          repeatable: true,
          name: 'compoField',
          component: componentToAddUID,
          required: true,
          max: 2,
          min: 1,
        },
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        initialAttribute: {},
        shouldAddComponentToData: true,
      };

      const expected = {
        ...initialState,
        components: {
          [componentToAddUID]: componentSchema,
          'default.dish': dishComponentSchema,
        },
        initialComponents: {
          [componentToAddUID]: componentSchema,
          'default.dish': dishComponentSchema,
        },
        initialContentTypes: {
          [contentTypeUID]: contentType,
        },
        modifiedData: {
          components: {
            'default.dish': {
              ...dishComponentSchema,
              schema: {
                ...dishComponentSchema.schema,
                attributes: [
                  ...dishComponentSchema.schema.attributes,
                  { name: 'test', type: 'string' },
                ],
              },
            },
            [componentToAddUID]: componentSchema,
          },
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [
                ...contentType.schema.attributes,
                {
                  name: 'compoField',
                  type: 'component',
                  repeatable: true,
                  component: componentToAddUID,
                  required: true,
                  max: 2,
                  min: 1,
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should create the component correctly in case of creating the component on the fly', () => {
      const componentToCreateUID = 'default.new-compo';
      const componentToCreate = {
        uid: componentToCreateUID,
        isTemporary: true,
        category: 'default',
        schema: {
          name: 'newCompo',
          icon: 'ad',
          attributes: {},
        },
      };
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [
            { name: 'images', type: 'media', multiple: true, required: false },
            { name: 'full_name', type: 'string', required: true },
          ],
        },
      };

      const state: any = {
        ...initialState,
        components: {
          [componentToCreateUID]: componentToCreate,
        },
        modifiedData: {
          components: {
            [componentToCreateUID]: componentToCreate,
          },
          contentType,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        attributeToSet: {
          name: 'newCompo',
          type: 'component',
          repeatable: false,
          component: componentToCreateUID,
        },
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        initialAttribute: undefined,
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        components: {
          [componentToCreateUID]: componentToCreate,
        },
        modifiedData: {
          components: {
            [componentToCreateUID]: componentToCreate,
          },
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [
                ...contentType.schema.attributes,
                {
                  name: 'newCompo',
                  type: 'component',
                  repeatable: false,
                  component: componentToCreateUID,
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('Adding a dynamic zone', () => {
    it('Should create the dynamiczone attribute correctly', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [
            { name: 'images', type: 'media', multiple: true, required: false },
            { name: 'full_name', type: 'string', required: true },
          ],
        },
      };

      const state: any = {
        ...initialState,
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        attributeToSet: {
          type: 'dynamiczone',
          components: [],
          name: 'dz',
        },
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        initialAttribute: {},
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        modifiedData: {
          components: {},
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [
                ...contentType.schema.attributes,
                { name: 'dz', type: 'dynamiczone', components: [] },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('Adding a relation with another content type', () => {
    it('Should add the relation attribute correctly for a content type', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [
            { name: 'geolocation', type: 'json', required: true },
            { name: 'city', type: 'string', required: true },
            { name: 'postal_coder', type: 'string' },
            {
              name: 'category',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              type: 'relation',
            },
            { name: 'cover', type: 'media', multiple: false, required: false },
            { name: 'images', type: 'media', multiple: true, required: false },
            { name: 'full_name', type: 'string', required: true },
          ],
        },
      };
      const targetContentTypeUID = 'api::category.category';
      const targetContentTypeSchema = {
        uid: 'api::category.category',
        schema: {
          name: 'category',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [{ name: 'name', type: 'string' }],
        },
      };

      const state: any = {
        ...initialState,
        contentTypes: {
          [contentTypeUID]: contentType,
          [targetContentTypeUID]: targetContentTypeSchema,
        },
        initialContentTypes: {
          [contentTypeUID]: contentType,
          [targetContentTypeUID]: targetContentTypeSchema,
        },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        attributeToSet: {
          name: 'categories',
          relation: 'oneToMany',
          targetAttribute: 'address',
          target: targetContentTypeUID,
          type: 'relation',
        },
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        initialAttribute: {},
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        contentTypes: {
          [contentTypeUID]: contentType,
          [targetContentTypeUID]: targetContentTypeSchema,
        },
        initialContentTypes: {
          [contentTypeUID]: contentType,
          [targetContentTypeUID]: targetContentTypeSchema,
        },
        modifiedData: {
          components: {},
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [
                ...contentType.schema.attributes,
                {
                  name: 'categories',
                  relation: 'oneToMany',
                  targetAttribute: 'address',
                  target: targetContentTypeUID,
                  type: 'relation',
                },
              ],
            },
          },
        },
      };

      // const expected = state.setIn(
      //   ['modifiedData', 'contentType', 'schema', 'attributes', 'categories'],
      //   fromJS({
      //     relation: 'oneToMany',
      //     targetAttribute: 'address',
      //     target: targetContentTypeUID,
      //     type: 'relation',
      //   })
      // );

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should add the relation attribute correctly for a component', () => {
      const componentUID = 'default.dish';
      const targetContentTypeUID = 'api::category.category';
      const compoSchema = {
        uid: 'default.dish',
        category: 'default',
        schema: {
          icon: 'book',
          name: 'dish',
          description: '',
          connection: 'default',
          collectionName: 'components_dishes',
          attributes: [
            {
              name: 'name',
              type: 'string',
              required: true,
              default: 'My super dish',
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        components: { [componentUID]: compoSchema },
        initialComponents: { [componentUID]: compoSchema },
        modifiedData: {
          components: {},
          component: compoSchema,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        attributeToSet: {
          name: 'address',
          relation: 'oneToOne',
          targetAttribute: null,
          target: targetContentTypeUID,
          type: 'relation',
        },
        forTarget: 'component',
        targetUid: componentUID,
        initialAttribute: {},
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        components: { [componentUID]: compoSchema },
        initialComponents: { [componentUID]: compoSchema },
        modifiedData: {
          components: {},
          component: {
            ...compoSchema,
            schema: {
              ...compoSchema.schema,
              attributes: [
                ...compoSchema.schema.attributes,
                {
                  name: 'address',
                  relation: 'oneToOne',
                  targetAttribute: null,
                  target: targetContentTypeUID,
                  type: 'relation',
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should add the relation attribute correctly for a component from the modifiedData.components object', () => {
      const componentUID = 'default.dish';
      const targetContentTypeUID = 'api::category.category';

      const compoSchema = {
        uid: 'default.dish',
        category: 'default',
        schema: {
          icon: 'book',
          name: 'dish',
          description: '',
          connection: 'default',
          collectionName: 'components_dishes',
          attributes: [
            {
              name: 'name',
              type: 'string',
              required: true,
              default: 'My super dish',
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        components: { [componentUID]: compoSchema },
        initialComponents: { [componentUID]: compoSchema },
        modifiedData: {
          components: { [componentUID]: compoSchema },
          contenType: {},
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        attributeToSet: {
          name: 'address',
          relation: 'oneToOne',
          targetAttribute: null,
          target: targetContentTypeUID,
          type: 'relation',
          private: true,
        },
        forTarget: 'components',
        targetUid: componentUID,
        initialAttribute: {},
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        components: { [componentUID]: compoSchema },
        initialComponents: { [componentUID]: compoSchema },
        modifiedData: {
          components: {
            [componentUID]: {
              ...compoSchema,
              schema: {
                ...compoSchema.schema,
                attributes: [
                  ...compoSchema.schema.attributes,
                  {
                    name: 'address',
                    relation: 'oneToOne',
                    targetAttribute: null,
                    target: targetContentTypeUID,
                    type: 'relation',
                    private: true,
                  },
                ],
              },
            },
          },
          contenType: {},
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('Adding a relation with the same content type', () => {
    it('Should not create an opposite attribute if the relation is oneWay', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [{ name: 'full_name', type: 'string', required: true }],
        },
      };

      const state: any = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        attributeToSet: {
          name: 'address',
          relation: 'oneToOne',
          targetAttribute: null,
          target: contentTypeUID,
          type: 'relation',
        },
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [
                ...contentType.schema.attributes,
                {
                  name: 'address',
                  relation: 'oneToOne',
                  targetAttribute: null,
                  target: contentTypeUID,
                  type: 'relation',
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should not create an opposite attribute if the relation is manyWay', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [{ name: 'full_name', type: 'string', required: true }],
        },
      };

      const state: any = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const action: any = {
        type: ADD_ATTRIBUTE,
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        attributeToSet: {
          name: 'addresses',
          relation: 'oneToMany',
          targetAttribute: null,
          target: contentTypeUID,
          type: 'relation',
        },
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [
                ...contentType.schema.attributes,
                {
                  name: 'addresses',
                  relation: 'oneToMany',
                  targetAttribute: null,
                  target: contentTypeUID,
                  type: 'relation',
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should handle the oneToOne relation correctly and create the opposite attribute', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [
            { name: 'images', type: 'media', multiple: true, required: false },
            { name: 'full_name', type: 'string', required: true },
          ],
        },
      };

      const state: any = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const name = 'address_left_side';
      const targetAttribute = 'address_right_side';
      const attribute = {
        name,
        relation: 'oneToOne',
        targetAttribute,
        target: contentTypeUID,
        type: 'relation',
      };
      const action: any = {
        type: ADD_ATTRIBUTE,
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        attributeToSet: attribute,
        shouldAddComponentToData: false,
      };
      const oppositeAttribute = {
        name: targetAttribute,
        relation: 'oneToOne',
        target: contentTypeUID,
        targetAttribute: name,
        type: 'relation',
      };

      const expected = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [...contentType.schema.attributes, attribute, oppositeAttribute],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should handle the oneToMany relation correctly and create the opposite attribute', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [{ name: 'full_name', type: 'string', required: true }],
        },
      };

      const state: any = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const name = 'address_left_side';
      const targetAttribute = 'address_right_side';

      const attribute = {
        name,
        relation: 'oneToMany',
        targetAttribute,
        target: contentTypeUID,
        type: 'relation',
      };
      const action: any = {
        type: ADD_ATTRIBUTE,
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        attributeToSet: attribute,
        shouldAddComponentToData: false,
      };
      const oppositeAttribute = {
        name: targetAttribute,
        relation: 'manyToOne',
        target: contentTypeUID,
        targetAttribute: name,
        type: 'relation',
      };

      const expected = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [...contentType.schema.attributes, attribute, oppositeAttribute],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should handle the manyToOne relation correctly and create the opposite attribute', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [{ name: 'full_name', type: 'string', required: true }],
        },
      };

      const state: any = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const name = 'address_left_side';
      const targetAttribute = 'address_right_side';
      const attribute = {
        name,
        relation: 'manyToOne',
        targetAttribute,
        target: contentTypeUID,
        type: 'relation',
      };
      const action: any = {
        type: ADD_ATTRIBUTE,
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        attributeToSet: attribute,
        shouldAddComponentToData: false,
      };
      const oppositeAttribute = {
        name: targetAttribute,
        relation: 'oneToMany',
        target: contentTypeUID,
        targetAttribute: name,
        type: 'relation',
      };

      const expected = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [...contentType.schema.attributes, attribute, oppositeAttribute],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should handle the manyToMany relation correctly and create the opposite attribute', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [{ name: 'full_name', type: 'string', required: true }],
        },
      };

      const state: any = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const name = 'address_left_side';
      const targetAttribute = 'address_right_side';
      const attribute = {
        name,
        relation: 'manyToMany',
        targetAttribute,
        target: contentTypeUID,
        type: 'relation',
      };
      const action: any = {
        type: ADD_ATTRIBUTE,
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        attributeToSet: attribute,
        shouldAddComponentToData: false,
      };
      const oppositeAttribute = {
        name: targetAttribute,
        relation: 'manyToMany',
        target: contentTypeUID,
        targetAttribute: name,
        type: 'relation',
      };

      const expected = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [...contentType.schema.attributes, attribute, oppositeAttribute],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/tests/reducerAddCustomFieldAttributeAction.test.ts">
import cloneDeep from 'lodash/cloneDeep';

import { ADD_CUSTOM_FIELD_ATTRIBUTE } from '../constants';
import { reducer, initialState } from '../reducer';

import type { Component, ContentType } from '../../../types';

describe('CTB | components | DataManagerProvider | reducer | ADD_CUSTOM_FIELD_ATTRIBUTE', () => {
  it('adds a custom field to a contentType', () => {
    const contentType = {
      uid: 'api::test.test',
      schema: {
        name: 'test',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [{ name: 'test', type: 'string' }],
      },
    };

    const newCustomFieldAttribute = {
      // The underlying data type should be in the action and expected
      // The type is converted to customField on the server,
      type: 'string',
      name: 'color',
      options: { format: 'hex' },
      customField: 'plugin::mycustomfields.color',
    };

    const action: any = {
      type: ADD_CUSTOM_FIELD_ATTRIBUTE,
      attributeToSet: newCustomFieldAttribute,
      forTarget: 'contentType',
      targetUid: 'api::test.test',
      initialAttribute: {},
    };

    const state: any = {
      ...initialState,
      modifiedData: {
        components: {},
        contentType,
      },
    };

    const updatedContentType = cloneDeep(contentType);
    updatedContentType.schema.attributes.push(newCustomFieldAttribute);

    const expected = {
      ...initialState,
      modifiedData: {
        components: {},
        contentType: updatedContentType,
      },
    };

    expect(reducer(state, action)).toEqual(expected);
  });

  it('adds a custom field to a component', () => {
    const componentSchema = {
      uid: 'basic.simple',
      category: 'basic',
      schema: {
        icon: 'ambulance',
        name: 'simple',
        description: '',
        connection: 'basic',
        collectionName: 'components_basic_simples',
        attributes: [
          { type: 'string', required: true, name: 'name' },
          { type: 'string', name: 'test' },
        ],
      },
    };

    const newCustomFieldAttribute = {
      // The underlying data type should be in the action and expected
      // The type is converted to customField on the server,
      type: 'string',
      name: 'color',
      options: { format: 'hex' },
      customField: 'plugin::mycustomfields.color',
    };

    const action: any = {
      type: ADD_CUSTOM_FIELD_ATTRIBUTE,
      attributeToSet: newCustomFieldAttribute,
      forTarget: 'component',
      targetUid: 'basic.simple',
      initialAttribute: {},
    };

    const state: any = {
      ...initialState,
      modifiedData: {
        components: {},
        component: componentSchema,
      },
    };

    const updatedComponent = cloneDeep(componentSchema);
    updatedComponent.schema.attributes.push(newCustomFieldAttribute);

    const expected = {
      ...initialState,
      modifiedData: {
        components: {},
        component: updatedComponent,
      },
    };

    expect(reducer(state, action)).toEqual(expected);
  });

  it('adds a custom field to a component that is an attribute of a content type', () => {
    const componentSchema: Component = {
      uid: 'basic.simple',
      category: 'basic',
      schema: {
        icon: 'ambulance',
        name: 'simple',
        description: '',
        connection: 'basic',
        collectionName: 'components_basic_simples',
        attributes: [
          { type: 'string', required: true, name: 'name' },
          { type: 'string', name: 'test' },
        ],
      },
    };

    const contentType: ContentType = {
      uid: 'api::test.test',
      schema: {
        name: 'test',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [
          { name: 'test', type: 'string' },
          { name: 'testcompo', type: 'component', component: 'basic.simple' },
        ],
      },
    };

    const state: any = {
      ...initialState,
      components: {
        'basic.simple': componentSchema,
      },
      modifiedData: {
        components: {
          'basic.simple': componentSchema,
        },
        contentType,
      },
    };

    const newCustomFieldAttribute = {
      // The underlying data type should be in the action and expected
      // The type is converted to customField on the server,
      type: 'string',
      name: 'color',
      options: { format: 'hex' },
      customField: 'plugin::mycustomfields.color',
    };

    const action: any = {
      type: ADD_CUSTOM_FIELD_ATTRIBUTE,
      attributeToSet: newCustomFieldAttribute,
      forTarget: 'components',
      targetUid: 'basic.simple',
      initialAttribute: {},
    };

    const updatedComponent = cloneDeep(componentSchema);
    updatedComponent.schema.attributes.push(newCustomFieldAttribute);

    const expected = {
      ...initialState,
      components: {
        'basic.simple': componentSchema,
      },
      modifiedData: {
        components: {
          'basic.simple': updatedComponent,
        },
        contentType,
      },
    };

    expect(reducer(state, action)).toEqual(expected);
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/tests/reducerBasicActions.test.ts">
import get from 'lodash/get';

import * as actions from '../constants';
import { reducer, initialState } from '../reducer';

import { data as testData } from './data';

import type { Component } from '../../../types';

describe('CTB | components | DataManagerProvider | reducer | basics actions ', () => {
  it('Should return the initial state', () => {
    const state = { ...initialState };

    expect(reducer(state, { type: 'TEST' } as any)).toEqual(initialState);
  });

  describe('ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE', () => {
    it('should add the created component to the dynamic zone', () => {
      const createdComponent: Component = {
        uid: 'default.test',
        category: 'default',
        isTemporary: true,
        schema: {
          icon: 'book',
          name: 'test',
          collectionName: '',
          attributes: [],
        },
      };

      const components: Record<string, Component> = {
        'default.test': createdComponent,
        'default.other': {
          uid: 'default.other',
          category: 'default',
          schema: {
            icon: 'book',
            name: 'test',
            collectionName: '',
            attributes: [],
          },
        },
      };
      const contentType = {
        uid: 'api::test',
        schema: {
          name: 'test',
          attributes: [
            {
              name: 'dz',
              type: 'dynamiczone',
              components: ['default.other'],
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        components,
        modifiedData: {
          components,
          contentType,
        },
      };

      const expected = {
        ...initialState,
        components,
        modifiedData: {
          components,
          contentType: {
            uid: 'api::test',
            schema: {
              name: 'test',
              attributes: [
                {
                  name: 'dz',
                  type: 'dynamiczone',
                  components: ['default.other', 'default.test'],
                },
              ],
            },
          },
        },
      };

      const action: any = {
        type: actions.ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE,
        dynamicZoneTarget: 'dz',
        componentsToAdd: ['default.test'],
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('CHANGE_DYNAMIC_ZONE_COMPONENTS', () => {
    it('Should add the component to the dz field and to the modifiedData.components if the added component is not already in the modifiedData.components', () => {
      const componentUID = 'default.openingtimes';
      const component = testData.components[componentUID];

      const ct = testData.contentTypes['api::address.address'];

      const contentType = {
        ...ct,
        schema: {
          ...ct.schema,
          attributes: [
            {
              name: 'price_range',
              enum: ['very_cheap', 'cheap', 'average', 'expensive', 'very_expensive'],
              type: 'enumeration',
            },
            {
              name: 'opening_times',
              component: 'default.openingtimes',
              type: 'component',
              repeatable: true,
              min: 1,
              max: 10,
            },
            {
              name: 'dz',
              type: 'dynamiczone',
              components: ['default.openingtimes'],
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        components: testData.components,
        modifiedData: {
          components: {
            [componentUID]: component,
          },
          contentType,
        },
      };

      const expected = {
        ...initialState,
        components: testData.components,
        modifiedData: {
          components: {
            [componentUID]: component,
            'default.dish': testData.components['default.dish'],
          },
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [
                {
                  name: 'price_range',
                  enum: ['very_cheap', 'cheap', 'average', 'expensive', 'very_expensive'],
                  type: 'enumeration',
                },
                {
                  name: 'opening_times',
                  component: 'default.openingtimes',
                  type: 'component',
                  repeatable: true,
                  min: 1,
                  max: 10,
                },
                {
                  name: 'dz',
                  type: 'dynamiczone',
                  components: ['default.openingtimes', 'default.dish'],
                },
              ],
            },
          },
        },
      };

      const action: any = {
        type: actions.CHANGE_DYNAMIC_ZONE_COMPONENTS,
        dynamicZoneTarget: 'dz',
        newComponents: ['default.dish'],
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should add the component to the dz field and the nestedComponents the modifiedData.components', () => {
      const componentUID = 'default.openingtimes';
      const component = get(testData, ['components', componentUID]);

      const contentType = {
        uid: 'api::address.address',
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [{ name: 'dz', type: 'dynamiczone', components: [componentUID] }],
        },
      };

      const state: any = {
        ...initialState,
        components: testData.components,
        modifiedData: {
          components: {
            [componentUID]: component,
          },
          contentType,
        },
      };

      const componentToAddUid = 'default.closingperiod';

      const action: any = {
        type: actions.CHANGE_DYNAMIC_ZONE_COMPONENTS,
        dynamicZoneTarget: 'dz',
        newComponents: [componentToAddUid],
      };

      const expected = {
        ...initialState,
        components: testData.components,
        modifiedData: {
          components: {
            [componentUID]: component,
            'default.dish': testData.components['default.dish'],
            [componentToAddUid]: testData.components[componentToAddUid],
          },
          contentType: {
            uid: 'api::address.address',
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'dz', type: 'dynamiczone', components: [componentUID, componentToAddUid] },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('CREATE_COMPONENT_SCHEMA', () => {
    it('Should add the created component schema to the components object when creating a component using the left menu link', () => {
      const action: any = {
        type: actions.CREATE_COMPONENT_SCHEMA,
        data: { name: 'new component', icon: 'arrow-alt-circle-down' },
        componentCategory: 'test',
        schemaType: 'component',
        uid: 'test.new-component',
        shouldAddComponentToData: false,
      };

      const state: any = {
        ...initialState,
        components: testData.components,
        initialComponents: testData.components,
      };

      const expected = {
        ...initialState,
        components: {
          ...testData.components,
          [action.uid]: {
            uid: action.uid,
            isTemporary: true,
            category: action.componentCategory,
            schema: {
              ...action.data,
              attributes: [],
            },
          },
        },
        initialComponents: testData.components,
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should add the created component schema to the components object, create the attribute and also add the created component to modifiedData.components when using the add attribute modal', () => {
      const action: any = {
        type: actions.CREATE_COMPONENT_SCHEMA,
        data: { name: 'new component', icon: 'arrow-alt-circle-down' },
        componentCategory: 'test',
        schemaType: 'component',
        uid: 'test.new-component',
        shouldAddComponentToData: true,
      };
      const compoToCreate = {
        uid: action.uid,
        isTemporary: true,
        category: action.componentCategory,
        schema: {
          ...action.data,
          attributes: [],
        },
      };

      const state: any = {
        ...initialState,
        components: testData.components,
        initialComponents: testData.components,
        modifiedData: {
          components: {},
          contentType: { ok: true },
        },
      };

      const expected = {
        ...initialState,
        components: {
          ...testData.components,
          [action.uid]: compoToCreate,
        },
        initialComponents: testData.components,
        modifiedData: {
          components: {
            [action.uid]: compoToCreate,
          },
          contentType: { ok: true },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('CREATE_SCHEMA', () => {
    it('Should create a content type schema correctly', () => {
      const uid = 'api::test';
      const data = {
        collectionName: 'test',
        name: 'test',
      };

      const state = { ...initialState };

      const action: any = { type: actions.CREATE_SCHEMA, uid, data };

      const expected = {
        ...initialState,
        contentTypes: {
          [uid]: {
            uid,
            isTemporary: true,
            schema: {
              collectionName: data.collectionName,
              name: data.name,
              attributes: [],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('DELETE_NOT_SAVED_TYPE', () => {
    it('Should reset the components and and contentTypes object', () => {
      const state: any = {
        ...initialState,
        components: {
          foo: {},
          bar: {},
        },
        initialComponents: { foo: {} },
        contentTypes: {
          baz: {},
          bat: {},
        },
        initialContentTypes: {
          baz: {},
        },
      };

      const expected = {
        ...initialState,
        components: {
          foo: {},
        },
        initialComponents: { foo: {} },
        contentTypes: {
          baz: {},
        },
        initialContentTypes: {
          baz: {},
        },
      };

      const action: any = { type: actions.DELETE_NOT_SAVED_TYPE };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('GET_DATA_SUCCEEDED', () => {
    it('should add api data for the content type builder (content type, components and reserved names)', () => {
      const components = {
        'default.test': {
          uid: 'default.test',
          category: 'default',
          schema: {
            attributes: [],
          },
        },
      };
      const contentTypes = {
        'api::test.test': {
          uid: 'api::test.test',
          schema: {
            attributes: [],
          },
        },
      };
      const reservedNames = {
        models: ['admin', 'ctb'],
        attributes: ['attributes', 'length'],
      };

      const state = { ...initialState };
      const expected = {
        ...initialState,
        components,
        contentTypes,
        initialComponents: components,
        initialContentTypes: contentTypes,
        reservedNames,
        isLoading: false,
      };

      expect(
        reducer(state, {
          type: actions.GET_DATA_SUCCEEDED,
          components,
          contentTypes,
          reservedNames,
        } as any)
      ).toEqual(expected);
    });
  });

  describe('RELOAD_PLUGIN', () => {
    it('Should return the initial state constant', () => {
      const state = { ...initialState, component: { foo: {} } };

      expect(
        reducer(state, {
          type: actions.RELOAD_PLUGIN,
        } as any)
      ).toEqual(initialState);
    });
  });

  describe('REMOVE_COMPONENT_FROM_DYNAMIC_ZONE', () => {
    it('Should remove a component from a dynamic zone', () => {
      const components = {
        'default.openingtimes': {
          uid: 'default.openingtimes',
          category: 'default',
          schema: {
            icon: 'calendar',
            name: 'openingtimes',
            description: '',
            connection: 'default',
            collectionName: 'components_openingtimes',
            attributes: [
              {
                name: 'label',
                type: 'string',
                required: true,
                default: 'something',
              },
              {
                name: 'time',
                type: 'string',
              },
            ],
          },
        },
        'default.dish': {
          uid: 'default.dish',
          category: 'default',
          schema: {
            icon: 'calendar',
            name: 'dish',
            description: '',
            connection: 'default',
            collectionName: 'components_dishes',
            attributes: [
              {
                name: 'label',
                type: 'string',
                required: true,
                default: 'something',
              },

              { name: 'time', type: 'string' },
            ],
          },
        },
      };

      const modifiedData = {
        components,
        contentType: {
          uid: 'api::address.address',
          schema: {
            name: 'address',
            description: '',
            connection: 'default',
            collectionName: 'addresses',
            attributes: [
              {
                name: 'full_name',
                type: 'string',
                required: true,
              },
              {
                name: 'dz',
                type: 'dynamiczone',
                components: ['default.openingtimes', 'default.dish'],
              },
              {
                name: 'otherDz',
                type: 'dynamiczone',
                components: ['default.openingtimes', 'default.dish'],
              },
            ],
          },
        },
      };
      const state: any = {
        ...initialState,
        components,
        modifiedData,
      };

      const action: any = {
        type: actions.REMOVE_COMPONENT_FROM_DYNAMIC_ZONE,
        dzName: 'dz',
        componentToRemoveIndex: 1,
      };

      const expected = {
        ...initialState,
        components,
        modifiedData: {
          components,
          contentType: {
            uid: 'api::address.address',
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: 'addresses',
              attributes: [
                {
                  name: 'full_name',
                  type: 'string',
                  required: true,
                },
                {
                  name: 'dz',
                  type: 'dynamiczone',
                  components: ['default.openingtimes'],
                },
                {
                  name: 'otherDz',
                  type: 'dynamiczone',
                  components: ['default.openingtimes', 'default.dish'],
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('REMOVE_FIELD_FROM_DISPLAYED_COMPONENT', () => {
    it('Should remove the selected field', () => {
      const state: any = {
        ...initialState,
        modifiedData: {
          components: {
            'default.test': {
              schema: {
                attributes: [
                  {
                    name: 'text',
                    type: 'text',
                  },
                  {
                    name: 'other',
                    type: 'string',
                  },
                  {
                    name: 'last',
                    type: 'integer',
                  },
                ],
              },
            },
          },
        },
      };

      const action: any = {
        type: actions.REMOVE_FIELD_FROM_DISPLAYED_COMPONENT,
        componentUid: 'default.test',
        attributeToRemoveName: 'other',
      };

      const expected = {
        ...initialState,
        modifiedData: {
          components: {
            'default.test': {
              schema: {
                attributes: [
                  {
                    name: 'text',
                    type: 'text',
                  },
                  {
                    name: 'last',
                    type: 'integer',
                  },
                ],
              },
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('SET_MODIFIED_DATA', () => {
    it('Should set the modifiedData object correctly if the user did create a new type', () => {
      const schemaToSet = {
        components: {},
        contentType: {
          uid: 'test',
        },
      };

      const state: any = {
        ...initialState,
        modifiedData: null,
        initialData: null,
        isLoadingForDataToBeSet: true,
      };

      const expected = {
        ...initialState,
        modifiedData: schemaToSet,
        initialData: schemaToSet,
        isLoadingForDataToBeSet: false,
      };

      expect(
        reducer(state, {
          type: actions.SET_MODIFIED_DATA,
          schemaToSet,
          hasJustCreatedSchema: true,
        } as any)
      ).toEqual(expected);
    });

    it('Should set the modifiedData object correctly if the user did not create a new type', () => {
      const schemaToSet = {
        components: {},
        contentType: {
          uid: 'test',
        },
      };

      const state: any = {
        ...initialState,
        initialComponents: { ok: true },
        initialContentTypes: { ok: false },
        initialData: null,
        modifiedData: null,
      };
      const expected = {
        ...initialState,
        initialComponents: { ok: true },
        initialContentTypes: { ok: false },
        components: { ok: true },
        contentTypes: { ok: false },
        initialData: schemaToSet,
        modifiedData: schemaToSet,
        isLoadingForDataToBeSet: false,
      };

      expect(
        reducer(state, {
          type: actions.SET_MODIFIED_DATA,
          schemaToSet,
          hasJustCreatedSchema: false,
        } as any)
      ).toEqual(expected);
    });
  });

  describe('UPDATE_SCHEMA', () => {
    it('Should update the modified data correctly if the schemaType is a content type', () => {
      const data = {
        displayName: 'test1',
      };

      const state: any = {
        ...initialState,
        modifiedData: {
          components: {},
          contentType: {
            uid: 'test',
            schema: {
              displayName: 'test',
              attributes: [
                {
                  name: 'something',
                  type: 'string',
                },
              ],
            },
          },
        },
      };

      const action: any = {
        type: actions.UPDATE_SCHEMA,
        data,
        schemaType: 'contentType',
      };
      const expected = {
        ...initialState,
        modifiedData: {
          components: {},
          contentType: {
            uid: 'test',
            schema: {
              displayName: 'test1',
              attributes: [
                {
                  name: 'something',
                  type: 'string',
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should update the modified data correctly if the schemaType is a component', () => {
      const data = {
        displayName: 'newTest',
        category: 'test',
        icon: 'test',
      };

      const state: any = {
        ...initialState,
        components: {
          test: {
            uid: 'test',
            category: 'default',
            schema: {
              displayName: 'test',
              icon: 'book',
              attributes: [
                {
                  name: 'something',
                  type: 'string',
                },
              ],
            },
          },
        },
        modifiedData: {
          components: {},
          component: {
            uid: 'test',
            category: 'default',
            schema: {
              displayName: 'test',
              icon: 'book',
              attributes: [
                {
                  name: 'something',
                  type: 'string',
                },
              ],
            },
          },
        },
      };

      const action: any = {
        type: actions.UPDATE_SCHEMA,
        data,
        schemaType: 'component',
        uid: 'test',
      };
      const expected = {
        ...initialState,
        components: {
          test: {
            uid: 'test',
            category: 'test',
            schema: {
              displayName: 'newTest',
              icon: 'test',
              attributes: [
                {
                  name: 'something',
                  type: 'string',
                },
              ],
            },
          },
        },
        modifiedData: {
          components: {},
          component: {
            uid: 'test',
            category: 'test',
            schema: {
              displayName: 'newTest',
              icon: 'test',
              attributes: [
                {
                  name: 'something',
                  type: 'string',
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/tests/reducerEditAttributeAction.test.ts">
import { EDIT_ATTRIBUTE } from '../constants';
import { initialState, reducer } from '../reducer';

describe('CTB | components | DataManagerProvider | reducer | EDIT_ATTRIBUTE', () => {
  describe('Editing a common attribute (string, integer, json, media, ...)', () => {
    it('Should edit the attribute correctly and preserve the order of the attributes for a content type', () => {
      const contentTypeUID = 'api::address.address';
      const contentType = {
        uid: contentTypeUID,
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [
            { name: 'geolocation', type: 'json', required: true },
            { name: 'cover', type: 'media', multiple: false, required: false },
            {
              name: 'category',
              relation: 'oneToOne',
              target: 'api::category.category',
              type: 'relation',
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const action: any = {
        type: EDIT_ATTRIBUTE,
        attributeToSet: {
          type: 'media',
          multiple: true,
          required: false,
          name: 'covers',
        },
        forTarget: 'contentType',
        targetUid: contentTypeUID,
        initialAttribute: {
          type: 'media',
          multiple: false,
          required: false,
          name: 'cover',
        },
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType: {
            ...contentType,
            schema: {
              ...contentType.schema,
              attributes: [
                { name: 'geolocation', type: 'json', required: true },
                { name: 'covers', type: 'media', multiple: true, required: false },
                {
                  name: 'category',
                  relation: 'oneToOne',
                  target: 'api::category.category',
                  type: 'relation',
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should edit the attribute correctly and preserve the order of the attributes for a component inside the content type view', () => {
      const contentTypeUID = 'api::address.address';
      const componentUID = 'default.dish';
      const contentType = {
        uid: contentTypeUID,
        schema: {
          name: 'address',
          description: '',
          connection: 'default',
          collectionName: '',
          attributes: [
            {
              name: 'dishes',
              component: componentUID,
              type: 'component',
              repeatable: true,
            },
            {
              name: 'category',
              relation: 'oneToOne',
              target: 'api::category.category',
              type: 'relation',
            },
          ],
        },
      };
      const component = {
        uid: componentUID,
        category: 'default',
        schema: {
          icon: 'book',
          name: 'dish',
          description: '',
          connection: 'default',
          collectionName: 'components_dishes',
          attributes: [
            {
              name: 'name',
              type: 'string',
              required: true,
              default: 'My super dish',
            },
            {
              name: 'description',
              type: 'text',
            },
            {
              name: 'price',
              type: 'float',
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        components: { [componentUID]: component },
        initialComponents: { [componentUID]: component },
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: { [componentUID]: component },
          contentType,
        },
      };

      const action: any = {
        type: EDIT_ATTRIBUTE,
        attributeToSet: {
          type: 'text',
          required: true,
          name: 'test',
        },
        forTarget: 'components',
        targetUid: componentUID,
        initialAttribute: {
          type: 'text',
          name: 'description',
        },
        shouldAddComponentToData: false,
      };

      const expected = {
        ...initialState,
        components: { [componentUID]: component },
        initialComponents: { [componentUID]: component },
        contentTypes: { [contentTypeUID]: contentType },
        initialContentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {
            [componentUID]: {
              ...component,
              schema: {
                ...component.schema,
                attributes: [
                  {
                    name: 'name',
                    type: 'string',
                    required: true,
                    default: 'My super dish',
                  },
                  {
                    name: 'test',
                    type: 'text',
                    required: true,
                  },
                  {
                    name: 'price',
                    type: 'float',
                  },
                ],
              },
            },
          },
          contentType,
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('Editing a relation attribute', () => {
    describe('Editing a relation with the same content type', () => {
      describe('Changing the nature of the relation', () => {
        it('Should handle changing the nature from a one side relation (oneWay or manyWay) to another one side relation correctly and preserve the order of the attributes', () => {
          const contentTypeUID = 'api::address.address';
          const contentType = {
            uid: contentTypeUID,
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'geolocation', type: 'json', required: true },
                { name: 'city', type: 'string', required: true },
                { name: 'postal_code', type: 'string' },
                {
                  name: 'one_way',
                  relation: 'oneToOne',
                  targetAttribute: null,
                  target: contentTypeUID,
                  type: 'relation',
                },
                {
                  name: 'category',
                  relation: 'oneToOne',
                  target: 'api::category.category',
                  targetAttribute: null,
                  type: 'relation',
                },
                {
                  name: 'cover',
                  type: 'media',
                  multiple: false,
                  required: false,
                },
                {
                  name: 'images',
                  type: 'media',
                  multiple: true,
                  required: false,
                },
                { name: 'full_name', type: 'string', required: true },
              ],
            },
          };

          const state: any = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType,
            },
          };

          const action: any = {
            type: EDIT_ATTRIBUTE,
            attributeToSet: {
              relation: 'oneToMany',
              targetAttribute: null,
              target: contentTypeUID,
              type: 'relation',
              name: 'many_ways',
            },
            forTarget: 'contentType',
            targetUid: contentTypeUID,
            initialAttribute: {
              relation: 'oneToOne',
              targetAttribute: null,
              target: contentTypeUID,
              name: 'one_way',
            },
            shouldAddComponentToData: false,
          };

          const expected = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType: {
                ...contentType,
                schema: {
                  ...contentType.schema,
                  attributes: [
                    { name: 'geolocation', type: 'json', required: true },
                    { name: 'city', type: 'string', required: true },
                    { name: 'postal_code', type: 'string' },
                    {
                      name: 'many_ways',
                      relation: 'oneToMany',
                      target: contentTypeUID,
                      targetAttribute: null,
                      type: 'relation',
                    },
                    {
                      name: 'category',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                    },
                    {
                      name: 'cover',
                      type: 'media',
                      multiple: false,
                      required: false,
                    },
                    {
                      name: 'images',
                      type: 'media',
                      multiple: true,
                      required: false,
                    },
                    { name: 'full_name', type: 'string', required: true },
                  ],
                },
              },
            },
          };

          expect(reducer(state, action)).toEqual(expected);
        });

        it('Should handle changing the nature from a one side relation (oneWay or manyWay) to a many sides (oneToOne, ...) correctly and preserve the order of the attributes', () => {
          const contentTypeUID = 'api::address.address';
          const contentType = {
            uid: contentTypeUID,
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'geolocation', type: 'json', required: true },
                { name: 'city', type: 'string', required: true },
                { name: 'postal_code', type: 'string' },
                {
                  name: 'one_way',
                  relation: 'oneToOne',
                  targetAttribute: null,
                  target: contentTypeUID,
                  type: 'relation',
                },
                {
                  name: 'category',
                  relation: 'oneToOne',
                  target: 'api::category.category',
                  targetAttribute: null,
                  type: 'relation',
                },
                {
                  name: 'cover',
                  type: 'media',
                  multiple: false,
                  required: false,
                },
                {
                  name: 'images',
                  type: 'media',
                  multiple: true,
                  required: false,
                },
                { name: 'full_name', type: 'string', required: true },
              ],
            },
          };
          const state: any = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType,
            },
          };

          const action: any = {
            type: EDIT_ATTRIBUTE,
            attributeToSet: {
              relation: 'oneToOne',
              targetAttribute: 'address',
              target: contentTypeUID,
              type: 'relation',
              name: 'one_way',
            },
            forTarget: 'contentType',
            targetUid: contentTypeUID,
            initialAttribute: {
              relation: 'oneToOne',
              targetAttribute: null,
              target: contentTypeUID,
              type: 'relation',
              name: 'one_way',
            },
            shouldAddComponentToData: false,
          };

          const expected = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType: {
                ...contentType,
                schema: {
                  ...contentType.schema,
                  attributes: [
                    { name: 'geolocation', type: 'json', required: true },
                    { name: 'city', type: 'string', required: true },
                    { name: 'postal_code', type: 'string' },
                    {
                      name: 'one_way',
                      relation: 'oneToOne',
                      target: contentTypeUID,
                      targetAttribute: 'address',
                      type: 'relation',
                    },
                    {
                      name: 'address',
                      relation: 'oneToOne',
                      target: contentTypeUID,
                      targetAttribute: 'one_way',
                      type: 'relation',
                    },
                    {
                      name: 'category',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                    },
                    {
                      name: 'cover',
                      type: 'media',
                      multiple: false,
                      required: false,
                    },
                    {
                      name: 'images',
                      type: 'media',
                      multiple: true,
                      required: false,
                    },
                    { name: 'full_name', type: 'string', required: true },
                  ],
                },
              },
            },
          };

          expect(reducer(state, action)).toEqual(expected);
        });

        it('Should handle changing the nature from a many side relation to a one side relation correctly and preserve the order of the attributes', () => {
          const contentTypeUID = 'api::address.address';
          const contentType = {
            uid: contentTypeUID,
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'postal_code', type: 'string' },
                {
                  name: 'left',
                  relation: 'oneToOne',
                  targetAttribute: 'right',
                  target: contentTypeUID,
                  type: 'relation',
                },
                {
                  name: 'right',
                  relation: 'oneToOne',
                  target: contentTypeUID,
                  targetAttribute: 'left',
                  type: 'relation',
                },
                {
                  name: 'category',
                  relation: 'oneToOne',
                  target: 'api::category.category',
                  targetAttribute: null,
                  type: 'relation',
                },
              ],
            },
          };

          const state: any = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType,
            },
          };

          const action: any = {
            type: EDIT_ATTRIBUTE,
            attributeToSet: {
              relation: 'oneToOne',
              targetAttribute: null,
              target: contentTypeUID,
              type: 'relation',
              name: 'one_way',
            },
            forTarget: 'contentType',
            targetUid: contentTypeUID,
            initialAttribute: {
              relation: 'oneToOne',
              target: contentTypeUID,
              targetAttribute: 'right',
              type: 'relation',
              name: 'left',
            },
            shouldAddComponentToData: false,
          };

          const expected = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType: {
                ...contentType,
                schema: {
                  ...contentType.schema,
                  attributes: [
                    { name: 'postal_code', type: 'string' },
                    {
                      name: 'one_way',
                      relation: 'oneToOne',
                      targetAttribute: null,
                      target: contentTypeUID,
                      type: 'relation',
                    },
                    {
                      name: 'category',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                    },
                  ],
                },
              },
            },
          };

          expect(reducer(state, action)).toEqual(expected);
        });
      });

      describe('Changing the target of the relation', () => {
        it('Should handle the edition of the target correctly for a one way relation (oneWay, manyWay) with another content type and preserve the order of the attributes', () => {
          const contentTypeUID = 'api::address.address';
          const updatedTargetUID = 'api::category.category';
          const contentType = {
            uid: contentTypeUID,
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                {
                  name: 'address',
                  relation: 'oneToOne',
                  targetAttribute: null,
                  target: contentTypeUID,
                  type: 'relation',
                },
                {
                  name: 'category',
                  relation: 'oneToOne',
                  target: 'api::category.category',
                  targetAttribute: null,
                  type: 'relation',
                },
                {
                  name: 'cover',
                  type: 'media',
                  multiple: false,
                  required: false,
                },
              ],
            },
          };

          const state: any = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType,
            },
          };

          const action: any = {
            type: EDIT_ATTRIBUTE,
            attributeToSet: {
              relation: 'oneToOne',
              targetAttribute: null,
              target: updatedTargetUID,
              type: 'relation',
              name: 'one_way',
            },
            forTarget: 'contentType',
            targetUid: contentTypeUID,
            initialAttribute: {
              relation: 'oneToOne',
              targetAttribute: null,
              target: contentTypeUID,
              type: 'relation',
              name: 'address',
            },
            shouldAddComponentToData: false,
          };
          const expected = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType: {
                ...contentType,
                schema: {
                  ...contentType.schema,
                  attributes: [
                    {
                      name: 'one_way',
                      relation: 'oneToOne',
                      targetAttribute: null,
                      target: updatedTargetUID,
                      type: 'relation',
                    },
                    {
                      name: 'category',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                    },
                    {
                      name: 'cover',
                      type: 'media',
                      multiple: false,
                      required: false,
                    },
                  ],
                },
              },
            },
          };

          expect(reducer(state, action)).toEqual(expected);
        });

        it('Should remove the opposite attribute and keep the order of the attributes if the relation nature is not a one side', () => {
          const contentTypeUID = 'api::address.address';
          const updatedTargetUID = 'api::category.category';
          const contentType = {
            uid: contentTypeUID,
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'postal_code', type: 'string' },
                {
                  name: 'many_to_many_left',
                  relation: 'manyToMany',
                  targetAttribute: 'many_to_many_right',
                  target: contentTypeUID,
                  type: 'relation',
                },
                {
                  name: 'many_to_many_right',
                  relation: 'manyToMany',
                  targetAttribute: 'many_to_many_left',
                  target: contentTypeUID,
                  type: 'relation',
                },
                {
                  name: 'category',
                  relation: 'oneToOne',
                  target: 'api::category.category',
                  targetAttribute: null,
                  type: 'relation',
                },
              ],
            },
          };
          const state: any = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType,
            },
          };

          const action: any = {
            type: EDIT_ATTRIBUTE,
            attributeToSet: {
              relation: 'manyToMany',
              targetAttribute: 'many_to_many_right',
              target: updatedTargetUID,
              type: 'relation',
              name: 'many_to_many_left',
            },
            forTarget: 'contentType',
            targetUid: contentTypeUID,
            initialAttribute: {
              relation: 'manyToMany',
              targetAttribute: 'many_to_many_right',
              target: contentTypeUID,
              type: 'relation',
              name: 'many_to_many_left',
            },
            shouldAddComponentToData: false,
          };

          const expected = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType: {
                ...contentType,
                schema: {
                  ...contentType.schema,
                  attributes: [
                    { name: 'postal_code', type: 'string' },
                    {
                      name: 'many_to_many_left',
                      relation: 'manyToMany',
                      targetAttribute: 'many_to_many_right',
                      target: updatedTargetUID,
                      type: 'relation',
                    },
                    {
                      name: 'category',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                    },
                  ],
                },
              },
            },
          };

          expect(reducer(state, action)).toEqual(expected);
        });
      });

      describe('Editing the other informations of the relation', () => {
        it('Should handle the edition of the other properties correctly by updating the opposite attribute in the other cases', () => {
          const contentTypeUID = 'api::address.address';
          const contentType = {
            uid: contentTypeUID,
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'postal_code', type: 'string' },
                {
                  name: 'many_to_many_left',
                  relation: 'manyToMany',
                  targetAttribute: 'many_to_many_right',
                  target: contentTypeUID,
                  type: 'relation',
                },
                {
                  name: 'many_to_many_right',
                  relation: 'manyToMany',
                  targetAttribute: 'many_to_many_left',
                  target: contentTypeUID,
                  type: 'relation',
                },
                {
                  name: 'category',
                  relation: 'oneToOne',
                  target: 'api::category.category',
                  targetAttribute: null,
                  type: 'relation',
                },
              ],
            },
          };

          const state: any = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType,
            },
          };

          const action: any = {
            type: EDIT_ATTRIBUTE,
            attributeToSet: {
              relation: 'manyToMany',
              targetAttribute: 'many_to_many_right_updated',
              target: contentTypeUID,
              type: 'relation',
              name: 'many_to_many_left',
            },
            forTarget: 'contentType',
            targetUid: contentTypeUID,
            initialAttribute: {
              relation: 'manyToMany',
              targetAttribute: 'many_to_many_right',
              target: contentTypeUID,
              type: 'relation',
              name: 'many_to_many_left',
            },
            shouldAddComponentToData: false,
          };

          const expected = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType: {
                ...contentType,
                schema: {
                  ...contentType.schema,
                  attributes: [
                    { name: 'postal_code', type: 'string' },
                    {
                      name: 'many_to_many_left',
                      relation: 'manyToMany',
                      targetAttribute: 'many_to_many_right_updated',
                      target: contentTypeUID,
                      type: 'relation',
                    },
                    {
                      name: 'many_to_many_right_updated',
                      relation: 'manyToMany',
                      targetAttribute: 'many_to_many_left',
                      target: contentTypeUID,
                      type: 'relation',
                    },
                    {
                      name: 'category',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                    },
                  ],
                },
              },
            },
          };

          expect(reducer(state, action)).toEqual(expected);
        });

        it('Should handle the edition of the name of the relation correctly for a one side relation', () => {
          const contentTypeUID = 'api::address.address';
          const contentType = {
            uid: contentTypeUID,
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'postal_code', type: 'string' },
                {
                  name: 'one_way',
                  relation: 'oneToOne',
                  targetAttribute: null,
                  target: contentTypeUID,
                  type: 'relation',
                },
                {
                  name: 'category',
                  relation: 'oneToOne',
                  target: 'api::category.category',
                  targetAttribute: null,
                  type: 'relation',
                },
                {
                  name: 'cover',
                  type: 'media',
                  multiple: false,
                  required: false,
                },
              ],
            },
          };
          const state: any = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType,
            },
          };

          const action: any = {
            type: EDIT_ATTRIBUTE,
            attributeToSet: {
              relation: 'oneToOne',
              targetAttribute: null,
              target: contentTypeUID,
              type: 'relation',
              name: 'one_way_updated',
            },
            forTarget: 'contentType',
            targetUid: contentTypeUID,
            initialAttribute: {
              relation: 'oneToOne',
              targetAttribute: null,
              target: contentTypeUID,
              type: 'relation',
              name: 'one_way',
            },
            shouldAddComponentToData: false,
          };

          const expected = {
            ...initialState,
            components: {},
            initialComponents: {},
            contentTypes: { [contentTypeUID]: contentType },
            initialContentTypes: { [contentTypeUID]: contentType },
            modifiedData: {
              components: {},
              contentType: {
                ...contentType,
                schema: {
                  ...contentType.schema,
                  attributes: [
                    { name: 'postal_code', type: 'string' },
                    {
                      name: 'one_way_updated',
                      relation: 'oneToOne',
                      targetAttribute: null,
                      target: contentTypeUID,
                      type: 'relation',
                    },
                    {
                      name: 'category',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                    },
                    {
                      name: 'cover',
                      type: 'media',
                      multiple: false,
                      required: false,
                    },
                  ],
                },
              },
            },
          };

          expect(reducer(state, action)).toEqual(expected);
        });
      });
    });

    describe('Editing a relation with another content type', () => {
      it('Should not create an opposite attribute if the target is the same content type and the nature is a one side relation (oneWay, manyWay)', () => {
        const contentTypeUID = 'api::category.category';
        const updatedTargetUID = 'api::address.address';
        const contentType = {
          uid: contentTypeUID,
          schema: {
            name: 'address',
            description: '',
            connection: 'default',
            collectionName: '',
            attributes: [
              { name: 'postal_code', type: 'string' },
              {
                name: 'one_way',
                relation: 'oneToOne',
                targetAttribute: null,
                target: contentTypeUID,
                type: 'relation',
              },
              {
                name: 'category',
                relation: 'oneToOne',
                target: 'api::category.category',
                targetAttribute: null,
                type: 'relation',
              },
              {
                name: 'cover',
                type: 'media',
                multiple: false,
                required: false,
              },
            ],
          },
        };
        const state: any = {
          ...initialState,
          components: {},
          initialComponents: {},
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {},
            contentType,
          },
        };

        const action: any = {
          type: EDIT_ATTRIBUTE,
          attributeToSet: {
            relation: 'oneToOne',
            targetAttribute: null,
            target: updatedTargetUID,
            type: 'relation',
            name: 'one_way',
          },
          forTarget: 'contentType',
          targetUid: contentTypeUID,
          initialAttribute: {
            relation: 'oneToOne',
            targetAttribute: null,
            target: contentTypeUID,
            type: 'relation',
            name: 'one_way',
          },
          shouldAddComponentToData: false,
        };
        const expected = {
          ...initialState,
          components: {},
          initialComponents: {},
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {},
            contentType: {
              ...contentType,
              schema: {
                ...contentType.schema,
                attributes: [
                  { name: 'postal_code', type: 'string' },
                  {
                    name: 'one_way',
                    relation: 'oneToOne',
                    targetAttribute: null,
                    target: updatedTargetUID,
                    type: 'relation',
                  },
                  {
                    name: 'category',
                    relation: 'oneToOne',
                    target: 'api::category.category',
                    targetAttribute: null,
                    type: 'relation',
                  },
                  {
                    name: 'cover',
                    type: 'media',
                    multiple: false,
                    required: false,
                  },
                ],
              },
            },
          },
        };

        expect(reducer(state, action)).toEqual(expected);
      });

      it('Should create an opposite attribute if the target is the same content type and the nature is not a one side relation (oneToOne, ...)', () => {
        const originalTargetUID = 'api::category.category';
        const contentTypeUID = 'api::address.address';
        const contentType = {
          uid: contentTypeUID,
          schema: {
            name: 'address',
            description: '',
            connection: 'default',
            collectionName: '',
            attributes: [
              { name: 'postal_code', type: 'string' },
              {
                name: 'one_to_many',
                relation: 'oneToMany',
                targetAttribute: 'many_to_one',
                target: originalTargetUID,
                type: 'relation',
              },
              {
                name: 'category',
                relation: 'oneToOne',
                target: 'api::category.category',
                targetAttribute: null,
                type: 'relation',
              },
              {
                name: 'cover',
                type: 'media',
                multiple: false,
                required: false,
              },
            ],
          },
        };
        const state: any = {
          ...initialState,
          components: {},
          initialComponents: {},
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {},
            contentType,
          },
        };

        const action: any = {
          type: EDIT_ATTRIBUTE,
          attributeToSet: {
            relation: 'oneToMany',
            targetAttribute: 'many_to_one',
            target: contentTypeUID,
            type: 'relation',
            name: 'one_to_many',
          },
          forTarget: 'contentType',
          targetUid: contentTypeUID,
          initialAttribute: {
            relation: 'oneToMany',
            targetAttribute: 'many_to_one',
            target: originalTargetUID,
            type: 'relation',
            name: 'one_to_many',
          },
          shouldAddComponentToData: false,
        };

        const expected = {
          ...initialState,
          components: {},
          initialComponents: {},
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {},
            contentType: {
              ...contentType,
              schema: {
                ...contentType.schema,
                attributes: [
                  { name: 'postal_code', type: 'string' },
                  {
                    name: 'one_to_many',
                    relation: 'oneToMany',
                    targetAttribute: 'many_to_one',
                    target: contentTypeUID,
                    type: 'relation',
                  },
                  {
                    name: 'many_to_one',
                    relation: 'manyToOne',
                    targetAttribute: 'one_to_many',
                    target: contentTypeUID,
                    type: 'relation',
                  },
                  {
                    name: 'category',
                    relation: 'oneToOne',
                    target: 'api::category.category',
                    targetAttribute: null,
                    type: 'relation',
                  },
                  {
                    name: 'cover',
                    type: 'media',
                    multiple: false,
                    required: false,
                  },
                ],
              },
            },
          },
        };

        expect(reducer(state, action)).toEqual(expected);
      });

      it('Should create an opposite attribute if the target is the same content type and the nature is manyToMany', () => {
        const originalTargetUID = 'api::category.category';
        const contentTypeUID = 'api::address.address';
        const contentType = {
          uid: contentTypeUID,
          schema: {
            name: 'address',
            description: '',
            connection: 'default',
            collectionName: '',
            attributes: [
              { name: 'postal_code', type: 'string' },
              {
                name: 'many_to_many_left',
                relation: 'manyToMany',
                targetAttribute: 'many_to_many_right',
                target: originalTargetUID,
                type: 'relation',
              },
              {
                name: 'category',
                relation: 'oneToOne',
                target: 'api::category.category',
                targetAttribute: null,
                type: 'relation',
              },
              {
                name: 'cover',
                type: 'media',
                multiple: false,
                required: false,
              },
            ],
          },
        };
        const state: any = {
          ...initialState,
          components: {},
          initialComponents: {},
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {},
            contentType,
          },
        };

        const action: any = {
          type: EDIT_ATTRIBUTE,
          attributeToSet: {
            relation: 'manyToMany',
            targetAttribute: 'many_to_many_right',
            target: contentTypeUID,
            type: 'relation',
            name: 'many_to_many_left',
          },
          forTarget: 'contentType',
          targetUid: contentTypeUID,
          initialAttribute: {
            relation: 'manyToMany',
            targetAttribute: 'many_to_many_right',
            target: originalTargetUID,
            type: 'relation',
            name: 'many_to_many_left',
          },
          shouldAddComponentToData: false,
        };
        const expected = {
          ...initialState,
          components: {},
          initialComponents: {},
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {},
            contentType: {
              ...contentType,
              schema: {
                ...contentType.schema,
                attributes: [
                  { name: 'postal_code', type: 'string' },
                  {
                    name: 'many_to_many_left',
                    relation: 'manyToMany',
                    targetAttribute: 'many_to_many_right',
                    target: contentTypeUID,
                    type: 'relation',
                  },
                  {
                    name: 'many_to_many_right',
                    relation: 'manyToMany',
                    targetAttribute: 'many_to_many_left',
                    target: contentTypeUID,
                    type: 'relation',
                  },
                  {
                    name: 'category',
                    relation: 'oneToOne',
                    target: 'api::category.category',
                    targetAttribute: null,
                    type: 'relation',
                  },
                  {
                    name: 'cover',
                    type: 'media',
                    multiple: false,
                    required: false,
                  },
                ],
              },
            },
          },
        };

        expect(reducer(state, action)).toEqual(expected);
      });
    });

    describe('Editing a relation and preserve plugin options', () => {
      it('Should save pluginOptions if the relation is a one side relation (oneWay, manyWay)', () => {
        const contentTypeUID = 'api::category.category';
        const updatedTargetUID = 'api::address.address';
        const contentType = {
          uid: contentTypeUID,
          schema: {
            name: 'address',
            description: '',
            connection: 'default',
            collectionName: '',
            attributes: [
              { name: 'postal_code', type: 'string' },
              {
                name: 'one_way',
                relation: 'oneToOne',
                targetAttribute: null,
                target: contentTypeUID,
                type: 'relation',
              },
              {
                name: 'category',
                relation: 'oneToOne',
                target: 'api::category.category',
                targetAttribute: null,
                type: 'relation',
              },
              {
                name: 'cover',
                type: 'media',
                multiple: false,
                required: false,
              },
            ],
          },
        };
        const state: any = {
          ...initialState,
          components: {},
          initialComponents: {},
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {},
            contentType,
          },
        };

        const action: any = {
          type: EDIT_ATTRIBUTE,
          attributeToSet: {
            relation: 'oneToOne',
            targetAttribute: null,
            target: updatedTargetUID,
            type: 'relation',
            name: 'one_way',
            pluginOptions: {
              myplugin: {
                example: 'first',
              },
            },
          },
          forTarget: 'contentType',
          targetUid: contentTypeUID,
          initialAttribute: {
            relation: 'oneToOne',
            targetAttribute: null,
            target: contentTypeUID,
            type: 'relation',
            name: 'one_way',
          },
          shouldAddComponentToData: false,
        };
        const expected = {
          ...initialState,
          components: {},
          initialComponents: {},
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {},
            contentType: {
              ...contentType,
              schema: {
                ...contentType.schema,
                attributes: [
                  { name: 'postal_code', type: 'string' },
                  {
                    name: 'one_way',
                    relation: 'oneToOne',
                    targetAttribute: null,
                    target: updatedTargetUID,
                    type: 'relation',
                    pluginOptions: {
                      myplugin: {
                        example: 'first',
                      },
                    },
                  },
                  {
                    name: 'category',
                    relation: 'oneToOne',
                    target: 'api::category.category',
                    targetAttribute: null,
                    type: 'relation',
                  },
                  {
                    name: 'cover',
                    type: 'media',
                    multiple: false,
                    required: false,
                  },
                ],
              },
            },
          },
        };

        expect(reducer(state, action)).toEqual(expected);
      });

      it('Should preserve plugin options on the opposite attribute if the target is a the same content type and the nature is not a one side relation (oneToOne, ...)', () => {
        const contentTypeUID = 'api::address.address';
        const contentType = {
          uid: contentTypeUID,
          schema: {
            name: 'address',
            description: '',
            connection: 'default',
            collectionName: '',
            attributes: [
              { name: 'postal_code', type: 'string' },
              {
                name: 'one_to_many',
                relation: 'oneToMany',
                targetAttribute: 'many_to_one',
                target: contentTypeUID,
                type: 'relation',
              },
              {
                name: 'many_to_one',
                relation: 'manyToOne',
                targetAttribute: 'one_to_many',
                target: contentTypeUID,
                type: 'relation',
                pluginOptions: {
                  myplugin: {
                    example: 'first',
                  },
                },
              },
              {
                name: 'category',
                relation: 'oneToOne',
                target: 'api::category.category',
                targetAttribute: null,
                type: 'relation',
              },
              {
                name: 'cover',
                type: 'media',
                multiple: false,
                required: false,
              },
            ],
          },
        };
        const state: any = {
          ...initialState,
          components: {},
          initialComponents: {},
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {},
            contentType,
          },
        };

        const action: any = {
          type: EDIT_ATTRIBUTE,
          attributeToSet: {
            relation: 'oneToMany',
            targetAttribute: 'many_to_one',
            target: contentTypeUID,
            type: 'relation',
            name: 'one_to_many',
            pluginOptions: {
              myplugin: {
                example: 'first',
              },
            },
          },
          forTarget: 'contentType',
          targetUid: contentTypeUID,
          initialAttribute: {
            relation: 'oneToMany',
            targetAttribute: 'many_to_one',
            target: contentTypeUID,
            type: 'relation',
            name: 'one_to_many',
          },
          shouldAddComponentToData: false,
        };

        const expected = {
          ...initialState,
          components: {},
          initialComponents: {},
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {},
            contentType: {
              ...contentType,
              schema: {
                ...contentType.schema,
                attributes: [
                  { name: 'postal_code', type: 'string' },
                  {
                    name: 'one_to_many',
                    relation: 'oneToMany',
                    targetAttribute: 'many_to_one',
                    target: contentTypeUID,
                    type: 'relation',
                    pluginOptions: {
                      myplugin: {
                        example: 'first',
                      },
                    },
                  },
                  {
                    name: 'many_to_one',
                    relation: 'manyToOne',
                    targetAttribute: 'one_to_many',
                    target: contentTypeUID,
                    type: 'relation',
                    pluginOptions: {
                      myplugin: {
                        example: 'first',
                      },
                    },
                  },
                  {
                    name: 'category',
                    relation: 'oneToOne',
                    target: 'api::category.category',
                    targetAttribute: null,
                    type: 'relation',
                  },
                  {
                    name: 'cover',
                    type: 'media',
                    multiple: false,
                    required: false,
                  },
                ],
              },
            },
          },
        };

        expect(reducer(state, action)).toEqual(expected);
      });

      it('Should save pluginOptions if the relation is nested inside a component', () => {
        const contentTypeUID = 'api::address.address';
        const componentUID = 'default.dish';
        const contentType = {
          uid: contentTypeUID,
          schema: {
            name: 'address',
            description: '',
            connection: 'default',
            collectionName: '',
            attributes: [
              {
                name: 'dishes',
                component: componentUID,
                type: 'component',
                repeatable: true,
              },
              { name: 'dynamiczone', type: 'dynamiczone', components: [componentUID] },
            ],
          },
        };
        const component = {
          uid: componentUID,
          category: 'default',
          schema: {
            icon: 'book',
            name: 'dish',
            description: '',
            connection: 'default',
            collectionName: 'components_dishes',
            attributes: [
              {
                name: 'name',
                type: 'string',
                required: true,
                default: 'My super dish',
              },
              {
                name: 'description',
                type: 'text',
              },
              {
                name: 'price',
                type: 'float',
              },
              {
                name: 'category',
                relation: 'oneToOne',
                target: 'api::category.category',
                targetAttribute: null,
                type: 'relation',
              },
            ],
          },
        };

        const state: any = {
          ...initialState,
          components: { [componentUID]: component },
          initialComponents: { [componentUID]: component },
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: { [componentUID]: component },
            contentType,
          },
        };

        const action: any = {
          type: EDIT_ATTRIBUTE,
          attributeToSet: {
            name: 'category',
            relation: 'oneToOne',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
            pluginOptions: {
              myplugin: {
                example: 'first',
              },
            },
          },
          forTarget: 'components',
          targetUid: componentUID,
          initialAttribute: {
            name: 'category',
            relation: 'oneToOne',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
          },
          shouldAddComponentToData: false,
        };

        const expected = {
          ...initialState,
          components: { [componentUID]: component },
          initialComponents: { [componentUID]: component },
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {
              [componentUID]: {
                ...component,
                schema: {
                  ...component.schema,
                  attributes: [
                    {
                      name: 'name',
                      type: 'string',
                      required: true,
                      default: 'My super dish',
                    },
                    {
                      name: 'description',
                      type: 'text',
                    },
                    {
                      name: 'price',
                      type: 'float',
                    },
                    {
                      name: 'category',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                      pluginOptions: {
                        myplugin: {
                          example: 'first',
                        },
                      },
                    },
                  ],
                },
              },
            },
            contentType,
          },
        };

        expect(reducer(state, action)).toEqual(expected);
      });

      it('Should preserve pluginOptions if the relation is nested inside a component', () => {
        const contentTypeUID = 'api::address.address';
        const componentUID = 'default.dish';
        const contentType = {
          uid: contentTypeUID,
          schema: {
            name: 'address',
            description: '',
            connection: 'default',
            collectionName: '',
            attributes: [
              {
                name: 'dishes',
                component: componentUID,
                type: 'component',
                repeatable: true,
              },
              { name: 'dynamiczone', type: 'dynamiczone', components: [componentUID] },
            ],
          },
        };
        const component = {
          uid: componentUID,
          category: 'default',
          schema: {
            icon: 'book',
            name: 'dish',
            description: '',
            connection: 'default',
            collectionName: 'components_dishes',
            attributes: [
              {
                name: 'name',
                type: 'string',
                required: true,
                default: 'My super dish',
              },
              {
                name: 'description',
                type: 'text',
              },
              {
                name: 'price',
                type: 'float',
              },
              {
                name: 'category',
                relation: 'oneToOne',
                target: 'api::category.category',
                targetAttribute: null,
                type: 'relation',
                pluginOptions: {
                  myplugin: {
                    example: 'first',
                  },
                },
              },
            ],
          },
        };

        const state: any = {
          ...initialState,
          components: { [componentUID]: component },
          initialComponents: { [componentUID]: component },
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: { [componentUID]: component },
            contentType,
          },
        };

        const action: any = {
          type: EDIT_ATTRIBUTE,
          attributeToSet: {
            name: 'category-new',
            relation: 'oneToOne',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
            pluginOptions: {
              myplugin: {
                example: 'first',
              },
            },
          },
          forTarget: 'components',
          targetUid: componentUID,
          initialAttribute: {
            name: 'category',
            relation: 'oneToOne',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
            pluginOptions: {
              myplugin: {
                example: 'first',
              },
            },
          },
          shouldAddComponentToData: false,
        };

        const expected = {
          ...initialState,
          components: { [componentUID]: component },
          initialComponents: { [componentUID]: component },
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {
              [componentUID]: {
                ...component,
                schema: {
                  ...component.schema,
                  attributes: [
                    {
                      name: 'name',
                      type: 'string',
                      required: true,
                      default: 'My super dish',
                    },
                    {
                      name: 'description',
                      type: 'text',
                    },
                    {
                      name: 'price',
                      type: 'float',
                    },
                    {
                      name: 'category-new',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                      pluginOptions: {
                        myplugin: {
                          example: 'first',
                        },
                      },
                    },
                  ],
                },
              },
            },
            contentType,
          },
        };

        expect(reducer(state, action)).toEqual(expected);
      });

      it('Should save pluginOptions if the relation is nested inside a dynamic zone', () => {
        const contentTypeUID = 'api::address.address';
        const componentUID = 'default.dish';
        const contentType = {
          uid: contentTypeUID,
          schema: {
            name: 'address',
            description: '',
            connection: 'default',
            collectionName: '',
            attributes: [{ name: 'dynamiczone', type: 'dynamiczone', components: [componentUID] }],
          },
        };
        const component = {
          uid: componentUID,
          category: 'default',
          schema: {
            icon: 'book',
            name: 'dish',
            description: '',
            connection: 'default',
            collectionName: 'components_dishes',
            attributes: [
              {
                name: 'name',
                type: 'string',
                required: true,
                default: 'My super dish',
              },
              {
                name: 'description',
                type: 'text',
              },
              {
                name: 'price',
                type: 'float',
              },
              {
                name: 'category',
                relation: 'oneToOne',
                target: 'api::category.category',
                targetAttribute: null,
                type: 'relation',
              },
            ],
          },
        };

        const state: any = {
          ...initialState,
          components: { [componentUID]: component },
          initialComponents: { [componentUID]: component },
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: { [componentUID]: component },
            contentType,
          },
        };

        const action: any = {
          type: EDIT_ATTRIBUTE,
          attributeToSet: {
            name: 'category',
            relation: 'oneToOne',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
            pluginOptions: {
              myplugin: {
                example: 'first',
              },
            },
          },
          forTarget: 'components',
          targetUid: componentUID,
          initialAttribute: {
            name: 'category',
            relation: 'oneToOne',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
          },
          shouldAddComponentToData: false,
        };

        const expected = {
          ...initialState,
          components: { [componentUID]: component },
          initialComponents: { [componentUID]: component },
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {
              [componentUID]: {
                ...component,
                schema: {
                  ...component.schema,
                  attributes: [
                    {
                      name: 'name',
                      type: 'string',
                      required: true,
                      default: 'My super dish',
                    },
                    {
                      name: 'description',
                      type: 'text',
                    },
                    {
                      name: 'price',
                      type: 'float',
                    },
                    {
                      name: 'category',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                      pluginOptions: {
                        myplugin: {
                          example: 'first',
                        },
                      },
                    },
                  ],
                },
              },
            },
            contentType,
          },
        };

        expect(reducer(state, action)).toEqual(expected);
      });

      it('Should preserve pluginOptions if the relation is nested inside a dynamic zone', () => {
        const contentTypeUID = 'api::address.address';
        const componentUID = 'default.dish';
        const contentType = {
          uid: contentTypeUID,
          schema: {
            name: 'address',
            description: '',
            connection: 'default',
            collectionName: '',
            attributes: [{ name: 'dynamiczone', type: 'dynamiczone', components: [componentUID] }],
          },
        };
        const component = {
          uid: componentUID,
          category: 'default',
          schema: {
            icon: 'book',
            name: 'dish',
            description: '',
            connection: 'default',
            collectionName: 'components_dishes',
            attributes: [
              {
                name: 'name',
                type: 'string',
                required: true,
                default: 'My super dish',
              },
              {
                name: 'description',
                type: 'text',
              },
              {
                name: 'price',
                type: 'float',
              },
              {
                name: 'category',
                relation: 'oneToOne',
                target: 'api::category.category',
                targetAttribute: null,
                type: 'relation',
                pluginOptions: {
                  myplugin: {
                    example: 'first',
                  },
                },
              },
            ],
          },
        };

        const state: any = {
          ...initialState,
          components: { [componentUID]: component },
          initialComponents: { [componentUID]: component },
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: { [componentUID]: component },
            contentType,
          },
        };

        const action: any = {
          type: EDIT_ATTRIBUTE,
          attributeToSet: {
            name: 'category-new',
            relation: 'oneToOne',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
            pluginOptions: {
              myplugin: {
                example: 'first',
              },
            },
          },
          forTarget: 'components',
          targetUid: componentUID,
          initialAttribute: {
            name: 'category',
            relation: 'oneToOne',
            target: 'api::category.category',
            targetAttribute: null,
            type: 'relation',
            pluginOptions: {
              myplugin: {
                example: 'first',
              },
            },
          },
          shouldAddComponentToData: false,
        };

        const expected = {
          ...initialState,
          components: { [componentUID]: component },
          initialComponents: { [componentUID]: component },
          contentTypes: { [contentTypeUID]: contentType },
          initialContentTypes: { [contentTypeUID]: contentType },
          modifiedData: {
            components: {
              [componentUID]: {
                ...component,
                schema: {
                  ...component.schema,
                  attributes: [
                    {
                      name: 'name',
                      type: 'string',
                      required: true,
                      default: 'My super dish',
                    },
                    {
                      name: 'description',
                      type: 'text',
                    },
                    {
                      name: 'price',
                      type: 'float',
                    },
                    {
                      name: 'category-new',
                      relation: 'oneToOne',
                      target: 'api::category.category',
                      targetAttribute: null,
                      type: 'relation',
                      pluginOptions: {
                        myplugin: {
                          example: 'first',
                        },
                      },
                    },
                  ],
                },
              },
            },
            contentType,
          },
        };

        expect(reducer(state, action)).toEqual(expected);
      });
    });
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/tests/reducerEditCustomFieldAttributeAction.test.ts">
import cloneDeep from 'lodash/cloneDeep';

import { EDIT_CUSTOM_FIELD_ATTRIBUTE } from '../constants';
import { initialState, reducer } from '../reducer';

describe('CTB | components | DataManagerProvider | reducer | EDIT_CUSTOM_FIELD_ATTRIBUTE', () => {
  it('edits a custom field attribute on a content type', () => {
    const initialCustomFieldAttribute = {
      name: 'custom_field',
      type: 'string',
      customField: 'plugin::mycustomfields.color',
    };

    const contentTypeUID = 'api::address.address';
    const contentType = {
      uid: contentTypeUID,
      schema: {
        name: 'address',
        description: '',
        connection: 'default',
        collectionName: '',
        attributes: [{ name: 'test', type: 'string' }, initialCustomFieldAttribute],
      },
    };

    const state: any = {
      ...initialState,
      contentTypes: { [contentTypeUID]: contentType },
      initialContentTypes: { [contentTypeUID]: contentType },
      modifiedData: {
        components: {},
        contentType,
      },
    };

    const updatedCustomFieldAttribute = {
      type: 'string',
      options: {
        format: 'hex',
      },
      name: 'color_picker_hex',
      customField: 'plugin::mycustomfields.color',
    };

    const action: any = {
      type: EDIT_CUSTOM_FIELD_ATTRIBUTE,
      attributeToSet: updatedCustomFieldAttribute,
      forTarget: 'contentType',
      targetUid: contentTypeUID,
      initialAttribute: initialCustomFieldAttribute,
      shouldAddComponentToData: false,
    };

    const updatedContentType = cloneDeep(contentType);
    updatedContentType.schema.attributes = [
      { name: 'test', type: 'string' },
      updatedCustomFieldAttribute,
    ];

    const expected = {
      ...initialState,
      contentTypes: { [contentTypeUID]: contentType },
      initialContentTypes: { [contentTypeUID]: contentType },
      modifiedData: {
        components: {},
        contentType: updatedContentType,
      },
    };

    expect(reducer(state, action)).toEqual(expected);
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/tests/reducerRemoveFieldAction.test.ts">
import { REMOVE_FIELD } from '../constants';
import { reducer, initialState } from '../reducer';

import { data as testData } from './data';

describe('CTB | components | DataManagerProvider | reducer | REMOVE_FIELD', () => {
  describe('Removing a field that is not a relation', () => {
    it('Should remove the attribute correctly from the content type', () => {
      const action: any = {
        type: REMOVE_FIELD,
        mainDataKey: 'contentType',
        attributeToRemoveName: 'city',
        componentUid: '',
      };

      const state: any = {
        ...initialState,
        contentTypes: testData.contentTypes,
        initialContentTypes: testData.contentTypes,
        modifiedData: {
          components: {},
          contentType: {
            uid: 'api::address.address',
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'geolocation', type: 'json', required: true },
                { name: 'city', type: 'string', required: true },
                { name: 'postal_coder', type: 'string' },
                {
                  name: 'category',
                  relation: 'oneToOne',
                  target: 'api::category.category',
                  targetAttribute: null,
                  type: 'relation',
                },
                { name: 'cover', type: 'media', multiple: false, required: false },
                { name: 'images', type: 'media', multiple: true, required: false },
                { name: 'full_name', type: 'string', required: true },
              ],
            },
          },
        },
      };

      const expected = {
        ...state,
        modifiedData: {
          components: {},
          contentType: {
            uid: 'api::address.address',
            schema: {
              name: 'address',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'geolocation', type: 'json', required: true },

                { name: 'postal_coder', type: 'string' },
                {
                  name: 'category',
                  relation: 'oneToOne',
                  target: 'api::category.category',
                  targetAttribute: null,
                  type: 'relation',
                },
                { name: 'cover', type: 'media', multiple: false, required: false },
                { name: 'images', type: 'media', multiple: true, required: false },
                { name: 'full_name', type: 'string', required: true },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('Removing a relation attribute with another content type', () => {
    it('Should remove the attribute correctly if the relation is made with another content type', () => {
      const attributeToRemoveName = 'menu';
      const action: any = {
        type: REMOVE_FIELD,
        mainDataKey: 'contentType',
        attributeToRemoveName,
        componentUid: '',
      };

      const state: any = {
        ...initialState,
        contentTypes: testData.contentTypes,
        initialContentTypes: testData.contentTypes,
        modifiedData: {
          components: {},
          contentType: {
            uid: 'api::menusection.menusection',
            schema: {
              name: 'menusection',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'name', type: 'string', required: true, minLength: 6 },
                {
                  name: 'dishes',
                  component: 'default.dish',
                  type: 'component',
                  repeatable: true,
                },
                {
                  name: 'menu',
                  relation: 'manyToOne',
                  target: 'api::menu.menu',
                  targetAttribute: 'menusections',
                  type: 'relation',
                },
              ],
            },
          },
        },
      };

      const expected = {
        ...initialState,
        contentTypes: testData.contentTypes,
        initialContentTypes: testData.contentTypes,
        modifiedData: {
          components: {},
          contentType: {
            uid: 'api::menusection.menusection',
            schema: {
              name: 'menusection',
              description: '',
              connection: 'default',
              collectionName: '',
              attributes: [
                { name: 'name', type: 'string', required: true, minLength: 6 },
                {
                  name: 'dishes',
                  component: 'default.dish',
                  type: 'component',
                  repeatable: true,
                },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('Removing a relation attribute with the same content type', () => {
    it('Should handle the removal of the one side (oneWay or manyWay) nature correctly', () => {
      const contentTypeUID = 'api::dummy.dummy';

      const action: any = {
        type: REMOVE_FIELD,
        mainDataKey: 'contentType',
        attributeToRemoveName: 'one_way_attr',
        componentUid: '',
      };
      const contentType = {
        uid: contentTypeUID,
        schema: {
          name: 'dummy',
          attributes: [
            { name: 'name', type: 'string' },
            {
              name: 'one_way_attr',
              relation: 'oneToOne',
              target: contentTypeUID,
              type: 'relation',
            },
            {
              name: 'many_way_attrs',
              relation: 'oneToMany',
              target: contentTypeUID,
              type: 'relation',
            },
            {
              name: 'one_to_many_left',
              relation: 'oneToMany',
              targetAttribute: 'one_to_many_right',
              target: contentTypeUID,
              type: 'relation',
            },
            {
              name: 'one_to_many_right',
              relation: 'manyToOne',
              target: 'api::dummy.dummy',
              targetAttribute: 'one_to_many_left',
              type: 'relation',
            },
          ],
        },
      };

      const expectedContentType = {
        uid: contentTypeUID,
        schema: {
          name: 'dummy',
          attributes: [
            { name: 'name', type: 'string' },
            {
              name: 'many_way_attrs',
              relation: 'oneToMany',
              target: contentTypeUID,
              type: 'relation',
            },
            {
              name: 'one_to_many_left',
              relation: 'oneToMany',
              targetAttribute: 'one_to_many_right',
              target: contentTypeUID,
              type: 'relation',
            },
            {
              name: 'one_to_many_right',
              relation: 'manyToOne',
              target: 'api::dummy.dummy',
              targetAttribute: 'one_to_many_left',
              type: 'relation',
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        contentTypes: {
          [contentTypeUID]: contentType,
        },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const expected = {
        ...initialState,
        contentTypes: {
          [contentTypeUID]: contentType,
        },
        modifiedData: {
          components: {},
          contentType: expectedContentType,
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should handle the removal of the two sides (oneToOne, oneToMany, manyToOne, manyToMany) nature correctly', () => {
      const contentTypeUID = 'api::dummy.dummy';
      const action: any = {
        type: REMOVE_FIELD,
        mainDataKey: 'contentType',
        attributeToRemoveName: 'one_to_many_left',
        componentUid: '',
      };
      const contentType = {
        uid: contentTypeUID,
        schema: {
          name: 'dummy',
          attributes: [
            { name: 'name', type: 'string' },
            {
              name: 'one_way_attr',
              relation: 'oneToOne',
              target: contentTypeUID,
              type: 'relation',
            },
            {
              name: 'many_way_attrs',
              relation: 'oneToMany',
              target: contentTypeUID,
              type: 'relation',
            },
            {
              name: 'one_to_many_left',
              relation: 'oneToMany',
              targetAttribute: 'one_to_many_right',
              target: contentTypeUID,
              type: 'relation',
            },
            {
              name: 'one_to_many_right',
              relation: 'manyToOne',
              target: 'api::dummy.dummy',
              targetAttribute: 'one_to_many_left',
              type: 'relation',
            },
          ],
        },
      };

      const expectedContentType = {
        uid: contentTypeUID,
        schema: {
          name: 'dummy',
          attributes: [
            { name: 'name', type: 'string' },
            {
              name: 'one_way_attr',
              relation: 'oneToOne',
              target: contentTypeUID,
              type: 'relation',
            },
            {
              name: 'many_way_attrs',
              relation: 'oneToMany',
              target: contentTypeUID,
              type: 'relation',
            },
          ],
        },
      };

      const state: any = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType,
        },
      };

      const expected = {
        ...initialState,
        contentTypes: { [contentTypeUID]: contentType },
        modifiedData: {
          components: {},
          contentType: expectedContentType,
        },
      };

      expect(reducer(state, action)).toEqual(expected);
      expect(
        reducer(state, {
          ...action,
          attributeToRemoveName: 'one_to_many_right',
        })
      ).toEqual(expected);
    });
  });

  describe('Removing a field that is targeted by a UID field', () => {
    it('Should remove the attribute correctly and remove the targetField from the UID field', () => {
      const attributeToRemoveName = 'description';
      const action: any = {
        type: REMOVE_FIELD,
        mainDataKey: 'contentType',
        attributeToRemoveName,
        componentUid: '',
      };

      const state: any = {
        ...initialState,
        contentTypes: testData.contentTypes,
        initialContentTypes: testData.contentTypes,
        modifiedData: {
          components: {},
          contentType: {
            uid: 'api::homepage.homepage',
            schema: {
              name: 'homepage',
              attributes: [
                { name: 'title', type: 'string' },
                { name: 'homepageuidfield', type: 'uid', targetField: 'description' },
                { name: 'description', type: 'string' },
                { name: 'other_uid_field', type: 'uid', targetField: 'description' },
              ],
            },
          },
        },
      };

      const expected = {
        ...initialState,
        contentTypes: testData.contentTypes,
        initialContentTypes: testData.contentTypes,
        modifiedData: {
          components: {},
          contentType: {
            uid: 'api::homepage.homepage',
            schema: {
              name: 'homepage',
              attributes: [
                { name: 'title', type: 'string' },
                { name: 'homepageuidfield', type: 'uid' },
                { name: 'other_uid_field', type: 'uid' },
              ],
            },
          },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/utils/tests/cleanData.test.ts">
import {
  formatComponent,
  formatMainDataType,
  getComponentsToPost,
  getCreatedAndModifiedComponents,
  sortContentType,
} from '../cleanData';

import { expectedData } from './expectedFormattedData';
import { data as rawData } from './rawData';

describe('CleanData utils', () => {
  describe('FormatComponent', () => {
    describe('FormatComponent when creating a type (POST)', () => {
      describe('Formatting created component', () => {
        it('should remove the uid key if the component is new', () => {
          const component = rawData.rawData.components['components.main-compo'];

          expect(
            formatComponent(component, 'api::test-content-type.test-content-type')
          ).not.toHaveProperty('uid');
        });

        it('should add a tempUID key if the component is new', () => {
          const component = rawData.rawData.components['components.main-compo'];

          expect(
            formatComponent(component, 'api::test-content-type.test-content-type')
          ).toHaveProperty('tmpUID');
        });

        it('should format the component correctly', () => {
          const component = rawData.rawData.components['components.main-compo'];
          const expectedComponent = expectedData.formattedComponents['components.main-compo'];

          expect(formatComponent(component, 'api::test-content-type.test-content-type')).toEqual(
            expectedComponent
          );
        });
      });

      describe('Formatting existing component', () => {
        it('should format the component correctly', () => {
          const component = rawData.rawData.components['blog.quote'];
          const expectedComponent = expectedData.formattedComponents['blog.quote'];

          expect(formatComponent(component, 'api::test-content-type.test-content-type')).toEqual(
            expectedComponent
          );
        });
      });
    });

    describe('FormatComponent when editing a type content type or component (PUT)', () => {
      describe('Formatting created component', () => {
        it('should remove the uid key if the component is new', () => {
          const component = rawData.rawData.components['components.main-compo'];

          expect(
            formatComponent(component, 'api::test-content-type.test-content-type')
          ).not.toHaveProperty('uid');
        });

        it('should add a tempUID key if the component is new', () => {
          const component = rawData.rawData.components['components.main-compo'];

          expect(
            formatComponent(component, 'api::test-content-type.test-content-type')
          ).toHaveProperty('tmpUID');
        });

        it('should format the component correctly', () => {
          const component = rawData.rawData.components['components.main-compo'];
          const expectedComponent =
            expectedData.formattedComponentsForEdit['components.main-compo'];

          expect(formatComponent(component, 'api::test-content-type.test-content-type')).toEqual(
            expectedComponent
          );
        });
      });

      describe('Formatting existing component', () => {
        it('should format the component correctly', () => {
          const component = rawData.rawData.components['blog.quote'];
          const expectedComponent = expectedData.formattedComponents['blog.quote'];

          expect(formatComponent(component, 'api::test-content-type.test-content-type')).toEqual(
            expectedComponent
          );
        });
      });
    });
  });

  describe('FormatMainDataType', () => {
    describe('Case Content Type', () => {
      describe('POSTING a content type', () => {
        it('should format the content type correctly', () => {
          const {
            rawData: { contentTypeToCreate },
          } = rawData;
          const expected = expectedData.contentTypeToCreate;

          expect(formatMainDataType(contentTypeToCreate)).toEqual(expected);
        });
      });

      describe('PUTING a content type', () => {
        it('should format the content type correctly', () => {
          const {
            rawData: { contentTypeToEdit },
          } = rawData;
          const expected = expectedData.contentTypeToEdit;

          expect(formatMainDataType(contentTypeToEdit)).toEqual(expected);
        });
      });
    });
  });

  describe('GetComponentsToPost', () => {
    describe('Creating a type (POST)', () => {
      it('should return an array containing all the formattedComponents', () => {
        const {
          initialComponents,
          rawData: { components },
        } = rawData;
        const expectedFormattedComponents = expectedData.components;

        expect(
          getComponentsToPost(
            components,
            initialComponents,
            'api::test-content-type.test-content-type'
          )
        ).toEqual(expectedFormattedComponents);
      });
    });

    describe('Editing a type (PUT)', () => {
      it('should return an array containing all the formattedComponents', () => {
        const {
          initialComponents,
          rawData: { components },
        } = rawData;
        const expectedFormattedComponents = expectedData.componentsForEdit;

        expect(
          getComponentsToPost(
            components,
            initialComponents,
            'api::test-content-type.test-content-type'
          )
        ).toEqual(expectedFormattedComponents);
      });
    });
  });

  describe('GetCreatedAndModifiedComponents', () => {
    it('should return an empty array if there is no component', () => {
      expect(getCreatedAndModifiedComponents({}, {})).toEqual([]);
    });

    it('should return an array containing the uid of the modified and created components', () => {
      const { componentsToFormat } = expectedData;
      const {
        initialComponents,
        rawData: { components },
      } = rawData;

      expect(getCreatedAndModifiedComponents(components, initialComponents).sort()).toEqual(
        componentsToFormat.sort()
      );
    });
  });

  describe('sortContentType', () => {
    it('should return sorted collection types array', () => {
      const { sortedContentTypes } = expectedData;
      const {
        rawData: { contentTypesToSort },
      } = rawData;

      expect(sortContentType(contentTypesToSort)).toEqual(sortedContentTypes);
    });

    it('should return an empty array if no content types', () => {
      expect(sortContentType({})).toEqual([]);
    });
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/utils/tests/createModifiedDataSchema.test.ts">
import { createModifiedDataSchema } from '../createModifiedDataSchema';

import type { Components } from '../../../../types';
import type { Internal } from '@strapi/types';

describe('CONTENT TYPE BUILDER | COMPONENTS | DataManagerProvider |utils | createModifiedDataSchema', () => {
  it('should create the modifiedData object correctly when it is used in the content type view and there is no associated components', () => {
    const dataSchema: any = {
      apiID: 'test',
      schema: {
        attributes: [{ type: 'string', name: 'name' }],
      },
    };

    const retrievedComponents: Internal.UID.Component[] = [];
    const components = {};
    const isInContentTypeView = true;

    const expected = {
      contentType: dataSchema,
      components: {},
    };

    expect(
      createModifiedDataSchema(dataSchema, retrievedComponents, components, isInContentTypeView)
    ).toEqual(expected);
  });

  it('should create the modifiedData object correctly when it is used in the component view and there is no associated components', () => {
    const dataSchema: any = {
      apiID: 'test',
      schema: {
        attributes: [{ type: 'string', name: 'name' }],
      },
    };

    const retrievedComponents: Internal.UID.Component[] = [];
    const components = {};
    const isInContentTypeView = false;

    const expected = {
      component: dataSchema,
      components: {},
    };

    expect(
      createModifiedDataSchema(dataSchema, retrievedComponents, components, isInContentTypeView)
    ).toEqual(expected);
  });

  it('should create the modifiedData object correctly when it is used in the content type view and there are some associated components', () => {
    const dataSchema: any = {
      apiID: 'test',
      schema: {
        attributes: [
          { type: 'string', name: 'name' },
          { type: 'component', component: 'blog.dish', name: 'compo' },
        ],
      },
    };

    const retrievedComponents: Internal.UID.Component[] = ['blog.dish'];
    const components: Components = {
      'blog.dish': {
        uid: 'blog.dish',
        schema: { attributes: [{ name: 'name', type: 'string' }] },
      },
      'blog.test': {
        uid: 'blog.test',
        schema: { attributes: [{ type: 'string', name: 'name' }] },
      },
    };
    const isInContentTypeView = true;

    const expected = {
      contentType: dataSchema,
      components: {
        'blog.dish': {
          uid: 'blog.dish',
          schema: { attributes: [{ type: 'string', name: 'name' }] },
        },
      },
    };

    expect(
      createModifiedDataSchema(dataSchema, retrievedComponents, components, isInContentTypeView)
    ).toEqual(expected);
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/utils/tests/expectedFormattedData.ts">
export const expectedData = {
  contentTypeToCreate: {
    displayName: 'test content type',
    description: '',
    attributes: {
      name: {
        type: 'string',
      },
      address: {
        relation: 'oneToOne',
        target: 'api::address.address',
        // targetAttribute: null,
        type: 'relation',
      },
      testContentTypes: {
        relation: 'oneToMany',
        targetAttribute: 'testContentType',
        target: 'api::test-content-type.test-content-type',
        type: 'relation',
      },
      testContentType: {
        relation: 'manyToOne',
        target: 'api::test-content-type.test-content-type',
        targetAttribute: 'testContentTypes',
        type: 'relation',
      },
      mainCompoField: {
        type: 'component',
        repeatable: false,
        component: 'components.main-compo',
      },
      existingCompo: {
        type: 'component',
        repeatable: true,
        component: 'default.metas',
      },
      quote: {
        type: 'component',
        repeatable: false,
        component: 'blog.quote',
      },
      someCustomField: {
        customField: 'plugin::test.test',
        type: 'customField',
      },
    },
  },
  contentTypeToEdit: {
    displayName: 'test content type',
    description: '',
    attributes: {
      name: {
        type: 'string',
      },
      address: {
        relation: 'oneToOne',
        target: 'api::address.address',
        type: 'relation',
      },
      testContentTypes: {
        relation: 'oneToMany',
        targetAttribute: 'testContentType',
        target: 'api::test-content-type.test-content-type',
        type: 'relation',
      },
      testContentType: {
        relation: 'manyToOne',
        target: 'api::test-content-type.test-content-type',
        targetAttribute: 'testContentTypes',
        type: 'relation',
      },
      mainCompoField: {
        type: 'component',
        repeatable: false,
        component: 'components.main-compo',
      },
      existingCompo: {
        type: 'component',
        repeatable: true,
        component: 'default.metas',
      },
      quote: {
        type: 'component',
        repeatable: false,
        component: 'blog.quote',
      },
      someCustomField: {
        customField: 'plugin::test.test',
        type: 'customField',
      },
    },
  },
  componentsToFormat: ['components.main-compo', 'default.nested-compo', 'blog.quote'],
  sortedContentTypes: [
    {
      uid: 'plugin::myplugins.atest',
      name: 'plugin::myplugins.atest',
      title: 'plugin::myplugins.atest',
      to: '/plugins/content-type-builder/content-types/plugin::myplugins.atest',
      kind: 'collectionType',
      visible: true,
      plugin: null,
      restrictRelationsTo: [],
    },
    {
      uid: 'plugin::myplugins.btest',
      name: 'plugin::myplugins.btest',
      title: 'plugin::myplugins.btest',
      to: '/plugins/content-type-builder/content-types/plugin::myplugins.btest',
      kind: 'collectionType',
      visible: true,
      plugin: null,
      restrictRelationsTo: null,
    },
    {
      uid: 'plugin::myplugins.ctest',
      name: 'plugin::myplugins.ctest',
      title: 'plugin::myplugins.ctest',
      to: '/plugins/content-type-builder/content-types/plugin::myplugins.ctest',
      kind: 'collectionType',
      visible: true,
      plugin: null,
      restrictRelationsTo: ['oneWay'],
    },
    {
      uid: 'plugin::myplugins.test',
      name: 'plugin::myplugins.test',
      title: 'plugin::myplugins.test',
      to: '/plugins/content-type-builder/content-types/plugin::myplugins.test',
      kind: 'singleType',
      visible: true,
      plugin: null,
      restrictRelationsTo: null,
    },
  ],

  components: [
    {
      tmpUID: 'components.main-compo',
      name: 'mainCompo',
      icon: 'ad',
      category: 'components',
      attributes: {
        name: {
          type: 'string',
        },
        testContentType: {
          relation: 'oneToOne',
          target: 'api::test-content-type.test-content-type',
          type: 'relation',
        },
        subCompoField: {
          type: 'component',
          repeatable: false,
          component: 'default.nested-compo',
        },
        someCustomField: {
          customField: 'plugin::test.test',
          type: 'customField',
        },
      },
    },
    {
      tmpUID: 'default.nested-compo',
      name: 'nestedCompo',
      icon: 'address-book',
      category: 'default',
      attributes: {
        name: {
          type: 'string',
        },
        email: {
          type: 'email',
        },
      },
    },
    {
      uid: 'blog.quote',
      category: 'blog',
      name: 'quote',
      description: '',
      icon: 'anchor',
      connection: 'default',
      collectionName: 'components_quotes',
      attributes: {
        quote: {
          type: 'string',
          required: true,
        },

        link_to_biography: {
          type: 'string',
          required: true,
        },
      },
    },
  ],
  componentsForEdit: [
    {
      tmpUID: 'components.main-compo',
      name: 'mainCompo',
      icon: 'ad',
      category: 'components',
      attributes: {
        name: {
          type: 'string',
        },
        testContentType: {
          relation: 'oneToOne',
          target: 'api::test-content-type.test-content-type',
          type: 'relation',
        },
        subCompoField: {
          type: 'component',
          repeatable: false,
          component: 'default.nested-compo',
        },
        someCustomField: {
          customField: 'plugin::test.test',
          type: 'customField',
        },
      },
    },
    {
      tmpUID: 'default.nested-compo',
      name: 'nestedCompo',
      icon: 'address-book',
      category: 'default',
      attributes: {
        name: {
          type: 'string',
        },
        email: {
          type: 'email',
        },
      },
    },
    {
      uid: 'blog.quote',
      category: 'blog',
      name: 'quote',
      description: '',
      icon: 'anchor',
      connection: 'default',
      collectionName: 'components_quotes',
      attributes: {
        quote: {
          type: 'string',
          required: true,
        },
        link_to_biography: {
          type: 'string',
          required: true,
        },
      },
    },
  ],
  formattedComponents: {
    'components.main-compo': {
      tmpUID: 'components.main-compo',
      name: 'mainCompo',
      icon: 'ad',
      category: 'components',
      attributes: {
        name: {
          type: 'string',
        },
        testContentType: {
          relation: 'oneToOne',
          target: 'api::test-content-type.test-content-type',
          type: 'relation',
        },
        subCompoField: {
          type: 'component',
          repeatable: false,
          component: 'default.nested-compo',
        },
        someCustomField: {
          customField: 'plugin::test.test',
          type: 'customField',
        },
      },
    },
    'default.nested-compo': {
      tmpUID: 'default.nested-compo',
      name: 'nestedCompo',
      icon: 'address-book',
      category: 'default',
      attributes: {
        name: {
          type: 'string',
        },
        email: {
          type: 'email',
        },
      },
    },
    'blog.quote': {
      uid: 'blog.quote',
      category: 'blog',
      name: 'quote',
      description: '',
      icon: 'anchor',
      connection: 'default',
      collectionName: 'components_quotes',
      attributes: {
        quote: {
          type: 'string',
          required: true,
        },
        link_to_biography: {
          type: 'string',
          required: true,
        },
      },
    },
  },
  formattedComponentsForEdit: {
    'components.main-compo': {
      tmpUID: 'components.main-compo',
      name: 'mainCompo',
      icon: 'ad',
      category: 'components',
      attributes: {
        name: {
          type: 'string',
        },
        testContentType: {
          relation: 'oneToOne',
          target: 'api::test-content-type.test-content-type',
          type: 'relation',
        },
        subCompoField: {
          type: 'component',
          repeatable: false,
          component: 'default.nested-compo',
        },
        someCustomField: {
          customField: 'plugin::test.test',
          type: 'customField',
        },
      },
    },
    'default.nested-compo': {
      tmpUID: 'default.nested-compo',
      name: 'nestedCompo',
      icon: 'address-book',
      category: 'default',
      attributes: {
        name: {
          type: 'string',
        },
        email: {
          type: 'email',
        },
      },
    },
    'blog.quote': {
      uid: 'blog.quote',
      category: 'blog',
      name: 'quote',
      description: '',
      icon: 'anchor',
      connection: 'default',
      collectionName: 'components_quotes',
      attributes: {
        quote: {
          type: 'string',
          required: true,
        },
        link_to_biography: {
          type: 'string',
          required: true,
        },
      },
    },
  },
};
</file>

<file path="admin/src/components/DataManagerProvider/utils/tests/formatSchemas.test.ts">
import { formatSchemas, toAttributesArray } from '../formatSchemas';

import type { AttributeType } from '../../../../types';

describe('CONTENT TYPE BUILDER | components | DataManagerProvider | utils ', () => {
  describe('toAttributesArray', () => {
    it('should return an array of attributes', () => {
      const attributes: Record<string, AttributeType> = {
        name: { type: 'string', pluginOptions: { i18n: { enabled: false } } },
        price: { type: 'integer' },
      };

      const expected = [
        { type: 'string', name: 'name', pluginOptions: { i18n: { enabled: false } } },
        { type: 'integer', name: 'price' },
      ];

      expect(toAttributesArray(attributes)).toEqual(expected);
    });
  });

  describe('formatSchema', () => {
    it('should format all the attributes to an array', () => {
      const schemas = {
        address: {
          apiID: 'address',
          schema: {
            pluginOptions: { i18n: { enabled: false } },
            attributes: {
              name: { type: 'string', pluginOptions: { i18n: { enabled: false } } },
              price: { type: 'integer' },
            },
          },
        },
        test: {
          apiID: 'test',
          schema: {
            pluginOptions: { i18n: { enabled: false } },
            attributes: {
              firstName: { type: 'string', pluginOptions: { i18n: { enabled: false } } },
              lastName: { type: 'string' },
            },
          },
        },
      };

      const expected = {
        address: {
          apiID: 'address',
          schema: {
            pluginOptions: { i18n: { enabled: false } },
            attributes: [
              { type: 'string', pluginOptions: { i18n: { enabled: false } }, name: 'name' },
              { type: 'integer', name: 'price' },
            ],
          },
        },
        test: {
          apiID: 'test',
          schema: {
            pluginOptions: { i18n: { enabled: false } },
            attributes: [
              { type: 'string', pluginOptions: { i18n: { enabled: false } }, name: 'firstName' },
              { type: 'string', name: 'lastName' },
            ],
          },
        },
      };

      expect(formatSchemas(schemas)).toEqual(expected);
    });
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/utils/tests/rawData.ts">
import type { Components, ContentType, ContentTypes } from '../../../../types';

type DataType = {
  initialComponents: Components;
  rawData: {
    components: Components;
    contentTypesToSort: ContentTypes;
    contentTypeToCreate: ContentType;
    contentTypeToEdit: ContentType;
  };
};

export const data: DataType = {
  initialComponents: {
    'default.metas': {
      uid: 'default.metas',
      category: 'default',
      schema: {
        icon: 'angry',
        name: 'metas',
        description: '',
        connection: 'default',
        collectionName: 'components_metas',
        attributes: [
          {
            name: 'meta',
            type: 'string',
            required: true,
            default: 'title',
          },
          {
            name: 'value',
            type: 'text',
            required: true,
            default: 'A title',
          },
        ],
      },
    },
    'blog.quote': {
      uid: 'blog.quote',
      category: 'blog',
      schema: {
        name: 'quote',
        description: '',
        icon: 'anchor',
        connection: 'default',
        collectionName: 'components_quotes',
        attributes: [
          {
            name: 'quote',
            type: 'text',
            required: true,
          },

          {
            name: 'link_to_biography',
            type: 'string',
            required: true,
          },
        ],
      },
    },
  },
  rawData: {
    components: {
      'components.main-compo': {
        uid: 'components.main-compo',
        isTemporary: true,
        category: 'components',
        schema: {
          name: 'mainCompo',
          icon: 'ad',
          attributes: [
            {
              name: 'name',
              type: 'string',
            },
            {
              name: 'testContentType',
              relation: 'oneToOne',
              targetAttribute: null,
              target: 'api::test-content-type.test-content-type',
              type: 'relation',
            },
            {
              name: 'subCompoField',
              type: 'component',
              repeatable: false,
              component: 'default.nested-compo',
            },
            {
              name: 'someCustomField',
              type: 'string',
              customField: 'plugin::test.test',
            },
          ],
        },
      },
      'default.nested-compo': {
        uid: 'default.nested-compo',
        isTemporary: true,
        category: 'default',
        schema: {
          name: 'nestedCompo',
          icon: 'address-book',
          attributes: [
            {
              name: 'name',
              type: 'string',
            },
            {
              name: 'email',
              type: 'email',
              default: null,
            },
          ],
        },
      },
      'default.metas': {
        uid: 'default.metas',
        category: 'default',
        schema: {
          icon: 'angry',
          name: 'metas',
          description: '',
          connection: 'default',
          collectionName: 'components_metas',
          attributes: [
            {
              name: 'meta',
              type: 'string',
              required: true,
              default: 'title',
            },
            {
              name: 'value',
              type: 'text',
              required: true,
              default: 'A title',
            },
          ],
        },
      },
      'blog.quote': {
        uid: 'blog.quote',
        category: 'blog',
        schema: {
          name: 'quote',
          description: '',
          icon: 'anchor',
          connection: 'default',
          collectionName: 'components_quotes',
          attributes: [
            {
              name: 'quote',
              type: 'string',
              required: true,
            },
            {
              name: 'link_to_biography',
              type: 'string',
              required: true,
            },
          ],
        },
      },
    },
    contentTypesToSort: {
      'plugin::myplugins.test': {
        name: 'plugin::myplugins.test',
        title: 'test',
        uid: 'plugin::myplugins.test',
        schema: {
          displayName: 'plugin::myplugins.test',
          kind: 'singleType',
          visible: true,
          restrictRelationsTo: null,
        },
      },
      'plugin::myplugins.btest': {
        name: 'plugin::myplugins.test',
        title: 'test',
        uid: 'plugin::myplugins.btest',
        schema: {
          displayName: 'plugin::myplugins.btest',
          kind: 'collectionType',
          visible: true,
          restrictRelationsTo: null,
        },
      },
      'plugin::myplugins.atest': {
        name: 'plugin::myplugins.test',
        title: 'test',
        uid: 'plugin::myplugins.atest',
        schema: {
          displayName: 'plugin::myplugins.atest',
          kind: 'collectionType',
          visible: true,
          restrictRelationsTo: [],
        },
      },
      'plugin::myplugins.ctest': {
        name: 'plugin::myplugins.ctest',
        title: 'test',
        uid: 'plugin::myplugins.ctest',
        schema: {
          displayName: 'plugin::myplugins.ctest',
          kind: 'collectionType',
          visible: true,
          restrictRelationsTo: ['oneWay'],
        },
      },
    },

    contentTypeToCreate: {
      name: 'api::test-content-type.test-content-type',
      title: 'test',
      uid: 'api::test-content-type.test-content-type',
      isTemporary: true,
      schema: {
        displayName: 'test content type',

        description: '',
        attributes: [
          {
            name: 'name',
            type: 'string',
          },
          {
            name: 'address',
            relation: 'oneToOne',
            targetAttribute: null,
            target: 'api::address.address',
            type: 'relation',
          },
          {
            name: 'testContentTypes',
            relation: 'oneToMany',
            targetAttribute: 'testContentType',
            target: 'api::test-content-type.test-content-type',
            type: 'relation',
          },
          {
            name: 'testContentType',
            relation: 'manyToOne',
            target: 'api::test-content-type.test-content-type',
            targetAttribute: 'testContentTypes',
            type: 'relation',
          },
          {
            name: 'mainCompoField',
            type: 'component',
            repeatable: false,
            component: 'components.main-compo',
          },
          {
            name: 'existingCompo',
            type: 'component',
            repeatable: true,
            component: 'default.metas',
          },
          {
            name: 'quote',
            type: 'component',
            repeatable: false,
            component: 'blog.quote',
          },
          {
            name: 'someCustomField',
            type: 'string',
            customField: 'plugin::test.test',
          },
        ],
      },
    },
    contentTypeToEdit: {
      name: 'api::test-content-type.test-content-type',
      title: 'test',
      uid: 'api::test-content-type.test-content-type',
      schema: {
        displayName: 'test content type',

        description: '',
        attributes: [
          {
            name: 'name',
            type: 'string',
          },
          {
            name: 'address',
            relation: 'oneToOne',
            targetAttribute: null,
            target: 'api::address.address',
            type: 'relation',
          },
          {
            name: 'testContentTypes',
            relation: 'oneToMany',
            targetAttribute: 'testContentType',
            target: 'api::test-content-type.test-content-type',
            type: 'relation',
          },
          {
            name: 'testContentType',
            relation: 'manyToOne',
            target: 'api::test-content-type.test-content-type',
            targetAttribute: 'testContentTypes',
            type: 'relation',
          },
          {
            name: 'mainCompoField',
            type: 'component',
            repeatable: false,
            component: 'components.main-compo',
          },
          {
            name: 'existingCompo',
            type: 'component',
            repeatable: true,
            component: 'default.metas',
          },
          {
            name: 'quote',
            type: 'component',
            repeatable: false,
            component: 'blog.quote',
          },
          {
            name: 'someCustomField',
            type: 'string',
            customField: 'plugin::test.test',
          },
        ],
      },
    },
  },
};
</file>

<file path="admin/src/components/DataManagerProvider/utils/tests/retrieveComponentsFromSchema.test.ts">
import { retrieveComponentsFromSchema } from '../retrieveComponentsFromSchema';

import type { AttributeType, Components } from '../../../../types';

describe('CONTENT TYPE BUILDER | components | DataManagerProvider |utils | retrieveComponentsFromSchema', () => {
  it('should return an array of components name', () => {
    const attributes: AttributeType[] = [
      {
        maxLength: 50,
        required: true,
        minLength: 5,
        type: 'string',
        pluginOptions: {},
        name: 'name',
      },
      { type: 'uid', targetField: 'name', pluginOptions: {}, name: 'slug' },

      {
        type: 'relation',
        relation: 'oneToOne',
        target: 'api::address.address',
        targetAttribute: null,
        private: false,
        name: 'address',
      },

      {
        type: 'relation',
        relation: 'oneToOne',
        target: 'api::menu.menu',
        inversedBy: 'restaurant',
        targetAttribute: 'restaurant',
        private: false,
        name: 'menu',
      },
      {
        component: 'default.openingtimes',
        type: 'component',
        repeatable: true,
        min: 1,
        max: 10,
        pluginOptions: {},
        name: 'opening_times',
      },
      {
        type: 'dynamiczone',
        components: ['default.restaurantservice'],
        pluginOptions: {},
        name: 'dz',
      },
    ];

    const components: Components = {
      'blog.test-como': {
        uid: 'blog.test-como',
        category: 'blog',
        apiId: 'test-como',
        schema: {
          icon: 'ad',
          name: 'test comp',
          description: '',
          collectionName: 'components_blog_test_comos',
          attributes: [{ type: 'string', name: 'name' }],
        },
      },
      'default.closingperiod': {
        uid: 'default.closingperiod',
        category: 'default',
        apiId: 'closingperiod',
        schema: {
          icon: 'angry',
          name: 'closingperiod',
          description: '',
          collectionName: 'components_closingperiods',
          attributes: [
            { type: 'string', name: 'label' },
            { type: 'date', required: true, name: 'start_date' },
            { type: 'date', required: true, name: 'end_date' },
            { type: 'media', multiple: false, required: false, name: 'media' },
            { component: 'default.dish', type: 'component', name: 'dish' },
          ],
        },
      },
      'default.dish': {
        uid: 'default.dish',
        category: 'default',
        apiId: 'dish',
        schema: {
          icon: 'address-book',
          name: 'dish',
          description: '',
          collectionName: 'components_dishes',
          attributes: [
            { type: 'string', required: false, default: 'My super dish', name: 'name' },
            { type: 'text', name: 'description' },
            { type: 'float', name: 'price' },
            { type: 'media', multiple: false, required: false, name: 'picture' },
            { type: 'richtext', name: 'very_long_description' },
            {
              type: 'relation',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              private: false,
              name: 'categories',
            },
          ],
        },
      },
      'default.openingtimes': {
        uid: 'default.openingtimes',
        category: 'default',
        apiId: 'openingtimes',
        schema: {
          icon: 'calendar',
          name: 'openingtimes',
          description: '',
          collectionName: 'components_openingtimes',
          attributes: [
            { type: 'string', required: true, default: 'something', name: 'label' },
            { type: 'string', name: 'time' },
            { type: 'component', repeatable: true, component: 'default.dish', name: 'dishrep' },
          ],
        },
      },
      'default.restaurantservice': {
        uid: 'default.restaurantservice',
        category: 'default',
        apiId: 'restaurantservice',
        schema: {
          icon: 'cannabis',
          name: 'restaurantservice',
          description: '',
          collectionName: 'components_restaurantservices',
          attributes: [
            { type: 'string', required: true, default: 'something', name: 'name' },
            { type: 'media', multiple: false, required: false, name: 'media' },
            { type: 'boolean', required: true, default: true, name: 'is_available' },
          ],
        },
      },
    };

    const expected = ['default.openingtimes', 'default.dish', 'default.restaurantservice'];

    expect(retrieveComponentsFromSchema(attributes, components)).toEqual(expected);
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/utils/tests/retrieveComponentsThatHaveComponents.test.ts">
import {
  getComponentWithChildComponents,
  retrieveComponentsThatHaveComponents,
} from '../retrieveComponentsThatHaveComponents';

const data: any = {
  // Slider has a component
  'blog.slider': {
    uid: 'blog.slider',
    category: 'blog',
    schema: {
      icon: 'atom',
      name: 'slider',
      description: '',
      connection: 'default',
      collectionName: 'components_sliders',
      attributes: [
        { type: 'string', required: true, name: 'title' },
        {
          name: 'slide',
          component: 'default.slide',
          type: 'component',
          repeatable: true,
          min: 1,
          max: 5,
        },
      ],
    },
  },
  'default.dish': {
    uid: 'default.dish',
    category: 'default',
    schema: {
      icon: 'beer',
      name: 'dish',
      description: '',
      connection: 'default',
      collectionName: 'components_dishes',
      attributes: [
        {
          name: 'name',
          type: 'string',
          required: true,
          default: 'My super dish',
        },
        {
          name: 'description',
          type: 'text',
        },
        {
          name: 'price',
          type: 'float',
        },
        {
          name: 'address',
          relation: 'oneToOne',
          target: 'api::address.address',
          type: 'relation',
        },
        {
          name: 'addresses',
          relation: 'oneToMany',
          target: 'api::address.address',
          type: 'relation',
        },
        {
          name: 'picture',
          type: 'media',
          multiple: false,
          required: false,
        },
        {
          name: 'very_long_description',
          type: 'richtext',
        },
      ],
    },
  },
};

describe('retrieveComponentsThatHaveComponents', () => {
  describe('doesComponentHaveAComponentField', () => {
    it('Should return correct child component if component has a component', () => {
      expect(getComponentWithChildComponents(data['blog.slider'])).toEqual({
        component: 'blog.slider',
        childComponents: [
          {
            component: 'default.slide',
          },
        ],
      });
    });

    it('Should return no child components if component has no child components', () => {
      expect(getComponentWithChildComponents(data['default.dish'])).toEqual({
        component: 'default.dish',
        childComponents: [],
      });
    });
  });

  describe('retrievComponentsThatHaveComponents', () => {
    it('should return an array with all the components that have nested components', () => {
      expect(retrieveComponentsThatHaveComponents(data)).toEqual([
        {
          component: 'blog.slider',
          childComponents: [
            {
              component: 'default.slide',
            },
          ],
        },
      ]);
    });
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/utils/tests/retrieveNestedComponents.test.ts">
import { retrieveNestedComponents } from '../retrieveNestedComponents';

import type { Components } from '../../../../types';

describe('CONTENT TYPE BUILDER | COMPONENTS | DataManagerProvider | utils | retrieveNestedComponents', () => {
  it('should return an array of nested components', () => {
    const components: Components = {
      'default.closingperiod': {
        uid: 'default.closingperiod',
        category: 'default',
        apiId: 'closingperiod',
        schema: {
          icon: 'angry',
          name: 'closingperiod',
          description: '',
          collectionName: 'components_closingperiods',
          attributes: [
            { type: 'string', name: 'label' },
            { type: 'date', required: true, name: 'start_date' },
            { type: 'date', required: true, name: 'end_date' },
            { type: 'media', multiple: false, required: false, name: 'media' },
            { component: 'default.dish', type: 'component', name: 'dish' },
          ],
        },
      },
      'default.dish': {
        uid: 'default.dish',
        category: 'default',
        apiId: 'dish',
        schema: {
          icon: 'address-book',
          name: 'dish',
          description: '',
          collectionName: 'components_dishes',
          attributes: [
            { type: 'string', required: false, default: 'My super dish', name: 'name' },
            { type: 'text', name: 'description' },
            { type: 'float', name: 'price' },
            { type: 'media', multiple: false, required: false, name: 'picture' },
            { type: 'richtext', name: 'very_long_description' },
            {
              type: 'relation',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              private: false,
              name: 'categories',
            },
          ],
        },
      },
    };

    const expected = [
      {
        component: 'default.dish',
        uidsOfAllParents: ['default.closingperiod'],
      },
    ];

    expect(retrieveNestedComponents(components)).toEqual(expected);
  });

  it('should return both parents', () => {
    const components: Components = {
      'default.closingperiod': {
        uid: 'default.closingperiod',
        category: 'default',
        apiId: 'closingperiod',
        schema: {
          icon: 'angry',
          name: 'closingperiod',
          description: '',
          collectionName: 'components_closingperiods',
          attributes: [
            { type: 'string', name: 'label' },
            { type: 'date', required: true, name: 'start_date' },
            { type: 'date', required: true, name: 'end_date' },
            { type: 'media', multiple: false, required: false, name: 'media' },
            { component: 'default.dish', type: 'component', name: 'dish' },
          ],
        },
      },
      'default.dish': {
        uid: 'default.dish',
        category: 'default',
        apiId: 'dish',
        schema: {
          icon: 'address-book',
          name: 'dish',
          description: '',
          collectionName: 'components_dishes',
          attributes: [
            { type: 'string', required: false, default: 'My super dish', name: 'name' },
            { type: 'text', name: 'description' },
            { type: 'float', name: 'price' },
            { type: 'media', multiple: false, required: false, name: 'picture' },
            { type: 'richtext', name: 'very_long_description' },
            {
              type: 'relation',
              relation: 'oneToOne',
              target: 'api::category.category',
              targetAttribute: null,
              private: false,
              name: 'categories',
            },
          ],
        },
      },

      'default.openingperiod': {
        uid: 'default.openingperiod',
        category: 'default',
        apiId: 'openingperiod',
        schema: {
          icon: 'angry',
          name: 'openingperiod',
          description: '',
          collectionName: 'components_openingperiods',
          attributes: [{ component: 'default.dish', type: 'component', name: 'dish' }],
        },
      },
    };

    const expected = [
      {
        component: 'default.dish',
        uidsOfAllParents: ['default.closingperiod', 'default.openingperiod'],
      },
    ];

    expect(retrieveNestedComponents(components)).toEqual(expected);
  });
});
</file>

<file path="admin/src/components/DataManagerProvider/utils/cleanData.ts">
import camelCase from 'lodash/camelCase';
import get from 'lodash/get';
import isEqual from 'lodash/isEqual';
import omit from 'lodash/omit';
import sortBy from 'lodash/sortBy';

import { pluginId } from '../../../pluginId';
import { makeUnique } from '../../../utils/makeUnique';

import type { Components, Component, AttributeType, ContentTypes } from '../../../types';
import type { Internal } from '@strapi/types';

const getCreatedAndModifiedComponents = (
  allComponents: Components,
  initialComponents: Components
) => {
  const componentUIDsToReturn = Object.keys(allComponents).filter((compoUid) => {
    const currentCompo = get(allComponents, compoUid, {});
    const initialCompo = get(initialComponents, compoUid, {});
    const hasComponentBeenCreated = get(currentCompo, ['isTemporary'], false);
    const hasComponentBeenModified = !isEqual(currentCompo, initialCompo);

    return hasComponentBeenCreated || hasComponentBeenModified;
  });

  return makeUnique(componentUIDsToReturn);
};

const formatComponent = (
  component: Component | Record<string, any>,
  mainDataUID: Internal.UID.Schema
) => {
  const formattedAttributes = formatAttributes(
    get(component, 'schema.attributes', []),
    mainDataUID
  );

  // Set tmpUID if the component has just been created
  // Keep the uid if the component already exists
  const compoUID = get(component, 'isTemporary', false)
    ? { tmpUID: component.uid }
    : { uid: component.uid };

  const formattedComponent = Object.assign(
    {},
    compoUID,
    { category: component.category },
    // Omit the attributes since we want to format them
    omit(component.schema, 'attributes'),
    // Add the formatted attributes
    { attributes: formattedAttributes }
  );

  return formattedComponent;
};

const formatMainDataType = (data: any, isComponent = false) => {
  const mainDataUID = get(data, 'uid', null);

  const formattedAttributes = formatAttributes(get(data, 'schema.attributes', []), mainDataUID);
  const initObj = isComponent ? { category: get(data, 'category', '') } : {};

  const formattedContentType = Object.assign(initObj, omit(data.schema, 'attributes'), {
    attributes: formattedAttributes,
  });

  delete formattedContentType.uid;
  delete formattedContentType.isTemporary;
  delete formattedContentType.visible;
  delete formattedContentType.restrictRelationsTo;

  return formattedContentType;
};

/**
 *
 * @param {Object} attributes
 * @param {String} mainDataUID uid of the main data type
 */
const formatAttributes = (attributes: AttributeType[], mainDataUID: Internal.UID.Schema) => {
  return attributes.reduce((acc: Record<string, AttributeType>, { name, ...rest }) => {
    const currentAttribute = rest;
    const hasARelationWithMainDataUID = currentAttribute.target === mainDataUID;
    const isRelationType = currentAttribute.type === 'relation';
    const currentTargetAttribute = get(currentAttribute, 'targetAttribute', null);

    if (!hasARelationWithMainDataUID) {
      if (isRelationType) {
        const relationAttr = Object.assign({}, currentAttribute, {
          targetAttribute: formatRelationTargetAttribute(currentTargetAttribute),
        });

        acc[name as string] = removeNullKeys(relationAttr) as AttributeType;
      } else {
        acc[name as string] = removeNullKeys(currentAttribute) as AttributeType;
      }
    }

    if (hasARelationWithMainDataUID) {
      const target = currentAttribute.target;

      const formattedRelationAttribute = Object.assign({}, currentAttribute, {
        target,
        targetAttribute: formatRelationTargetAttribute(currentTargetAttribute),
      });

      acc[name as string] = removeNullKeys(formattedRelationAttribute) as AttributeType;
    }

    if (currentAttribute.customField) {
      const customFieldAttribute = { ...currentAttribute, type: 'customField' };
      acc[name as string] = removeNullKeys(customFieldAttribute) as AttributeType;
    }

    return acc;
  }, {});
};

const formatRelationTargetAttribute = (targetAttribute: string | null) =>
  targetAttribute === '-' ? null : targetAttribute;

const removeNullKeys = (obj: Record<string, any>) =>
  Object.keys(obj).reduce((acc: Record<string, any>, current) => {
    if (obj[current] !== null && current !== 'plugin') {
      acc[current] = obj[current];
    }

    return acc;
  }, {});

const getComponentsToPost = (
  allComponents: Components,
  initialComponents: Components,
  mainDataUID: Internal.UID.Schema
) => {
  const componentsToFormat = getCreatedAndModifiedComponents(allComponents, initialComponents);
  const formattedComponents = componentsToFormat.map((compoUID) => {
    const currentCompo = get(allComponents, compoUID, {});
    const formattedComponent = formatComponent(currentCompo, mainDataUID);

    return formattedComponent;
  });

  return formattedComponents;
};

const sortContentType = (types: ContentTypes) =>
  sortBy(
    Object.keys(types)
      .map((uid) => ({
        visible: types[uid].schema.visible,
        name: uid,
        title: types[uid].schema.displayName,
        plugin: types[uid].plugin || null,
        uid,
        to: `/plugins/${pluginId}/content-types/${uid}`,
        kind: types[uid].schema.kind,
        restrictRelationsTo: types[uid].schema.restrictRelationsTo,
      }))
      .filter((obj) => obj !== null),
    (obj) => camelCase(obj.title)
  );

export {
  formatComponent,
  formatMainDataType,
  getComponentsToPost,
  getCreatedAndModifiedComponents,
  sortContentType,
};
</file>

<file path="admin/src/components/DataManagerProvider/utils/createDataObject.ts">
import { ContentType } from '../../../types';

export const createDataObject = (arr: ContentType[]) =>
  arr.reduce((acc: Record<string, ContentType>, current) => {
    acc[current.uid!] = current;

    return acc;
  }, {});
</file>

<file path="admin/src/components/DataManagerProvider/utils/createModifiedDataSchema.ts">
import get from 'lodash/get';

import type { ContentType, Components } from '../../../types';
import type { Internal } from '@strapi/types';

export const createModifiedDataSchema = (
  contentTypeSchema: ContentType,
  retrievedComponents: Internal.UID.Component[],
  allComponentsSchema: Components,
  isInContentTypeView: boolean
) => {
  const componentsAssociatedToContentType = retrievedComponents.reduce((acc: any, current) => {
    const componentSchema = get(allComponentsSchema, current, {});

    acc[current] = componentSchema;

    return acc;
  }, {});
  const keyName = isInContentTypeView ? 'contentType' : 'component';
  const schema = {
    [keyName]: contentTypeSchema,
    components: componentsAssociatedToContentType,
  };

  return schema;
};
</file>

<file path="admin/src/components/DataManagerProvider/utils/formatSchemas.ts">
import { AttributeType } from '../../../types';

/**
 * Format the attributes to array instead of an object
 */
export const formatSchemas = (schemas: Record<string, any>) => {
  return Object.keys(schemas).reduce((acc: any, current) => {
    const schema = schemas[current].schema;

    acc[current] = {
      ...schemas[current],
      schema: { ...schema, attributes: toAttributesArray(schema.attributes) },
    };

    return acc;
  }, {});
};

export const toAttributesArray = (attributes: Record<string, AttributeType>) => {
  return Object.keys(attributes).reduce((acc: AttributeType[], current: any) => {
    acc.push({ ...attributes[current], name: current });

    return acc;
  }, []);
};
</file>

<file path="admin/src/components/DataManagerProvider/utils/retrieveComponentsFromSchema.ts">
import get from 'lodash/get';

import { makeUnique } from '../../../utils/makeUnique';

import type { AttributeType, Components } from '../../../types';
import type { Internal } from '@strapi/types';

const retrieveComponentsFromSchema = (
  attributes: AttributeType[],
  allComponentsData: Components
): Internal.UID.Component[] => {
  const allComponents: Internal.UID.Component[] = attributes.reduce((acc: any, current) => {
    const type = current.type;
    if (type === 'component') {
      const currentComponentName = current.component;
      // Push the existing compo
      acc.push(currentComponentName);

      const currentComponentAttributes = get(
        allComponentsData,
        [currentComponentName, 'schema', 'attributes'],
        []
      );

      // Retrieve the nested ones
      acc.push(...retrieveComponentsFromSchema(currentComponentAttributes, allComponentsData));
    }

    if (type === 'dynamiczone') {
      const dynamicZoneComponents = current.components;
      const componentsFromDZComponents = dynamicZoneComponents.reduce((acc2: any, currentUid) => {
        const compoAttrs = get(allComponentsData, [currentUid, 'schema', 'attributes'], []);

        return [...acc2, ...retrieveComponentsFromSchema(compoAttrs, allComponentsData)];
      }, []);

      return [...acc, ...dynamicZoneComponents, ...componentsFromDZComponents];
    }

    return acc;
  }, []);

  return makeUnique<Internal.UID.Component>(allComponents);
};

export { retrieveComponentsFromSchema };
</file>

<file path="admin/src/components/DataManagerProvider/utils/retrieveComponentsThatHaveComponents.ts">
import get from 'lodash/get';

import type { Component, AttributeType, Components } from '../../../types';
import type { Internal } from '@strapi/types';

type ChildComponent = {
  component: Internal.UID.Component;
};

export type ComponentWithChildren = {
  component: Internal.UID.Component;
  childComponents: ChildComponent[];
};

const retrieveComponentsThatHaveComponents = (allComponents: Components) => {
  const componentsThatHaveNestedComponents = Object.keys(allComponents).reduce(
    (acc: ComponentWithChildren[], current) => {
      const currentComponent = get(allComponents, [current]);

      const compoWithChildren = getComponentWithChildComponents(currentComponent);
      if (compoWithChildren.childComponents.length > 0) {
        acc.push(compoWithChildren);
      }

      return acc;
    },
    []
  );

  return componentsThatHaveNestedComponents;
};

const getComponentWithChildComponents = (component: Component): ComponentWithChildren => {
  const attributes = get(component, ['schema', 'attributes'], []) as AttributeType[];
  return {
    component: component.uid,
    childComponents: attributes
      .filter((attribute) => {
        const { type } = attribute;

        return type === 'component';
      })
      .map((attribute) => {
        return {
          component: attribute.component,
        } as ChildComponent;
      }),
  };
};

export { getComponentWithChildComponents, retrieveComponentsThatHaveComponents };
</file>

<file path="admin/src/components/DataManagerProvider/utils/retrieveNestedComponents.ts">
import type { Components, AttributeType } from '../../../types';
import type { Internal } from '@strapi/types';

export type NestedComponent = {
  component: Internal.UID.Component;
  uidsOfAllParents?: Internal.UID.Component[];
  parentCompoUid?: Internal.UID.Component;
};

export const retrieveNestedComponents = (appComponents: Components): NestedComponent[] => {
  const nestedComponents = Object.keys(appComponents).reduce((acc: NestedComponent[], current) => {
    const componentAttributes = appComponents?.[current]?.schema?.attributes ?? [];
    const currentComponentNestedCompos = getComponentsNestedWithinComponent(
      componentAttributes,
      current as Internal.UID.Component
    );
    return [...acc, ...currentComponentNestedCompos];
  }, []);

  return mergeComponents(nestedComponents);
};

const getComponentsNestedWithinComponent = (
  componentAttributes: AttributeType[],
  parentCompoUid: Internal.UID.Component
) => {
  return componentAttributes.reduce((acc: NestedComponent[], current) => {
    const { type, component } = current;
    if (type === 'component') {
      acc.push({
        component,
        parentCompoUid,
      });
    }

    return acc;
  }, []);
};

// Merge duplicate components
const mergeComponents = (originalComponents: NestedComponent[]): NestedComponent[] => {
  const componentMap = new Map();
  // Populate the map with component and its parents
  originalComponents.forEach(({ component, parentCompoUid }) => {
    if (!componentMap.has(component)) {
      componentMap.set(component, new Set());
    }
    componentMap.get(component).add(parentCompoUid);
  });

  // Convert the map to the desired array format
  const transformedComponents: NestedComponent[] = Array.from(componentMap.entries()).map(
    ([component, parentCompoUidSet]) => ({
      component,
      uidsOfAllParents: Array.from(parentCompoUidSet),
    })
  );

  return transformedComponents;
};
</file>

<file path="admin/src/components/DataManagerProvider/utils/retrieveSpecificInfoFromComponents.ts">
import get from 'lodash/get';

import { makeUnique } from '../../../utils/makeUnique';

export const retrieveSpecificInfoFromComponents = (allComponents: any, keysToRetrieve: any) => {
  const allData = Object.keys(allComponents).map((compo) => {
    return get(allComponents, [compo, ...keysToRetrieve], '');
  });

  return makeUnique(allData);
};
</file>

<file path="admin/src/components/DataManagerProvider/utils/serverRestartWatcher.ts">
const SERVER_HAS_NOT_BEEN_KILLED_MESSAGE = 'did-not-kill-server';
const SERVER_HAS_BEEN_KILLED_MESSAGE = 'server is down';

/**
 * Server restart watcher
 * Sends an HEAD method to check if the server has been shut down correctly
 * and then pings until it's back on
 */
export function serverRestartWatcher(response: any, didShutDownServer?: boolean) {
  return new Promise((resolve) => {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    fetch(`${window.strapi.backendURL}/_health`, {
      method: 'HEAD',
      mode: 'no-cors',
      headers: {
        'Content-Type': 'application/json',
        'Keep-Alive': 'false',
      },
    })
      .then((res) => {
        if (res.status >= 400) {
          throw new Error(SERVER_HAS_BEEN_KILLED_MESSAGE);
        }

        if (!didShutDownServer) {
          throw new Error(SERVER_HAS_NOT_BEEN_KILLED_MESSAGE);
        }

        resolve(response);
      })
      .catch((err) => {
        setTimeout(() => {
          return serverRestartWatcher(
            response,
            err.message !== SERVER_HAS_NOT_BEEN_KILLED_MESSAGE
          ).then(resolve);
        }, 100);
      });
  });
}
</file>

<file path="admin/src/components/DataManagerProvider/utils/validateSchema.ts">
export const validateSchema = (schema: any) => {
  const dynamicZoneAttributes = Object.values(schema.attributes).filter(
    (attribute: any) => attribute.type === 'dynamiczone'
  );

  return dynamicZoneAttributes.every(
    (attribute: any) => Array.isArray(attribute.components) && attribute.components.length > 0
  );
};
</file>

<file path="admin/src/components/DataManagerProvider/constants.ts">
export const ADD_ATTRIBUTE = 'ContentTypeBuilder/DataManagerProvider/ADD_ATTRIBUTE';
export const ADD_CUSTOM_FIELD_ATTRIBUTE =
  'ContentTypeBuilder/DataManagerProvider/ADD_CUSTOM_FIELD_ATTRIBUTE';
export const ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE =
  'ContentTypeBuilder/DataManagerProvider/ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE';
export const CHANGE_DYNAMIC_ZONE_COMPONENTS =
  'ContentTypeBuilder/DataManagerProvider/CHANGE_DYNAMIC_ZONE_COMPONENTS';
export const CREATE_SCHEMA = 'ContentTypeBuilder/DataManagerProvider/CREATE_SCHEMA';
export const CREATE_COMPONENT_SCHEMA =
  'ContentTypeBuilder/DataManagerProvider/CREATE_COMPONENT_SCHEMA';
export const DELETE_NOT_SAVED_TYPE = 'ContentTypeBuilder/DataManagerProvider/DELETE_NOT_SAVED_TYPE';
export const EDIT_ATTRIBUTE = 'ContentTypeBuilder/DataManagerProvider/EDIT_ATTRIBUTE';
export const EDIT_CUSTOM_FIELD_ATTRIBUTE =
  'ContentTypeBuilder/DataManagerProvider/EDIT_CUSTOM_FIELD_ATTRIBUTE';
export const GET_DATA_SUCCEEDED = 'ContentTypeBuilder/DataManagerProvider/GET_DATA_SUCCEEDED';
export const RELOAD_PLUGIN = 'ContentTypeBuilder/DataManagerProvider/RELOAD_PLUGIN';
export const REMOVE_FIELD_FROM_DISPLAYED_COMPONENT =
  'ContentTypeBuilder/DataManagerProvider/REMOVE_FIELD_FROM_DISPLAYED_COMPONENT';
export const REMOVE_COMPONENT_FROM_DYNAMIC_ZONE =
  'ContentTypeBuilder/DataManagerProvider/REMOVE_COMPONENT_FROM_DYNAMIC_ZONE';
export const REMOVE_FIELD = 'ContentTypeBuilder/DataManagerProvider/REMOVE_FIELD';
export const SET_MODIFIED_DATA = 'ContentTypeBuilder/DataManagerProvider/SET_MODIFIED_DATA';
export const UPDATE_SCHEMA = 'ContentTypeBuilder/DataManagerProvider/UPDATE_SCHEMA';
export const UPDATE_INITIAL_STATE = 'ContentTypeBuilder/DataManagerProvider/UPDATE_INITIAL_STATE';
</file>

<file path="admin/src/components/DataManagerProvider/reducer.ts">
import produce, { current } from 'immer';
import get from 'lodash/get';
import set from 'lodash/set';

import { getRelationType } from '../../utils/getRelationType';
import { makeUnique } from '../../utils/makeUnique';

import * as actions from './constants';
import { retrieveComponentsFromSchema } from './utils/retrieveComponentsFromSchema';

import type { DataManagerStateType, ContentType, AttributeType, Component } from '../../types';
import type { Internal, Schema } from '@strapi/types';

// TODO: Define all possible actions based on type
export type Action = {
  type: string;
  uid?: string;
  mainDataKey: 'component' | 'components' | 'contentTypes' | 'contentType';
  schemaType: 'component' | 'contentType';
  attributeToRemoveName?: string;
  [key: string]: any;
};

const initialState: DataManagerStateType = {
  components: {},
  contentTypes: {},
  initialComponents: {},
  initialContentTypes: {},
  initialData: {},
  modifiedData: {
    components: {},
    contentTypes: {},
  },
  reservedNames: {},
  isLoading: true,
  isLoadingForDataToBeSet: true,
};

const ONE_SIDE_RELATIONS = ['oneWay', 'manyWay'];

const getOppositeRelation = (originalRelation?: Schema.Attribute.RelationKind.WithTarget) => {
  if (originalRelation === 'manyToOne') {
    return 'oneToMany';
  }

  if (originalRelation === 'oneToMany') {
    return 'manyToOne';
  }

  return originalRelation;
};

const findAttributeIndex = (schema: any, attributeToFind?: string) => {
  return schema.schema.attributes.findIndex(
    ({ name }: { name: string }) => name === attributeToFind
  );
};

const reducer = (state = initialState, action: Action) =>
  produce(state, (draftState: any) => {
    switch (action.type) {
      case actions.ADD_ATTRIBUTE: {
        const {
          attributeToSet: { name, ...rest },
          forTarget,
          targetUid,
        } = action;
        delete rest.createComponent;

        const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)
          ? [forTarget]
          : [forTarget, targetUid];

        const currentAttributes = get(
          state,
          ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'],
          []
        ).slice();

        // Add the createdAttribute
        const updatedAttributes = [...currentAttributes, { ...rest, name }];

        set(
          draftState,
          ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'],
          updatedAttributes
        );

        if (action.shouldAddComponentToData) {
          const componentToAddUID = rest.component;
          const componentToAdd = state.components[componentToAddUID];
          const isTemporaryComponent = componentToAdd?.isTemporary;
          const hasComponentAlreadyBeenAdded =
            state.modifiedData.components?.[componentToAddUID] !== undefined;

          if (isTemporaryComponent || hasComponentAlreadyBeenAdded) {
            break;
          }

          // Initialize modifiedData.components if it is undefined
          if (!draftState.modifiedData.components) {
            draftState.modifiedData.components = {};
          }

          // Add the added component to the modifiedData.components
          draftState.modifiedData.components[componentToAddUID] = componentToAdd;

          const nestedComponents = retrieveComponentsFromSchema(
            componentToAdd.schema.attributes as AttributeType[],
            state.components
          );

          // We dont' need to set the already added components otherwise all modifications will be lost so we need to only add the not modified ones
          const nestedComponentsToAddInModifiedData = nestedComponents.filter(
            (compoUID: Internal.UID.Component) => {
              return get(state, ['modifiedData', 'components', compoUID]) === undefined;
            }
          );

          nestedComponentsToAddInModifiedData.forEach((compoUID: Internal.UID.Component) => {
            const compoSchema = get(state, ['components', compoUID], {}) as Component;
            const isTemporary = compoSchema.isTemporary || false;

            // If the nested component has not been saved we don't need to add them as they are already in the state
            if (!isTemporary) {
              if (!draftState.modifiedData.components) {
                draftState.modifiedData.components = {};
              }
              draftState.modifiedData.components[compoUID] = compoSchema;
            }
          });

          break;
        }

        const isCreatingRelationAttribute = rest.type === 'relation';

        if (isCreatingRelationAttribute) {
          const target = rest.target;
          const targetAttribute = rest.targetAttribute || null;
          const relation = rest.relation;
          const relationType = getRelationType(relation, targetAttribute);
          const currentUid = get(state, ['modifiedData', ...pathToDataToEdit, 'uid']);

          // When the user in creating a relation with the same content type we need to create another attribute
          // that is the opposite of the created one
          if (
            rest.type === 'relation' &&
            relationType !== 'oneWay' &&
            relationType !== 'manyWay' &&
            target === currentUid
          ) {
            const oppositeAttribute = {
              name: targetAttribute,
              relation: getOppositeRelation(relationType),
              target,
              targetAttribute: name,
              type: 'relation',
            } as AttributeType;

            if (rest.private) {
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              oppositeAttribute.private = rest.private;
            }

            const attributesToSet = [...updatedAttributes, oppositeAttribute];

            set(
              draftState,
              ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'],
              attributesToSet
            );
          }
        }

        break;
      }
      case actions.ADD_CREATED_COMPONENT_TO_DYNAMIC_ZONE: {
        const { dynamicZoneTarget, componentsToAdd } = action;

        const dzAttributeIndex = findAttributeIndex(
          state.modifiedData.contentType,
          dynamicZoneTarget
        );

        componentsToAdd.forEach((componentUid: Internal.UID.Component) => {
          if (
            !draftState.modifiedData.contentType?.schema.attributes[dzAttributeIndex].components
          ) {
            draftState.modifiedData.contentType.schema.attributes[dzAttributeIndex].components = [];
          }
          draftState.modifiedData.contentType.schema.attributes[dzAttributeIndex].components.push(
            componentUid
          );
        });

        break;
      }
      case actions.ADD_CUSTOM_FIELD_ATTRIBUTE: {
        const {
          attributeToSet: { name, ...rest },
          forTarget,
          targetUid,
        } = action;

        const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)
          ? [forTarget]
          : [forTarget, targetUid];

        const currentAttributes = get(
          state,
          ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'],
          []
        ).slice();

        // Add the createdAttribute
        const updatedAttributes = [...currentAttributes, { ...rest, name }];

        set(
          draftState,
          ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'],
          updatedAttributes
        );

        break;
      }
      case actions.CHANGE_DYNAMIC_ZONE_COMPONENTS: {
        const { dynamicZoneTarget, newComponents } = action;

        const dzAttributeIndex = findAttributeIndex(
          state.modifiedData.contentType,
          dynamicZoneTarget
        );

        const currentDZComponents =
          (state.modifiedData.contentType?.schema.attributes[dzAttributeIndex]).components;

        const updatedComponents = makeUnique([...currentDZComponents, ...newComponents]);

        (draftState.modifiedData.contentType?.schema.attributes[dzAttributeIndex]).components =
          updatedComponents;

        // Retrieve all the components that needs to be added to the modifiedData.components
        const nestedComponents = retrieveComponentsFromSchema(
          current(draftState.modifiedData.contentType.schema.attributes),
          state.components
        );

        // We dont' need to set the already added components otherwise all modifications will be lost so we need to only add the not modified ones
        const nestedComponentsToAddInModifiedData = nestedComponents.filter((compoUID) => {
          return get(state, ['modifiedData', 'components', compoUID]) === undefined;
        });

        nestedComponentsToAddInModifiedData.forEach((compoUID: Internal.UID.Component) => {
          const compoSchema = get(state, ['components', compoUID], {}) as Component;
          const isTemporary = compoSchema.isTemporary || false;

          // If the nested component has not been saved we don't need to add them as they are already in the state
          if (!isTemporary) {
            if (!draftState.modifiedData.components) {
              draftState.modifiedData.components = {};
            }
            draftState.modifiedData.components[compoUID] = compoSchema;
          }
        });

        break;
      }
      case actions.CREATE_COMPONENT_SCHEMA: {
        const newSchema: Component = {
          uid: action.uid as Internal.UID.Component,
          isTemporary: true,
          category: action.componentCategory,
          schema: {
            ...action.data,
            attributes: [],
          },
        };
        draftState.components[action.uid as string] = newSchema;

        if (action.shouldAddComponentToData) {
          draftState.modifiedData.components[action.uid as string] = newSchema;
        }

        break;
      }
      case actions.CREATE_SCHEMA: {
        const newSchema: ContentType = {
          uid: action.uid as Internal.UID.ContentType,
          isTemporary: true,
          schema: {
            ...action.data,
            attributes: [],
          },
        };

        draftState.contentTypes[action.uid as string] = newSchema;

        break;
      }
      case actions.EDIT_ATTRIBUTE: {
        const {
          attributeToSet: { name, ...rest },
          forTarget,
          targetUid,
          initialAttribute,
        } = action;

        const initialAttributeName = initialAttribute.name;
        const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)
          ? [forTarget]
          : [forTarget, targetUid];

        const initialAttributeIndex = findAttributeIndex(
          get(state, ['modifiedData', ...pathToDataToEdit]),
          initialAttributeName
        );

        const isEditingRelation = rest.type === 'relation';

        if (!isEditingRelation) {
          set(
            draftState,
            ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes', initialAttributeIndex],
            action.attributeToSet
          );

          break;
        }

        const updatedAttributes: AttributeType[] = get(state, [
          'modifiedData',
          ...pathToDataToEdit,
          'schema',
          'attributes',
        ]).slice();

        // First create the current relation attribute updated
        const toSet = {
          name,
          relation: rest.relation,
          target: rest.target,
          targetAttribute: rest.targetAttribute,
          type: 'relation',
        } as AttributeType;

        if (rest.private) {
          toSet.private = rest.private;
        }

        if (rest.pluginOptions) {
          toSet.pluginOptions = rest.pluginOptions;
        }

        const currentAttributeIndex = updatedAttributes.findIndex((value: AttributeType) => {
          return value.name !== undefined && value.name === initialAttribute.name;
        });

        // First set it in the updatedAttributes
        if (currentAttributeIndex !== -1) {
          updatedAttributes.splice(currentAttributeIndex, 1, toSet);
        }

        let oppositeAttributeNameToRemove: string | null = null;
        let oppositeAttributeNameToUpdate: string | null = null;
        let oppositeAttributeToCreate: AttributeType | null = null;
        let initialOppositeAttribute = null;

        const currentUid = get(state, ['modifiedData', ...pathToDataToEdit, 'uid']);
        const didChangeTargetRelation = initialAttribute.target !== rest.target;
        const didCreateInternalRelation = rest.target === currentUid;
        const relationType = getRelationType(rest.relation, rest.targetAttribute);
        const initialRelationType = getRelationType(
          initialAttribute.relation,
          initialAttribute.targetAttribute
        );
        const hadInternalRelation = initialAttribute.target === currentUid;
        const didChangeRelationType = initialRelationType !== relationType;
        const shouldRemoveOppositeAttributeBecauseOfTargetChange =
          didChangeTargetRelation &&
          !didCreateInternalRelation &&
          hadInternalRelation &&
          isEditingRelation;
        const shouldRemoveOppositeAttributeBecauseOfRelationTypeChange =
          didChangeRelationType &&
          hadInternalRelation &&
          ['oneWay', 'manyWay'].includes(relationType!) &&
          isEditingRelation;
        const shouldUpdateOppositeAttributeBecauseOfRelationTypeChange =
          !ONE_SIDE_RELATIONS.includes(initialRelationType!) &&
          !ONE_SIDE_RELATIONS.includes(relationType!) &&
          hadInternalRelation &&
          didCreateInternalRelation &&
          isEditingRelation;
        const shouldCreateOppositeAttributeBecauseOfRelationTypeChange =
          ONE_SIDE_RELATIONS.includes(initialRelationType!) &&
          !ONE_SIDE_RELATIONS.includes(relationType!) &&
          hadInternalRelation &&
          didCreateInternalRelation &&
          isEditingRelation;
        const shouldCreateOppositeAttributeBecauseOfTargetChange =
          didChangeTargetRelation &&
          didCreateInternalRelation &&
          !ONE_SIDE_RELATIONS.includes(relationType!);

        // Store opposite attribute name to remove at the end of the loop
        if (
          shouldRemoveOppositeAttributeBecauseOfTargetChange ||
          shouldRemoveOppositeAttributeBecauseOfRelationTypeChange
        ) {
          oppositeAttributeNameToRemove = initialAttribute.targetAttribute;
        }

        // In case of oneWay or manyWay relation there isn't an opposite attribute
        if (oppositeAttributeNameToRemove) {
          const indexToRemove = updatedAttributes.findIndex(
            (value) => value.name === oppositeAttributeNameToRemove
          );

          updatedAttributes.splice(indexToRemove, 1);
        }

        // In order to preserve plugin options need to get the initial opposite attribute settings
        if (!shouldRemoveOppositeAttributeBecauseOfTargetChange) {
          const initialTargetContentType = get(state, [
            'initialContentTypes',
            initialAttribute.target,
          ]);

          if (initialTargetContentType) {
            const oppositeAttributeIndex = findAttributeIndex(
              initialTargetContentType,
              initialAttribute.targetAttribute
            );

            initialOppositeAttribute = get(state, [
              'initialContentTypes',
              initialAttribute.target,
              'schema',
              'attributes',
              oppositeAttributeIndex,
            ]);
          }
        }

        // Create the opposite attribute
        if (
          shouldCreateOppositeAttributeBecauseOfRelationTypeChange ||
          shouldCreateOppositeAttributeBecauseOfTargetChange
        ) {
          oppositeAttributeToCreate = {
            name: rest.targetAttribute,
            relation: getOppositeRelation(relationType),
            target: rest.target,
            targetAttribute: name,
            type: 'relation',
          } as AttributeType;

          if (rest.private) {
            oppositeAttributeToCreate.private = rest.private;
          }

          if (initialOppositeAttribute && initialOppositeAttribute.pluginOptions) {
            oppositeAttributeToCreate.pluginOptions = initialOppositeAttribute.pluginOptions;
          }

          const indexOfInitialAttribute = updatedAttributes.findIndex(
            ({ name }) => name === initialAttribute.name
          );
          const indexOfUpdatedAttribute = updatedAttributes.findIndex(
            ({ name: attrName }) => name === attrName
          );

          const indexToInsert =
            (indexOfInitialAttribute === -1 ? indexOfUpdatedAttribute : indexOfInitialAttribute) +
            1;

          updatedAttributes.splice(indexToInsert, 0, oppositeAttributeToCreate);
        }

        if (shouldUpdateOppositeAttributeBecauseOfRelationTypeChange) {
          oppositeAttributeNameToUpdate = initialAttribute.targetAttribute;

          oppositeAttributeToCreate = {
            name: rest.targetAttribute,
            relation: getOppositeRelation(relationType),
            target: rest.target,
            targetAttribute: name,
            type: 'relation',
          } as AttributeType;

          if (rest.private) {
            oppositeAttributeToCreate.private = rest.private;
          }

          if (initialOppositeAttribute && initialOppositeAttribute.pluginOptions) {
            oppositeAttributeToCreate.pluginOptions = initialOppositeAttribute.pluginOptions;
          }

          if (oppositeAttributeNameToUpdate) {
            const indexToUpdate = updatedAttributes.findIndex(
              ({ name }) => name === oppositeAttributeNameToUpdate
            );

            updatedAttributes.splice(indexToUpdate, 1, oppositeAttributeToCreate);
          }
        }

        set(
          draftState,
          ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes'],
          updatedAttributes
        );

        break;
      }
      case actions.EDIT_CUSTOM_FIELD_ATTRIBUTE: {
        const { forTarget, targetUid, initialAttribute, attributeToSet } = action;

        const initialAttributeName = initialAttribute.name;
        const pathToDataToEdit = ['component', 'contentType'].includes(forTarget)
          ? [forTarget]
          : [forTarget, targetUid];

        const initialAttributeIndex = findAttributeIndex(
          get(state, ['modifiedData', ...pathToDataToEdit]),
          initialAttributeName
        );

        set(
          draftState,
          ['modifiedData', ...pathToDataToEdit, 'schema', 'attributes', initialAttributeIndex],
          attributeToSet
        );

        break;
      }
      case actions.GET_DATA_SUCCEEDED: {
        draftState.components = action.components;
        draftState.initialComponents = action.components;
        draftState.initialContentTypes = action.contentTypes;
        draftState.contentTypes = action.contentTypes;
        draftState.reservedNames = action.reservedNames;
        draftState.isLoading = false;
        break;
      }
      case actions.UPDATE_INITIAL_STATE: {
        draftState.initialData = draftState.modifiedData;

        break;
      }
      case actions.DELETE_NOT_SAVED_TYPE: {
        // Doing so will also reset the modified and the initial data
        draftState.contentTypes = state.initialContentTypes;
        draftState.components = state.initialComponents;

        break;
      }
      case actions.RELOAD_PLUGIN: {
        return initialState;
      }
      case actions.REMOVE_COMPONENT_FROM_DYNAMIC_ZONE: {
        const dzAttributeIndex = findAttributeIndex(state.modifiedData.contentType, action.dzName);
        draftState.modifiedData.contentType.schema.attributes[dzAttributeIndex].components.splice(
          action.componentToRemoveIndex,
          1
        );

        break;
      }
      case actions.REMOVE_FIELD: {
        const { mainDataKey, attributeToRemoveName } = action;
        const pathToAttributes = ['modifiedData', mainDataKey, 'schema', 'attributes'];
        const attributeToRemoveIndex = findAttributeIndex(
          state.modifiedData[mainDataKey],
          attributeToRemoveName
        );

        const pathToAttributeToRemove = [...pathToAttributes, attributeToRemoveIndex];
        const attributeToRemoveData = get(state, pathToAttributeToRemove);
        const isRemovingRelationAttribute = attributeToRemoveData.type === 'relation';
        // Only content types can have relations with themselves since
        // components can only have oneWay or manyWay relations
        const canTheAttributeToRemoveHaveARelationWithItself = mainDataKey === 'contentType';

        if (isRemovingRelationAttribute && canTheAttributeToRemoveHaveARelationWithItself) {
          const { target, relation, targetAttribute } = attributeToRemoveData;
          const relationType = getRelationType(relation, targetAttribute);

          const uid = state.modifiedData.contentType?.uid;
          const shouldRemoveOppositeAttribute =
            target === uid && !ONE_SIDE_RELATIONS.includes(relationType!);

          if (shouldRemoveOppositeAttribute) {
            const attributes: AttributeType[] =
              state.modifiedData[mainDataKey]?.schema.attributes.slice();
            const nextAttributes = attributes.filter((attribute) => {
              if (attribute.name === attributeToRemoveName) {
                return false;
              }

              if (attribute.target === uid && attribute.targetAttribute === attributeToRemoveName) {
                return false;
              }

              return true;
            });

            draftState.modifiedData[mainDataKey].schema.attributes = nextAttributes;

            break;
          }
        }

        // Find all uid fields that have the targetField set to the field we are removing

        const uidFieldsToUpdate: string[] = state.modifiedData[
          mainDataKey
        ]!.schema.attributes.slice().reduce((acc: string[], current: AttributeType) => {
          if (current.type !== 'uid') {
            return acc;
          }

          if (current.targetField !== attributeToRemoveName) {
            return acc;
          }

          acc.push(current.name as string);

          return acc;
        }, []);

        uidFieldsToUpdate.forEach((fieldName) => {
          const fieldIndex = findAttributeIndex(state.modifiedData[mainDataKey], fieldName);

          delete draftState.modifiedData[mainDataKey]?.schema.attributes[fieldIndex].targetField;
        });

        draftState.modifiedData[mainDataKey]?.schema.attributes.splice(attributeToRemoveIndex, 1);

        break;
      }
      case actions.REMOVE_FIELD_FROM_DISPLAYED_COMPONENT: {
        const { attributeToRemoveName, componentUid } = action;

        const attributeToRemoveIndex = findAttributeIndex(
          state.modifiedData.components?.[componentUid],
          attributeToRemoveName
        );

        draftState.modifiedData.components?.[componentUid]?.schema?.attributes?.splice(
          attributeToRemoveIndex,
          1
        );

        break;
      }
      case actions.SET_MODIFIED_DATA: {
        draftState.isLoadingForDataToBeSet = false;
        draftState.initialData = action.schemaToSet;
        draftState.modifiedData = action.schemaToSet;

        // Reset the state with the initial data
        // All created components and content types will be lost
        if (!action.hasJustCreatedSchema) {
          draftState.components = state.initialComponents;
          draftState.contentTypes = state.initialContentTypes;
        }

        break;
      }
      case actions.UPDATE_SCHEMA: {
        const {
          data: { displayName, category, icon, kind },
          schemaType,
          uid,
        } = action;

        draftState.modifiedData[schemaType].schema.displayName = displayName;

        if (action.schemaType === 'component') {
          draftState.modifiedData.component.category = category;
          draftState.modifiedData.component.schema.icon = icon;
          const addedComponent = current(draftState.modifiedData.component);
          draftState.components[uid as string] = addedComponent;

          break;
        }

        draftState.modifiedData.contentType.schema.kind = kind;

        break;
      }
      default:
        return draftState;
    }
  });

export { initialState, reducer };
</file>

<file path="admin/src/components/DataManagerProvider/selectors.ts">
import { createSelector } from '@reduxjs/toolkit';

import { pluginId } from '../../pluginId';

import { initialState } from './reducer';

import type { DataManagerStateType } from '../../types';

/**
 * Direct selector to the dataManagerProvider state domain
 */
const dataManagerProviderDomain = () => (state: DataManagerStateType) =>
  state[`${pluginId}_dataManagerProvider`] || initialState;

/**
 * Other specific selectors
 */

/**
 * Default selector used by dataManagerProvider
 */

const makeSelectDataManagerProvider = () =>
  createSelector(dataManagerProviderDomain(), (substate) => {
    return substate;
  });

export { makeSelectDataManagerProvider, dataManagerProviderDomain };
</file>

<file path="admin/src/components/FormModal/attributes/validation/common.ts">
import { translatedErrors as errorsTrads } from '@strapi/admin/strapi-admin';
import { snakeCase } from 'lodash/fp';
import toNumber from 'lodash/toNumber';
import * as yup from 'yup';

import { getTrad } from '../../../../utils/getTrad';

const NAME_REGEX = /^[A-Za-z][_0-9A-Za-z]*$/;

const alreadyUsedAttributeNames = (
  usedNames: Array<string>
): yup.TestConfig<string | undefined, Record<string, unknown>> => {
  return {
    name: 'attributeNameAlreadyUsed',
    message: errorsTrads.unique.id,
    test(value: string | undefined) {
      if (!value) {
        return false;
      }
      const snakeCaseKey = snakeCase(value);

      return !usedNames.some((existingKey) => {
        return snakeCase(existingKey) === snakeCaseKey;
      });
    },
  };
};

const getUsedContentTypeAttributeNames = (
  ctShema: any,
  isEdition: boolean,
  attributeNameToEdit: string
) => {
  const attributes = ctShema?.schema?.attributes ?? {};

  return Object.keys(attributes).filter((attr) => {
    if (isEdition) {
      return attr !== attributeNameToEdit;
    }

    return true;
  });
};

const isNameAllowed = (
  reservedNames: Array<string>
): yup.TestConfig<string | undefined, Record<string, unknown>> => {
  return {
    name: 'forbiddenAttributeName',
    message: getTrad('error.attributeName.reserved-name'),
    test(value: string | undefined) {
      if (!value) {
        return false;
      }
      const snakeCaseKey = snakeCase(value);

      return !reservedNames.some((existingKey) => {
        return snakeCase(existingKey) === snakeCaseKey;
      });
    },
  };
};

const validators = {
  default: () => yup.string().nullable(),
  max: () => yup.number().integer().nullable(),
  min: () =>
    yup
      .number()
      .integer()
      .when('max', (max, schema) => {
        if (max) {
          return schema.max(max, getTrad('error.validation.minSupMax'));
        }

        return schema;
      })
      .nullable(),
  maxLength: () => yup.number().integer().positive(getTrad('error.validation.positive')).nullable(),
  minLength: () =>
    yup
      .number()
      .integer()
      .min(1)
      .when('maxLength', (maxLength, schema) => {
        if (maxLength) {
          return schema.max(maxLength, getTrad('error.validation.minSupMax'));
        }

        return schema;
      })
      .nullable(),
  name(usedNames: Array<string>, reservedNames: Array<string>) {
    return yup
      .string()
      .test(alreadyUsedAttributeNames(usedNames))
      .test(isNameAllowed(reservedNames))
      .matches(NAME_REGEX, errorsTrads.regex.id)
      .required(errorsTrads.required.id);
  },
  required: () => yup.boolean(),
  type: () => yup.string().required(errorsTrads.required.id),
  unique: () => yup.boolean().nullable(),
};

const createTextShape = (usedAttributeNames: Array<string>, reservedNames: Array<string>) => {
  const shape = {
    name: validators.name(usedAttributeNames, reservedNames),
    type: validators.type(),
    default: validators.default(),
    unique: validators.unique(),
    required: validators.required(),
    maxLength: validators.maxLength(),
    minLength: validators.minLength(),
    regex: yup
      .string()
      .test({
        name: 'isValidRegExpPattern',
        message: getTrad('error.validation.regex'),
        test(value) {
          try {
            return new RegExp(value || '') !== null;
          } catch (e) {
            return false;
          }
        },
      })
      .nullable(),
  };

  return shape;
};

type GenericIsMinSuperiorThanMax<T extends (string | null) | number> = yup.TestConfig<
  T | undefined,
  Record<string, unknown>
>;

const isMinSuperiorThanMax = <
  T extends (string | null) | number,
>(): GenericIsMinSuperiorThanMax<T> => ({
  name: 'isMinSuperiorThanMax',
  message: getTrad('error.validation.minSupMax'),
  test(min: T | undefined) {
    if (!min) {
      return true;
    }

    const { max } = (this as any).parent;

    if (!max) {
      return true;
    }

    if (Number.isNaN(toNumber(min))) {
      return true;
    }

    return toNumber(max) >= toNumber(min);
  },
});

export {
  alreadyUsedAttributeNames,
  createTextShape,
  getUsedContentTypeAttributeNames,
  isMinSuperiorThanMax,
  isNameAllowed,
  NAME_REGEX,
  validators,
};
</file>

<file path="admin/src/components/FormModal/attributes/advancedForm.ts">
import { getTrad } from '../../../utils/getTrad';
import { componentForm } from '../component/componentForm';

import { attributeOptions } from './attributeOptions';

type DataType = 'biginteger' | 'string' | 'integer' | 'float' | 'decimal';

export const advancedForm = {
  blocks() {
    return {
      sections: [
        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [attributeOptions.required, attributeOptions.private],
        },
      ],
    };
  },
  boolean() {
    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            {
              autoFocus: true,
              type: 'select-default-boolean',
              intlLabel: {
                id: getTrad('form.attribute.settings.default'),
                defaultMessage: 'Default value',
              },
              name: 'default',
              options: [
                {
                  value: 'true',
                  key: 'true',
                  metadatas: { intlLabel: { id: 'true', defaultMessage: 'true' } },
                },
                {
                  value: '',
                  key: 'null',
                  metadatas: { intlLabel: { id: 'null', defaultMessage: 'null' } },
                },
                {
                  value: 'false',
                  key: 'false',
                  metadatas: { intlLabel: { id: 'false', defaultMessage: 'false' } },
                },
              ],
            },
          ],
        },
        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [attributeOptions.required, attributeOptions.private],
        },
      ],
    };
  },
  component({ repeatable }: { repeatable: boolean }, step: string) {
    if (step === '1') {
      return { sections: componentForm.advanced() };
    }

    if (repeatable) {
      return {
        sections: [
          {
            sectionTitle: {
              id: 'global.settings',
              defaultMessage: 'Settings',
            },
            items: [
              attributeOptions.required,
              attributeOptions.private,
              attributeOptions.max,
              attributeOptions.min,
            ],
          },
        ],
      };
    }

    return {
      sections: [
        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [attributeOptions.required, attributeOptions.private],
        },
      ],
    };
  },
  date({ type }: { type: string }) {
    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            {
              ...attributeOptions.default,
              type: type || 'date',
              value: null,
              withDefaultValue: false,
              disabled: !type,
              autoFocus: false,
            },
          ],
        },
        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [attributeOptions.required, attributeOptions.unique, attributeOptions.private],
        },
      ],
    };
  },
  dynamiczone() {
    return {
      sections: [
        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [attributeOptions.required, attributeOptions.max, attributeOptions.min],
        },
      ],
    };
  },
  email() {
    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            {
              ...attributeOptions.default,
              type: 'email',
            },
          ],
        },

        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [
            attributeOptions.required,
            attributeOptions.unique,
            attributeOptions.maxLength,
            attributeOptions.minLength,
            attributeOptions.private,
          ],
        },
      ],
    };
  },
  enumeration(data: { enum: Array<string> }) {
    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            {
              name: 'default',
              type: 'select',
              intlLabel: {
                id: getTrad('form.attribute.settings.default'),
                defaultMessage: 'Default value',
              },
              validations: {},
              options: [
                {
                  key: '__null_reset_value__',
                  value: '',
                  metadatas: {
                    intlLabel: {
                      id: 'components.InputSelect.option.placeholder',
                      defaultMessage: 'Choose here',
                    },
                  },
                },
                ...(data.enum || [])
                  .filter((value, index) => data.enum.indexOf(value) === index && value)
                  .map((value) => {
                    return {
                      key: value,
                      value,
                      metadatas: {
                        intlLabel: { id: `${value}.no-override`, defaultMessage: value },
                      },
                    };
                  }),
              ],
            },
            {
              intlLabel: {
                id: getTrad('form.attribute.item.enumeration.graphql'),
                defaultMessage: 'Name override for GraphQL',
              },
              name: 'enumName',
              type: 'text',
              validations: {},
              description: {
                id: getTrad('form.attribute.item.enumeration.graphql.description'),
                defaultMessage: 'Allows you to override the default generated name for GraphQL',
              },
            },
          ],
        },

        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [attributeOptions.required, attributeOptions.private],
        },
      ],
    };
  },
  json() {
    return {
      sections: [
        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [attributeOptions.required, attributeOptions.private],
        },
      ],
    };
  },
  media() {
    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            {
              intlLabel: {
                id: getTrad('form.attribute.media.allowed-types'),
                defaultMessage: 'Select allowed types of media',
              },
              name: 'allowedTypes',
              type: 'allowed-types-select',
              size: 7,
              value: '',
              validations: {},
            },
          ],
        },
        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [attributeOptions.required, attributeOptions.private],
        },
      ],
    };
  },
  number(data: { type: DataType }) {
    const inputStep = data.type === 'decimal' || data.type === 'float' ? 'any' : 1;

    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            {
              autoFocus: true,
              name: 'default',
              type: data.type === 'biginteger' ? 'text' : 'number',
              step: inputStep,
              intlLabel: {
                id: getTrad('form.attribute.settings.default'),
                defaultMessage: 'Default value',
              },
              validations: {},
            },
          ],
        },
        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [
            attributeOptions.required,
            attributeOptions.unique,
            attributeOptions.max,
            attributeOptions.min,
            attributeOptions.private,
          ],
        },
      ],
    };
  },
  password() {
    return {
      sections: [
        { sectionTitle: null, items: [attributeOptions.default] },

        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [
            attributeOptions.required,
            attributeOptions.maxLength,
            attributeOptions.minLength,
            attributeOptions.private,
          ],
        },
      ],
    };
  },
  relation() {
    return {
      sections: [
        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [attributeOptions.private],
        },
      ],
    };
  },
  richtext() {
    return {
      sections: [
        { sectionTitle: null, items: [attributeOptions.default] },
        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [
            attributeOptions.required,
            attributeOptions.maxLength,
            attributeOptions.minLength,
            attributeOptions.private,
          ],
        },
      ],
    };
  },
  text() {
    return {
      sections: [
        { sectionTitle: null, items: [attributeOptions.default, attributeOptions.regex] },

        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [
            attributeOptions.required,
            attributeOptions.unique,
            attributeOptions.maxLength,
            attributeOptions.minLength,
            attributeOptions.private,
          ],
        },
      ],
    };
  },
  uid(data: { targetField: string }) {
    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            { ...attributeOptions.default, disabled: Boolean(data.targetField), type: 'text' },
          ],
        },

        {
          sectionTitle: {
            id: 'global.settings',
            defaultMessage: 'Settings',
          },
          items: [
            attributeOptions.required,
            attributeOptions.maxLength,
            attributeOptions.minLength,
            attributeOptions.private,
          ],
        },
      ],
    };
  },
};
</file>

<file path="admin/src/components/FormModal/attributes/attributeOptions.ts">
import { getTrad } from '../../../utils/getTrad';

export const attributeOptions = {
  default: {
    name: 'default',
    type: 'text',
    intlLabel: {
      id: getTrad('form.attribute.settings.default'),
      defaultMessage: 'Default value',
    },
  },
  max: {
    name: 'max',
    type: 'checkbox-with-number-field',
    intlLabel: {
      id: getTrad('form.attribute.item.maximum'),
      defaultMessage: 'Maximum value',
    },
  },
  maxLength: {
    name: 'maxLength',
    type: 'checkbox-with-number-field',
    intlLabel: {
      id: getTrad('form.attribute.item.maximumLength'),
      defaultMessage: 'Maximum length',
    },
  },
  min: {
    name: 'min',
    type: 'checkbox-with-number-field',
    intlLabel: {
      id: getTrad('form.attribute.item.minimum'),
      defaultMessage: 'Minimum value',
    },
  },
  minLength: {
    name: 'minLength',
    type: 'checkbox-with-number-field',
    intlLabel: {
      id: getTrad('form.attribute.item.minimumLength'),
      defaultMessage: 'Minimum length',
    },
  },
  private: {
    name: 'private',
    type: 'checkbox',
    intlLabel: {
      id: getTrad('form.attribute.item.privateField'),
      defaultMessage: 'Private field',
    },
    description: {
      id: getTrad('form.attribute.item.privateField.description'),
      defaultMessage: 'This field will not show up in the API response',
    },
  },
  regex: {
    intlLabel: {
      id: getTrad('form.attribute.item.text.regex'),
      defaultMessage: 'RegExp pattern',
    },
    name: 'regex',
    type: 'text',
    description: {
      id: getTrad('form.attribute.item.text.regex.description'),
      defaultMessage: 'The text of the regular expression',
    },
  },
  required: {
    name: 'required',
    type: 'checkbox',
    intlLabel: {
      id: getTrad('form.attribute.item.requiredField'),
      defaultMessage: 'Required field',
    },
    description: {
      id: getTrad('form.attribute.item.requiredField.description'),
      defaultMessage: "You won't be able to create an entry if this field is empty",
    },
  },
  unique: {
    name: 'unique',
    type: 'checkbox',
    intlLabel: {
      id: getTrad('form.attribute.item.uniqueField'),
      defaultMessage: 'Unique field',
    },
    description: {
      id: getTrad('form.attribute.item.uniqueField.description'),
      defaultMessage:
        "You won't be able to create an entry if there is an existing entry with identical content",
    },
  },
};
</file>

<file path="admin/src/components/FormModal/attributes/baseForm.ts">
import { getTrad } from '../../../utils/getTrad';
import { componentField } from '../component/componentField';
import { componentForm } from '../component/componentForm';

import { nameField } from './nameField';

export const baseForm = {
  component(data: { createComponent: boolean }, step: string) {
    if (step === '1') {
      const itemsToConcat =
        data.createComponent === true ? componentForm.base('componentToCreate.') : [];

      return {
        sections: [{ sectionTitle: null, items: [componentField] }, ...itemsToConcat],
      };
    }

    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            nameField,
            {
              name: 'component',
              type: 'select-component',
              intlLabel: {
                id: getTrad('modalForm.attributes.select-component'),
                defaultMessage: 'Select a component',
              },
              isMultiple: false,
            },
          ],
        },
        {
          sectionTitle: null,
          items: [
            {
              intlLabel: {
                id: 'global.type',
                defaultMessage: 'Type',
              },
              name: 'repeatable',
              type: 'boolean-radio-group',
              size: 12,
              radios: [
                {
                  title: {
                    id: getTrad('form.attribute.component.option.repeatable'),
                    defaultMessage: 'Repeatable component',
                  },
                  description: {
                    id: getTrad('form.attribute.component.option.repeatable.description'),
                    defaultMessage:
                      'Best for multiple instances (array) of ingredients, meta tags, etc..',
                  },
                  value: true,
                },
                {
                  title: {
                    id: getTrad('form.attribute.component.option.single'),
                    defaultMessage: 'Single component',
                  },
                  description: {
                    id: getTrad('form.attribute.component.option.single.description'),
                    defaultMessage:
                      'Best for grouping fields like full address, main information, etc...',
                  },
                  value: false,
                },
              ],
            },
          ],
        },
      ],
    };
  },
  date() {
    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            nameField,
            {
              intlLabel: {
                id: 'global.type',
                defaultMessage: 'Type',
              },
              name: 'type',
              type: 'select-date',
              options: [
                {
                  key: '__null_reset_value__',
                  value: '',
                  metadatas: {
                    intlLabel: {
                      id: 'components.InputSelect.option.placeholder',
                      defaultMessage: 'Choose here',
                    },
                    hidden: true,
                  },
                },
                {
                  key: 'date',
                  value: 'date',
                  metadatas: {
                    intlLabel: {
                      id: getTrad('form.attribute.item.date.type.date'),
                      defaultMessage: 'date (ex: 01/01/{currentYear})',
                      values: { currentYear: new Date().getFullYear() },
                    },
                  },
                },
                {
                  key: 'datetime',
                  value: 'datetime',
                  metadatas: {
                    intlLabel: {
                      id: getTrad('form.attribute.item.date.type.datetime'),
                      defaultMessage: 'datetime (ex: 01/01/{currentYear} 00:00 AM)',
                      values: { currentYear: new Date().getFullYear() },
                    },
                  },
                },
                {
                  key: 'time',
                  value: 'time',
                  metadatas: {
                    intlLabel: {
                      id: getTrad('form.attribute.item.date.type.time'),
                      defaultMessage: 'time (ex: 00:00 AM)',
                    },
                  },
                },
              ],
            },
          ],
        },
      ],
    };
  },
  enumeration() {
    return {
      sections: [
        { sectionTitle: null, items: [nameField] },
        {
          sectionTitle: null,
          items: [
            {
              name: 'enum',
              type: 'textarea-enum',
              size: 6,
              intlLabel: {
                id: getTrad('form.attribute.item.enumeration.rules'),
                defaultMessage: 'Values (one line per value)',
              },
              placeholder: {
                id: getTrad('form.attribute.item.enumeration.placeholder'),
                defaultMessage: 'Ex:\nmorning\nnoon\nevening',
              },
              validations: {
                required: true,
              },
            },
          ],
        },
      ],
    };
  },
  media() {
    return {
      sections: [
        { sectionTitle: null, items: [nameField] },
        {
          sectionTitle: null,
          items: [
            {
              intlLabel: {
                id: 'global.type',
                defaultMessage: 'Type',
              },
              name: 'multiple',
              size: 12,
              type: 'boolean-radio-group',
              radios: [
                {
                  title: {
                    id: getTrad('form.attribute.media.option.multiple'),
                    defaultMessage: 'Multiple media',
                  },
                  description: {
                    id: getTrad('form.attribute.media.option.multiple.description'),
                    defaultMessage: 'Best for sliders, carousels or multiple files download',
                  },
                  value: true,
                },
                {
                  title: {
                    id: getTrad('form.attribute.media.option.single'),
                    defaultMessage: 'Single media',
                  },
                  description: {
                    id: getTrad('form.attribute.media.option.single.description'),
                    defaultMessage: 'Best for avatar, profile picture or cover',
                  },
                  value: false,
                },
              ],
            },
          ],
        },
      ],
    };
  },
  number() {
    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            nameField,
            {
              intlLabel: {
                id: getTrad('form.attribute.item.number.type'),
                defaultMessage: 'Number format',
              },
              name: 'type',
              type: 'select-number',
              options: [
                {
                  key: '__null_reset_value__',
                  value: '',
                  metadatas: {
                    intlLabel: {
                      id: 'components.InputSelect.option.placeholder',
                      defaultMessage: 'Choose here',
                    },
                    hidden: true,
                  },
                },
                {
                  key: 'integer',
                  value: 'integer',
                  metadatas: {
                    intlLabel: {
                      id: getTrad('form.attribute.item.number.type.integer'),
                      defaultMessage: 'integer (ex: 10)',
                    },
                  },
                },
                {
                  key: 'biginteger',
                  value: 'biginteger',
                  metadatas: {
                    intlLabel: {
                      id: getTrad('form.attribute.item.number.type.biginteger'),
                      defaultMessage: 'biginteger (ex: 123456789)',
                    },
                  },
                },
                {
                  key: 'decimal',
                  value: 'decimal',
                  metadatas: {
                    intlLabel: {
                      id: getTrad('form.attribute.item.number.type.decimal'),
                      defaultMessage: 'decimal (ex: 2.22)',
                    },
                  },
                },
                {
                  key: 'float',
                  value: 'float',
                  metadatas: {
                    intlLabel: {
                      id: getTrad('form.attribute.item.number.type.float'),
                      defaultMessage: 'decimal (ex: 3.3333333)',
                    },
                  },
                },
              ],
            },
          ],
        },
      ],
    };
  },
  relation() {
    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            {
              intlLabel: { id: 'FIXME', defaultMessage: 'FIXME' },
              name: 'relation',
              size: 12,
              type: 'relation',
            },
          ],
        },
      ],
    };
  },
  string() {
    return {
      sections: [
        { sectionTitle: null, items: [nameField] },
        {
          sectionTitle: null,
          items: [
            {
              intlLabel: {
                id: 'global.type',
                defaultMessage: 'Type',
              },
              name: 'type',
              size: 12,
              type: 'radio-group',
              radios: [
                {
                  title: {
                    id: getTrad('form.attribute.text.option.short-text'),
                    defaultMessage: 'Sort text',
                  },
                  description: {
                    id: getTrad('form.attribute.text.option.short-text.description'),
                    defaultMessage:
                      'Best for titles, names, links (URL). It also enables exact search on the field.',
                  },
                  value: 'string',
                },
                {
                  title: {
                    id: getTrad('form.attribute.text.option.long-text'),
                    defaultMessage: 'Long text',
                  },
                  description: {
                    id: getTrad('form.attribute.text.option.long-text.description'),
                    defaultMessage: 'Best for descriptions, biography. Exact search is disabled.',
                  },
                  value: 'text',
                },
              ],
            },
          ],
        },
      ],
    };
  },
  text() {
    return {
      sections: [
        { sectionTitle: null, items: [nameField] },
        {
          sectionTitle: null,
          items: [
            {
              intlLabel: {
                id: 'global.type',
                defaultMessage: 'Type',
              },
              name: 'type',
              size: 12,
              type: 'radio-group',
              radios: [
                {
                  title: {
                    id: getTrad('form.attribute.text.option.short-text'),
                    defaultMessage: 'Sort text',
                  },
                  description: {
                    id: getTrad('form.attribute.text.option.short-text.description'),
                    defaultMessage:
                      'Best for titles, names, links (URL). It also enables exact search on the field.',
                  },
                  value: 'string',
                },
                {
                  title: {
                    id: getTrad('form.attribute.text.option.long-text'),
                    defaultMessage: 'Long text',
                  },
                  description: {
                    id: getTrad('form.attribute.text.option.long-text.description'),
                    defaultMessage: 'Best for descriptions, biography. Exact search is disabled.',
                  },
                  value: 'text',
                },
              ],
            },
          ],
        },
      ],
    };
  },
  uid(_data: unknown, step: string, attributes: Array<{ type: string; name: string }>) {
    const options = attributes
      .filter(({ type }) => ['string', 'text'].includes(type))
      .map(({ name }) => ({
        key: name,
        value: name,
        metadatas: {
          intlLabel: { id: `${name}.no-override`, defaultMessage: name },
        },
      }));

    return {
      sections: [
        {
          sectionTitle: null,
          items: [
            {
              ...nameField,
              placeholder: {
                id: getTrad('modalForm.attribute.form.base.name.placeholder'),
                defaultMessage: 'e.g. slug, seoUrl, canonicalUrl',
              },
            },
            {
              intlLabel: {
                id: getTrad('modalForm.attribute.target-field'),
                defaultMessage: 'Attached field',
              },
              name: 'targetField',
              type: 'select',
              options: [
                {
                  key: '__null_reset_value__',
                  value: '',
                  metadatas: { intlLabel: { id: 'global.none', defaultMessage: 'None' } },
                },
                ...options,
              ],
            },
          ],
        },
      ],
    };
  },
};
</file>

<file path="admin/src/components/FormModal/attributes/commonBaseForm.ts">
import { nameField } from './nameField';

export const commonBaseForm = {
  sections: [{ sectionTitle: null, items: [nameField] }],
};
</file>

<file path="admin/src/components/FormModal/attributes/form.ts">
import { advancedForm } from './advancedForm';
import { baseForm } from './baseForm';

export const attributesForm = {
  advanced: advancedForm,
  base: baseForm,
};
</file>

<file path="admin/src/components/FormModal/attributes/nameField.ts">
import { getTrad } from '../../../utils/getTrad';

export const nameField = {
  name: 'name',
  type: 'text',
  intlLabel: {
    id: 'global.name',
    defaultMessage: 'Name',
  },
  description: {
    id: getTrad('modalForm.attribute.form.base.name.description'),
    defaultMessage: 'No space is allowed for the name of the attribute',
  },
  // validations: {
  //   required: true,
  // },
};
</file>

<file path="admin/src/components/FormModal/attributes/types.ts">
import { translatedErrors as errorsTrads } from '@strapi/admin/strapi-admin';
import uniq from 'lodash/uniq';
import * as yup from 'yup';

import { getRelationType } from '../../../utils/getRelationType';
import { getTrad } from '../../../utils/getTrad';
import { toRegressedEnumValue } from '../../../utils/toRegressedEnumValue';

import {
  alreadyUsedAttributeNames,
  createTextShape,
  isMinSuperiorThanMax,
  isNameAllowed,
  NAME_REGEX,
  validators,
} from './validation/common';

import type { Schema } from '@strapi/types';

export const attributeTypes = {
  date(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
    };

    return yup.object(shape);
  },
  datetime(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
    };

    return yup.object(shape);
  },
  time(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
    };

    return yup.object(shape);
  },
  default(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
    };

    return yup.object(shape);
  },
  biginteger(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      default: yup
        .string()
        .nullable()
        .matches(/^-?\d*$/),
      unique: validators.unique(),
      required: validators.required(),
      max: yup
        .string()
        .nullable()
        .matches(/^-?\d*$/, errorsTrads.regex.id),
      min: yup
        .string()
        .nullable()
        .test(isMinSuperiorThanMax<string | null>())
        .matches(/^-?\d*$/, errorsTrads.regex.id),
    };

    return yup.object(shape);
  },
  boolean(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      default: yup.boolean().nullable(),
      required: validators.required(),
      unique: validators.unique(),
    };

    return yup.object(shape);
  },
  component(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      required: validators.required(),
      max: validators.max(),
      min: validators.min(),
      component: yup.string().required(errorsTrads.required.id),
    };

    return yup.object(shape);
  },
  decimal(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      default: yup.number(),
      required: validators.required(),
      max: yup.number(),
      min: yup.number().test(isMinSuperiorThanMax<number>()),
    };

    return yup.object(shape);
  },
  dynamiczone(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      required: validators.required(),
      max: validators.max(),
      min: validators.min(),
    };

    return yup.object(shape);
  },
  email(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      default: yup.string().email().nullable(),
      unique: validators.unique(),
      required: validators.required(),
      maxLength: validators.maxLength(),
      minLength: validators.minLength(),
    };

    return yup.object(shape);
  },
  enumeration(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    /**
     * For enumerations the least common denomiator is GraphQL, where
     * values needs to match the secure name regex:
     * GraphQL Spec https://spec.graphql.org/June2018/#sec-Names
     *
     * Therefore we need to make sure our users only use values, which
     * can be returned by GraphQL, by checking the regressed values
     * agains the GraphQL regex.
     *
     * TODO V5: check if we can avoid this coupling by moving this logic
     * into the GraphQL plugin.
     */
    const GRAPHQL_ENUM_REGEX = /^[_A-Za-z][_0-9A-Za-z]*$/;

    const shape = {
      name: yup
        .string()
        .test(alreadyUsedAttributeNames(usedAttributeNames))
        .test(isNameAllowed(reservedNames))
        .matches(GRAPHQL_ENUM_REGEX, errorsTrads.regex.id)
        .required(errorsTrads.required.id),
      type: validators.type(),
      default: validators.default(),
      unique: validators.unique(),
      required: validators.required(),
      enum: yup
        .array()
        .of(yup.string())
        .min(1, errorsTrads.min.id)
        .test({
          name: 'areEnumValuesUnique',
          message: getTrad('error.validation.enum-duplicate'),
          test(values) {
            if (!values) {
              return false;
            }
            const duplicates = uniq(
              values
                .map(toRegressedEnumValue)
                .filter((value, index, values) => values.indexOf(value) !== index)
            );

            return !duplicates.length;
          },
        })
        .test({
          name: 'doesNotHaveEmptyValues',
          message: getTrad('error.validation.enum-empty-string'),
          test: (values) => {
            if (!values) {
              return false;
            }
            return !values.map(toRegressedEnumValue).some((val) => val === '');
          },
        })
        .test({
          name: 'doesMatchRegex',
          message: getTrad('error.validation.enum-regex'),
          test: (values) => {
            if (!values) {
              return false;
            }
            return values
              .map(toRegressedEnumValue)
              .every((value) => GRAPHQL_ENUM_REGEX.test(value));
          },
        }),
      enumName: yup.string().nullable(),
    };

    return yup.object(shape);
  },
  float(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      required: validators.required(),
      default: yup.number(),
      max: yup.number(),
      min: yup.number().test(isMinSuperiorThanMax<number>()),
    };

    return yup.object(shape);
  },
  integer(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      default: yup.number().integer(),
      unique: validators.unique(),
      required: validators.required(),
      max: validators.max(),
      min: validators.min(),
    };

    return yup.object(shape);
  },
  json(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      required: validators.required(),
      unique: validators.unique(),
    };

    return yup.object(shape);
  },
  media(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      multiple: yup.boolean(),
      required: validators.required(),
      allowedTypes: yup
        .array()
        .of(yup.string().oneOf(['images', 'videos', 'files', 'audios']))
        .min(1)
        .nullable(),
    };

    return yup.object(shape);
  },
  password(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      default: validators.default(),
      unique: validators.unique(),
      required: validators.required(),
      maxLength: validators.maxLength(),
      minLength: validators.minLength(),
    };

    return yup.object(shape);
  },
  relation(
    usedAttributeNames: Array<string>,
    reservedNames: Array<string>,
    alreadyTakenTargetAttributes: Array<{ name: string }>,
    {
      initialData,
      modifiedData,
    }: {
      initialData: { targetAttribute?: string };
      modifiedData: {
        name?: string;
        relation?: Schema.Attribute.RelationKind.WithTarget;
        targetAttribute?: string;
      };
    }
  ) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      target: yup.string().required(errorsTrads.required.id),
      relation: yup.string().required(),
      type: yup.string().required(),
      targetAttribute: yup.lazy(() => {
        const relationType = getRelationType(modifiedData.relation, modifiedData.targetAttribute);

        if (relationType === 'oneWay' || relationType === 'manyWay') {
          return yup.string().nullable();
        }

        const schema = yup.string().test(isNameAllowed(reservedNames));
        const initialForbiddenName = [
          ...alreadyTakenTargetAttributes.map(({ name }) => name),
          modifiedData.name,
        ];

        const forbiddenTargetAttributeName = initialForbiddenName.filter(
          (val) => val !== initialData.targetAttribute
        );

        return schema
          .matches(NAME_REGEX, errorsTrads.regex.id)
          .test({
            name: 'forbiddenTargetAttributeName',
            message: getTrad('error.validation.relation.targetAttribute-taken'),
            test(value) {
              if (!value) {
                return false;
              }

              return !forbiddenTargetAttributeName.includes(value);
            },
          })
          .required(errorsTrads.required.id);
      }),
    };

    return yup.object(shape);
  },
  richtext(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      default: validators.default(),
      unique: validators.unique(),
      required: validators.required(),
      maxLength: validators.maxLength(),
      minLength: validators.minLength(),
    };

    return yup.object(shape);
  },
  blocks(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = {
      name: validators.name(usedAttributeNames, reservedNames),
      type: validators.type(),
      default: validators.default(),
      unique: validators.unique(),
      required: validators.required(),
      maxLength: validators.maxLength(),
      minLength: validators.minLength(),
    };

    return yup.object(shape);
  },
  string(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = createTextShape(usedAttributeNames, reservedNames);

    return yup.object(shape);
  },
  text(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = createTextShape(usedAttributeNames, reservedNames);

    return yup.object(shape);
  },
  uid(usedAttributeNames: Array<string>, reservedNames: Array<string>) {
    const shape = createTextShape(usedAttributeNames, reservedNames);

    return yup.object(shape);
  },
};
</file>

<file path="admin/src/components/FormModal/category/createCategorySchema.ts">
import { translatedErrors as errorsTrads } from '@strapi/admin/strapi-admin';
import * as yup from 'yup';

import { CATEGORY_NAME_REGEX } from './regex';

export const createCategorySchema = (usedCategoryNames: Array<string>) => {
  const shape = {
    name: yup
      .string()
      .matches(CATEGORY_NAME_REGEX, errorsTrads.regex.id)
      .test({
        name: 'nameNotAllowed',
        message: errorsTrads.unique.id,
        test(value) {
          if (!value) {
            return false;
          }
          return !usedCategoryNames.includes(value?.toLowerCase());
        },
      })
      .required(errorsTrads.required.id),
  };

  return yup.object(shape);
};
</file>

<file path="admin/src/components/FormModal/category/form.ts">
import { getTrad } from '../../../utils/getTrad';

export const categoryForm = {
  base: {
    sections: [
      {
        sectionTitle: null,
        items: [
          {
            autoFocus: true,
            name: 'name',
            type: 'text',
            intlLabel: {
              id: 'global.name',
              defaultMessage: 'Name',
            },

            // validations: {
            //   required: true,
            // },
            description: {
              id: getTrad('modalForm.editCategory.base.name.description'),
              defaultMessage: 'No space is allowed for the name of the category',
            },
          },
        ],
      },
    ],
  },
};
</file>

<file path="admin/src/components/FormModal/category/regex.ts">
export const CATEGORY_NAME_REGEX = /^[A-Za-z][-_0-9A-Za-z]*$/;
</file>

<file path="admin/src/components/FormModal/component/componentField.ts">
import { getTrad } from '../../../utils/getTrad';

export const componentField = {
  intlLabel: {
    id: 'global.type',
    defaultMessage: 'Type',
  },
  name: 'createComponent',
  type: 'boolean-radio-group',
  size: 12,
  radios: [
    {
      title: {
        id: getTrad('form.attribute.component.option.create'),
        defaultMessage: 'Create a new component',
      },
      description: {
        id: getTrad('form.attribute.component.option.create.description'),
        defaultMessage:
          'A component is shared across types and components, it will be available and accessible everywhere.',
      },
      value: true,
    },
    {
      title: {
        id: getTrad('form.attribute.component.option.reuse-existing'),
        defaultMessage: 'Use an existing component',
      },
      description: {
        id: getTrad('form.attribute.component.option.reuse-existing.description'),
        defaultMessage:
          'Reuse a component already created to keep your data consistent across content-types.',
      },
      value: false,
    },
  ],
};
</file>

<file path="admin/src/components/FormModal/component/componentForm.ts">
import { getTrad } from '../../../utils/getTrad';

export const componentForm = {
  base(prefix = '') {
    const sections = [
      {
        sectionTitle: null,
        items: [
          {
            name: `${prefix}displayName`,
            type: 'text',
            intlLabel: {
              id: getTrad('contentType.displayName.label'),
              defaultMessage: 'Display Name',
            },
          },
          {
            name: `${prefix}category`,
            type: 'select-category',
            intlLabel: {
              id: getTrad('modalForm.components.create-component.category.label'),
              defaultMessage: 'Select a category or enter a name to create a new one',
            },
          },
        ],
      },
      {
        sectionTitle: null,
        items: [
          {
            name: `${prefix}icon`,
            type: 'icon-picker',
            size: 12,
            intlLabel: {
              id: getTrad('modalForm.components.icon.label'),
              defaultMessage: 'Icon',
            },
          },
        ],
      },
    ];

    return sections;
  },
  advanced() {
    const sections: Array<unknown> = [];

    return sections;
  },
};
</file>

<file path="admin/src/components/FormModal/component/createComponentSchema.ts">
import { translatedErrors as errorsTrads } from '@strapi/admin/strapi-admin';
import { snakeCase } from 'lodash/fp';
import * as yup from 'yup';

import { getTrad } from '../../../utils/getTrad';
import { CATEGORY_NAME_REGEX } from '../category/regex';
import { createComponentUid } from '../utils/createUid';

export const createComponentSchema = (
  usedComponentNames: Array<string>,
  reservedNames: Array<string>,
  category: string,
  takenCollectionNames: Array<string>,
  currentCollectionName: string
) => {
  const shape = {
    displayName: yup
      .string()
      .test({
        name: 'nameAlreadyUsed',
        message: errorsTrads.unique.id,
        test(value) {
          if (!value) {
            return false;
          }

          const name = createComponentUid(value, category);

          const snakeCaseKey = snakeCase(name);
          const snakeCaseCollectionName = snakeCase(currentCollectionName);

          return (
            usedComponentNames.every((reserved) => {
              return snakeCase(reserved) !== snakeCaseKey;
            }) &&
            takenCollectionNames.every(
              (collectionName) => snakeCase(collectionName) !== snakeCaseCollectionName
            )
          );
        },
      })
      .test({
        name: 'nameNotAllowed',
        message: getTrad('error.contentTypeName.reserved-name'),
        test(value) {
          if (!value) {
            return false;
          }

          const snakeCaseKey = snakeCase(value);
          return reservedNames.every((reserved) => {
            return snakeCase(reserved) !== snakeCaseKey;
          });
        },
      })
      .required(errorsTrads.required.id),
    category: yup
      .string()
      .matches(CATEGORY_NAME_REGEX, errorsTrads.regex.id)
      .required(errorsTrads.required.id),

    icon: yup.string(),
  };

  return yup.object(shape);
};
</file>

<file path="admin/src/components/FormModal/contentType/contentTypeForm.ts">
import { getTrad } from '../../../utils/getTrad';

const nameField = {
  name: 'displayName',
  type: 'text',
  intlLabel: {
    id: getTrad('contentType.displayName.label'),
    defaultMessage: 'Display name',
  },
};

export const contentTypeForm = {
  advanced: {
    default() {
      return {
        sections: [
          {
            items: [
              {
                intlLabel: {
                  id: getTrad('contentType.draftAndPublish.label'),
                  defaultMessage: 'Draft & publish',
                },
                description: {
                  id: getTrad('contentType.draftAndPublish.description'),
                  defaultMessage:
                    'Allows writing a draft version of an entry, before it is published',
                },
                name: 'draftAndPublish',
                type: 'toggle-draft-publish',
                validations: {},
              },
            ],
          },
        ],
      };
    },
  },
  base: {
    create() {
      return {
        sections: [
          {
            sectionTitle: null,
            items: [
              nameField,
              {
                description: {
                  id: getTrad('contentType.apiId-singular.description'),
                  defaultMessage:
                    'Used to generate the API routes and databases tables/collections',
                },
                intlLabel: {
                  id: getTrad('contentType.apiId-singular.label'),
                  defaultMessage: 'API ID (Singular)',
                },
                name: 'singularName',
                type: 'text-singular',
              },
              {
                type: 'pushRight',
                size: 6,
                intlLabel: { id: '', defaultMessage: '' },
                name: 'pushRight',
              },
              {
                description: {
                  id: getTrad('contentType.apiId-plural.description'),
                  defaultMessage: 'Pluralized API ID',
                },
                intlLabel: {
                  id: getTrad('contentType.apiId-plural.label'),
                  defaultMessage: 'API ID (Plural)',
                },
                name: 'pluralName',
                type: 'text-plural',
              },
            ],
          },
        ],
      };
    },
    edit() {
      return {
        sections: [
          {
            sectionTitle: null,
            items: [
              nameField,
              {
                disabled: true,
                description: {
                  id: getTrad('contentType.apiId-singular.description'),
                  defaultMessage:
                    'Used to generate the API routes and databases tables/collections',
                },
                intlLabel: {
                  id: getTrad('contentType.apiId-singular.label'),
                  defaultMessage: 'API ID (Singular)',
                },
                name: 'singularName',
                type: 'text',
              },
              {
                type: 'pushRight',
                size: 6,
                intlLabel: { id: '', defaultMessage: '' },
                name: 'pushRight',
              },
              {
                disabled: true,
                description: {
                  id: getTrad('contentType.apiId-plural.description'),
                  defaultMessage: 'Pluralized API ID',
                },
                intlLabel: {
                  id: getTrad('contentType.apiId-plural.label'),
                  defaultMessage: 'API ID (Plural)',
                },
                name: 'pluralName',
                type: 'text',
              },
              {
                intlLabel: {
                  id: 'global.type',
                  defaultMessage: 'Type',
                },
                name: 'kind',
                type: 'content-type-radio-group',
                size: 12,
                radios: [
                  {
                    title: {
                      id: getTrad('form.button.collection-type.name'),
                      defaultMessage: 'Collection Type',
                    },
                    description: {
                      id: getTrad('form.button.collection-type.description'),
                      defaultMessage:
                        'Best for multiple instances like articles, products, comments, etc.',
                    },
                    value: 'collectionType',
                  },
                  {
                    title: {
                      id: getTrad('form.button.single-type.name'),
                      defaultMessage: 'Single Type',
                    },
                    description: {
                      id: getTrad('form.button.single-type.description'),
                      defaultMessage: 'Best for single instance like about us, homepage, etc.',
                    },
                    value: 'singleType',
                  },
                ],
              },
            ],
          },
        ],
      };
    },
  },
};
</file>

<file path="admin/src/components/FormModal/contentType/createContentTypeSchema.ts">
import { translatedErrors as errorsTrads } from '@strapi/admin/strapi-admin';
import { snakeCase } from 'lodash/fp';
import * as yup from 'yup';

import { getTrad } from '../../../utils/getTrad';
import { createUid } from '../utils/createUid';

type CreateContentTypeSchemaParams = {
  usedContentTypeNames: Array<string>;
  reservedModels: Array<string>;
  singularNames: Array<string>;
  pluralNames: Array<string>;
  collectionNames: Array<string>;
};

export const createContentTypeSchema = ({
  usedContentTypeNames = [],
  reservedModels = [],
  singularNames = [],
  pluralNames = [],
  collectionNames = [],
}: CreateContentTypeSchemaParams) => {
  const shape = {
    displayName: yup
      .string()
      .test({
        name: 'nameAlreadyUsed',
        message: errorsTrads.unique.id,
        test(value) {
          if (!value) {
            return false;
          }

          const name = createUid(value);

          const snakeCaseKey = snakeCase(name);

          return !usedContentTypeNames.some((value) => {
            return snakeCase(value) === snakeCaseKey;
          });
        },
      })
      .test({
        name: 'nameNotAllowed',
        message: getTrad('error.contentTypeName.reserved-name'),
        test(value) {
          if (!value) {
            return false;
          }
          const snakeCaseKey = snakeCase(value);

          return !reservedModels.some((key) => {
            return snakeCase(key) === snakeCaseKey;
          });
        },
      })
      .required(errorsTrads.required.id),
    pluralName: yup
      .string()
      .test({
        name: 'pluralNameAlreadyUsed',
        message: errorsTrads.unique.id,
        test(value) {
          if (!value) {
            return false;
          }

          const snakeCaseKey = snakeCase(value);

          return !pluralNames.some((key) => {
            return snakeCase(key) === snakeCaseKey;
          });
        },
      })
      .test({
        name: 'pluralNameAlreadyUsedAsSingular',
        message: getTrad('error.contentType.pluralName-equals-singularName'),
        test(value) {
          if (!value) {
            return false;
          }

          const snakeCaseKey = snakeCase(value);

          return !singularNames.some((key) => {
            return snakeCase(key) === snakeCaseKey;
          });
        },
      })
      .test({
        name: 'pluralAndSingularAreUnique',
        message: getTrad('error.contentType.pluralName-used'),
        test(value, context) {
          if (!value) {
            return false;
          }

          return snakeCase(context.parent.singularName) !== snakeCase(value);
        },
      })
      .test({
        name: 'pluralNameNotAllowed',
        message: getTrad('error.contentTypeName.reserved-name'),
        test(value) {
          if (!value) {
            return false;
          }

          const snakeCaseKey = snakeCase(value);

          return !reservedModels.some((key) => {
            return snakeCase(key) === snakeCaseKey;
          });
        },
      })
      .test({
        name: 'pluralNameNotAlreadyUsedInCollectionName',
        message: getTrad('error.contentType.pluralName-equals-collectionName'),
        test(value) {
          if (!value) {
            return false;
          }

          const snakeCaseKey = snakeCase(value);

          return !collectionNames.some((key) => {
            return snakeCase(key) === snakeCaseKey;
          });
        },
      })
      .required(errorsTrads.required.id),
    singularName: yup
      .string()
      .test({
        name: 'singularNameAlreadyUsed',
        message: errorsTrads.unique.id,
        test(value) {
          if (!value) {
            return false;
          }

          const snakeCaseKey = snakeCase(value);

          return !singularNames.some((key) => {
            return snakeCase(key) === snakeCaseKey;
          });
        },
      })
      .test({
        name: 'singularNameAlreadyUsedAsPlural',
        message: getTrad('error.contentType.singularName-equals-pluralName'),
        test(value) {
          if (!value) {
            return false;
          }

          const snakeCaseKey = snakeCase(value);

          return !pluralNames.some((key) => {
            return snakeCase(key) === snakeCaseKey;
          });
        },
      })
      .test({
        name: 'pluralAndSingularAreUnique',
        message: getTrad('error.contentType.singularName-used'),
        test(value, context) {
          if (!value) {
            return false;
          }

          return snakeCase(context.parent.pluralName) !== snakeCase(value);
        },
      })
      .test({
        name: 'singularNameNotAllowed',
        message: getTrad('error.contentTypeName.reserved-name'),
        test(value) {
          if (!value) {
            return false;
          }

          const snakeCaseKey = snakeCase(value);

          return !reservedModels.some((key) => {
            return snakeCase(key) === snakeCaseKey;
          });
        },
      })
      .required(errorsTrads.required.id),
    draftAndPublish: yup.boolean(),
    kind: yup.string().oneOf(['singleType', 'collectionType']),
  };

  return yup.object(shape);
};
</file>

<file path="admin/src/components/FormModal/forms/tests/customField.test.ts">
import * as yup from 'yup';

import { formsAPI as ctbFormsAPI } from '../../../../utils/formAPI';
import { SchemaParams, forms } from '../forms';

const mockBaseCustomField = {
  name: 'color',
  pluginId: 'color-picker',
  type: 'string',
  icon: jest.fn(),
  intlLabel: {
    id: 'color-picker.label',
    defaultMessage: 'Color',
  },
  intlDescription: {
    id: 'color-picker.description',
    defaultMessage: 'Select any color',
  },
  components: {
    Input: jest.fn(),
  },
};

const mockNoSectionInput = [
  {
    intlLabel: {
      id: 'test',
      defaultMessage: 'Test',
    },
    name: 'regex',
    type: 'text',
    description: {
      id: 'test',
      defaultMessage: 'test',
    },
  },
];

const mockNewSectionInput = [
  {
    sectionTitle: {
      id: 'test',
      defaultMessage: 'Settings',
    },
    items: [
      {
        name: 'required',
        type: 'checkbox',
        intlLabel: {
          id: 'color-picker.options.advanced.requiredField',
          defaultMessage: 'Required field',
        },
        description: {
          id: 'color-picker.options.advanced.requiredField.description',
          defaultMessage: "You won't be able to create an entry if this field is empty",
        },
      },
    ],
  },
];

describe('customField forms', () => {
  describe('schema', () => {
    it('validates input using the provided validator', async () => {
      const mockArgs: SchemaParams = {
        schemaAttributes: [
          {
            type: 'string',
            required: true,
            unique: true,
            configurable: true,
            name: 'type',
          },
        ],
        attributeType: 'string',
        reservedNames: {
          attributes: [],
        },
        customFieldValidator: () => ({
          test: yup.string().required(),
        }),
        schemaData: {
          modifiedData: {
            type: 'string',
            default: null,
            options: {
              test: 'option',
            },
          },
          initialData: {},
        },
        ctbFormsAPI,
      };
      const customFieldValidator = forms.customField.schema(mockArgs);
      const modifiedData = mockArgs.schemaData.modifiedData;
      const result = await customFieldValidator.validateAt('options.test', modifiedData);
      // If valid, yup returns the value
      expect(result).toBe(modifiedData.options.test);
    });
  });
  describe('base form', () => {
    it('adds to the default base form section', () => {
      const mockCustomField = {
        ...mockBaseCustomField,
        options: {
          base: mockNoSectionInput,
        },
      };

      const result = forms.customField.form.base({ customField: mockCustomField });

      const expected = [
        {
          sectionTitle: null,
          items: [
            {
              name: 'name',
              type: 'text',
              intlLabel: {
                id: 'global.name',
                defaultMessage: 'Name',
              },
              description: {
                id: 'content-type-builder.modalForm.attribute.form.base.name.description',
                defaultMessage: 'No space is allowed for the name of the attribute',
              },
            },
            {
              intlLabel: {
                id: 'test',
                defaultMessage: 'Test',
              },
              name: 'regex',
              type: 'text',
              description: {
                id: 'test',
                defaultMessage: 'test',
              },
            },
          ],
        },
      ];

      expect(result.sections.length).toBe(1);
      expect(result).toStrictEqual({ sections: expected });
    });

    it('adds a new base form section', () => {
      const mockCustomField = {
        ...mockBaseCustomField,
        options: {
          base: mockNewSectionInput,
        },
      };
      const result = forms.customField.form.base({ customField: mockCustomField });
      const expected = [
        {
          sectionTitle: null,
          items: [
            {
              name: 'name',
              type: 'text',
              intlLabel: {
                id: 'global.name',
                defaultMessage: 'Name',
              },
              description: {
                id: 'content-type-builder.modalForm.attribute.form.base.name.description',
                defaultMessage: 'No space is allowed for the name of the attribute',
              },
            },
          ],
        },
        {
          sectionTitle: {
            id: 'test',
            defaultMessage: 'Settings',
          },
          items: [
            {
              name: 'required',
              type: 'checkbox',
              intlLabel: {
                id: 'color-picker.options.advanced.requiredField',
                defaultMessage: 'Required field',
              },
              description: {
                id: 'color-picker.options.advanced.requiredField.description',
                defaultMessage: "You won't be able to create an entry if this field is empty",
              },
            },
          ],
        },
      ];

      expect(result.sections.length).toBe(2);
      expect(result).toStrictEqual({ sections: expected });
    });
  });
  describe('advanced form', () => {
    it('adds to the default advanced section', () => {
      const mockCustomField = {
        ...mockBaseCustomField,
        options: {
          advanced: mockNoSectionInput,
        },
      };
      const result = forms.customField.form.advanced({
        customField: mockCustomField,
        extensions: { getAdvancedForm: jest.fn() },
      });

      const expected = [
        {
          sectionTitle: null,
          items: [
            {
              intlLabel: {
                id: 'test',
                defaultMessage: 'Test',
              },
              name: 'regex',
              type: 'text',
              description: {
                id: 'test',
                defaultMessage: 'test',
              },
            },
          ],
        },
      ];

      expect(result.sections.length).toBe(1);
      expect(result).toStrictEqual({ sections: expected });
    });
    it('adds a new advanced form section', () => {
      const mockCustomField = {
        ...mockBaseCustomField,
        options: {
          advanced: mockNewSectionInput,
        },
      };

      const result = forms.customField.form.advanced({
        customField: mockCustomField,
        extensions: { getAdvancedForm: jest.fn() },
      });

      const expected = [
        {
          sectionTitle: null,
          items: [],
        },
        {
          sectionTitle: {
            id: 'test',
            defaultMessage: 'Settings',
          },
          items: [
            {
              name: 'required',
              type: 'checkbox',
              intlLabel: {
                id: 'color-picker.options.advanced.requiredField',
                defaultMessage: 'Required field',
              },
              description: {
                id: 'color-picker.options.advanced.requiredField.description',
                defaultMessage: "You won't be able to create an entry if this field is empty",
              },
            },
          ],
        },
      ];

      expect(result.sections.length).toBe(2);
      expect(result).toStrictEqual({ sections: expected });
    });

    it('injects inputs from other plugins', () => {
      const mockCustomField = {
        ...mockBaseCustomField,
        options: {
          base: [],
          advanced: [],
        },
      };
      const result = forms.customField.form.advanced({
        customField: mockCustomField,
        extensions: {
          getAdvancedForm: jest.fn(() => [
            {
              name: 'pluginOptions.i18n.localized',
              description: {
                id: 'i18n.plugin.schema.i18n.localized.description-field',
                defaultMessage: 'The field can have different values in each locale',
              },
              type: 'checkbox',
              intlLabel: {
                id: 'i18n.plugin.schema.i18n.localized.label-field',
                defaultMessage: 'Enable localization for this field',
              },
            },
          ]),
        },
      });

      const expected = [
        {
          sectionTitle: null,
          items: [],
        },
        {
          sectionTitle: {
            id: 'content-type-builder.modalForm.custom-fields.advanced.settings.extended',
            defaultMessage: 'Extended settings',
          },
          items: [
            {
              name: 'pluginOptions.i18n.localized',
              description: {
                id: 'i18n.plugin.schema.i18n.localized.description-field',
                defaultMessage: 'The field can have different values in each locale',
              },
              type: 'checkbox',
              intlLabel: {
                id: 'i18n.plugin.schema.i18n.localized.label-field',
                defaultMessage: 'Enable localization for this field',
              },
            },
          ],
        },
      ];

      expect(result.sections.length).toBe(2);
      expect(result).toStrictEqual({ sections: expected });
    });
  });
});
</file>

<file path="admin/src/components/FormModal/forms/utils/tests/addItemsToFormSections.test.ts">
import { addItemsToFormSection } from '../addItemsToFormSection';

describe('addItemsToFormSection', () => {
  it('adds items to the default section', () => {
    const sections = [{ sectionTitle: null, items: [] }];
    const itemsToAdd = [
      {
        intlLabel: {
          id: 'color-picker.color.format.label',
          defaultMessage: 'Color format',
        },
        name: 'options.color-picker.format',
        type: 'select',
        value: 'hex',
        options: [
          {
            key: 'hex',
            value: 'hex',
            metadatas: {
              intlLabel: {
                id: 'color-picker.color.format.hex',
                defaultMessage: 'Hexadecimal',
              },
            },
          },
          {
            key: 'rgba',
            value: 'rgba',
            metadatas: {
              intlLabel: {
                id: 'color-picker.color.format.rgba',
                defaultMessage: 'RGBA',
              },
            },
          },
        ],
      },
    ];

    addItemsToFormSection(itemsToAdd, sections);

    expect(sections.length).toBe(1);
    expect(sections[0].items.length).toBe(1);
  });

  it('adds the item as a new section', () => {
    const sections = [{ sectionTitle: null, items: [] }];
    const itemsToAdd = [
      {
        sectionTitle: null,
        items: [
          {
            intlLabel: {
              id: 'color-picker.color.format.label',
              defaultMessage: 'Color format',
            },
            name: 'options.color-picker.format',
            type: 'select',
            value: 'hex',
            options: [
              {
                key: 'hex',
                value: 'hex',
                metadatas: {
                  intlLabel: {
                    id: 'color-picker.color.format.hex',
                    defaultMessage: 'Hexadecimal',
                  },
                },
              },
              {
                key: 'rgba',
                value: 'rgba',
                metadatas: {
                  intlLabel: {
                    id: 'color-picker.color.format.rgba',
                    defaultMessage: 'RGBA',
                  },
                },
              },
            ],
          },
        ],
      },
    ];

    addItemsToFormSection(itemsToAdd, sections);

    expect(sections.length).toBe(2);
  });
});
</file>

<file path="admin/src/components/FormModal/forms/utils/addItemsToFormSection.ts">
type SectionTitle = {
  id: string;
  defaultMessage: string;
};

type Item = {
  intlLabel: {
    id: string;
    defaultMessage: string;
  };
  description?: { id: string; defaultMessage: string };
  name: string;
  type: string;
  value?: string;
  options?: {
    key: string;
    value: string;
    metadatas: {
      intlLabel: {
        id: string;
        defaultMessage: string;
      };
    };
  }[];
};

type FormTypeOption = {
  sectionTitle: SectionTitle | null;
  items: Item[];
};

export type FormTypeOptions = Array<FormTypeOption>;

/**
 * @description
 * Adds form options to the default section or as a new section
 */
export const addItemsToFormSection = (
  formTypeOptions: FormTypeOptions | Item[],
  sections: FormTypeOptions
) => {
  formTypeOptions.forEach((item) => {
    if (!('sectionTitle' in item)) {
      // When there is no sectionTitle key,
      // add the item to the default section
      sections[0].items?.push(item);
      return;
    }

    // Otherwise, when sectionTitle has a value (including null),
    // add the item as a new section
    sections.push(item);
  });
};
</file>

<file path="admin/src/components/FormModal/forms/utils/createCollectionName.ts">
import { snakeCase } from 'lodash/fp';
import pluralize from 'pluralize';

// TODO: create a utility for this
// Duplicate in server/src/services/schema-builder/component-builder.ts
const createComponentCollectionName = (name: string, category: string) => {
  return `components_${snakeCase(category)}_${pluralize(snakeCase(name))}`;
};

export { createComponentCollectionName };
</file>

<file path="admin/src/components/FormModal/forms/utils/getUsedAttributeNames.ts">
export type SchemaData = {
  initialData: {
    name: string;
    targetAttribute: any;
  };
  modifiedData: object;
};

export type Attribute = {
  name: string;
};

export const getUsedAttributeNames = (
  attributes: Array<Attribute>,
  schemaData: SchemaData
): Array<string> => {
  return attributes
    .filter(({ name }) => {
      return name !== schemaData.initialData.name;
    })
    .map(({ name }) => name);
};
</file>

<file path="admin/src/components/FormModal/forms/forms.ts">
import { getTrad } from '../../../utils';
import { commonBaseForm } from '../attributes/commonBaseForm';
import { attributesForm } from '../attributes/form';
import { nameField } from '../attributes/nameField';
import { attributeTypes } from '../attributes/types';
import { createCategorySchema } from '../category/createCategorySchema';
import { categoryForm } from '../category/form';
import { componentForm } from '../component/componentForm';
import { createComponentSchema } from '../component/createComponentSchema';
import { contentTypeForm } from '../contentType/contentTypeForm';
import { createContentTypeSchema } from '../contentType/createContentTypeSchema';
import { dynamiczoneForm } from '../dynamiczoneForm';

import { addItemsToFormSection, FormTypeOptions } from './utils/addItemsToFormSection';
import { createComponentCollectionName } from './utils/createCollectionName';
import { Attribute, getUsedAttributeNames, SchemaData } from './utils/getUsedAttributeNames';

import type { Internal } from '@strapi/types';

type ContentType = {
  schema: {
    singularName: string;
    pluralName: string;
    collectionName: string;
  };
};

export type SchemaParams = {
  schemaAttributes: any;
  attributeType: keyof typeof attributeTypes;
  customFieldValidator: any;
  reservedNames: {
    attributes: Array<string>;
  };
  schemaData: any;
  ctbFormsAPI: any;
};

type Base<TAttributesFormType extends 'base' | 'advanced'> = {
  data: any;
  type: keyof (typeof attributesForm)[TAttributesFormType];
  step: string;
  attributes: any;
  extensions: any;
  forTarget: string;
};

export const forms = {
  customField: {
    schema({
      schemaAttributes,
      attributeType,
      customFieldValidator,
      reservedNames,
      schemaData,
      ctbFormsAPI,
    }: SchemaParams) {
      const usedAttributeNames = getUsedAttributeNames(schemaAttributes, schemaData);

      let attributeShape;
      if (attributeType === 'relation') {
        attributeShape = attributeTypes[attributeType](
          usedAttributeNames,
          reservedNames.attributes,
          [],
          { initialData: {}, modifiedData: {} }
        );
      } else {
        attributeShape = attributeTypes[attributeType](
          usedAttributeNames,
          reservedNames.attributes
        );
      }

      return ctbFormsAPI.makeCustomFieldValidator(
        attributeShape,
        customFieldValidator,
        usedAttributeNames,
        reservedNames.attributes,
        schemaData
      );
    },
    form: {
      base({ customField }: any) {
        // Default section with required name field
        const sections: FormTypeOptions = [{ sectionTitle: null, items: [nameField] }];

        if (customField.options?.base) {
          addItemsToFormSection(customField.options.base, sections);
        }

        return { sections };
      },
      advanced({ customField, data, step, extensions, ...rest }: any) {
        // Default section with no fields
        const sections: FormTypeOptions = [{ sectionTitle: null, items: [] }];
        const injectedInputs = extensions.getAdvancedForm(['attribute', customField.type], {
          data,
          type: customField.type,
          step,
          ...rest,
        });

        if (customField.options?.advanced) {
          addItemsToFormSection(customField.options.advanced, sections);
        }

        if (injectedInputs) {
          const extendedSettings = {
            sectionTitle: {
              id: getTrad('modalForm.custom-fields.advanced.settings.extended'),
              defaultMessage: 'Extended settings',
            },
            items: injectedInputs,
          };

          sections.push(extendedSettings);
        }

        return { sections };
      },
    },
  },
  attribute: {
    schema(
      currentSchema: any,
      attributeType: keyof typeof attributeTypes,
      reservedNames: {
        attributes: Array<string>;
      },
      alreadyTakenTargetContentTypeAttributes: Array<Attribute>,
      options: SchemaData,
      extensions: {
        makeValidator: any;
      }
    ) {
      // Get the attributes object on the schema
      const attributes: Array<Attribute> = currentSchema?.schema?.attributes ?? [];
      const usedAttributeNames = getUsedAttributeNames(attributes, options);

      try {
        const attributeShape = attributeTypes[attributeType](
          usedAttributeNames,
          reservedNames.attributes,
          alreadyTakenTargetContentTypeAttributes,
          options
        );

        return extensions.makeValidator(
          ['attribute', attributeType],
          attributeShape,
          usedAttributeNames,
          reservedNames.attributes,
          alreadyTakenTargetContentTypeAttributes,
          options
        );
      } catch (err) {
        console.error('Error yup build schema', err);

        return attributeTypes.default(usedAttributeNames, reservedNames.attributes);
      }
    },
    form: {
      advanced({ data, type, step, extensions, ...rest }: Base<'advanced'>) {
        try {
          const baseForm = attributesForm.advanced[type](data, step).sections;
          const itemsToAdd = extensions.getAdvancedForm(['attribute', type], {
            data,
            type,
            step,
            ...rest,
          });

          const sections = baseForm.reduce((acc: Array<any>, current: any) => {
            if (current.sectionTitle === null) {
              acc.push(current);
            } else {
              acc.push({ ...current, items: [...current.items, ...itemsToAdd] });
            }

            return acc;
          }, []);
          // IF we want a dedicated section for the plugins
          // const sections = [
          //   ...baseForm,
          //   {
          //     sectionTitle: { id: 'Zone pour plugins', defaultMessage: 'Zone pour plugins' },
          //     items: itemsToAdd,
          //   },
          // ];

          return { sections };
        } catch (err) {
          console.error(err);

          return { sections: [] };
        }
      },
      base({ data, type, step, attributes }: Base<'base'>) {
        try {
          return attributesForm.base[type](data, step, attributes);
        } catch (err) {
          return commonBaseForm;
        }
      },
    },
  },
  contentType: {
    schema(
      alreadyTakenNames: Array<string>,
      isEditing: boolean,
      ctUid: Internal.UID.ContentType,
      reservedNames: {
        models: any;
      },
      extensions: any,
      contentTypes: Record<string, ContentType>
    ) {
      const singularNames = Object.values(contentTypes).map((contentType) => {
        return contentType.schema.singularName;
      });

      const pluralNames = Object.values(contentTypes).map((contentType: any) => {
        return contentType?.schema?.pluralName ?? '';
      });

      const takenNames = isEditing
        ? alreadyTakenNames.filter((uid) => uid !== ctUid)
        : alreadyTakenNames;

      const takenSingularNames = isEditing
        ? singularNames.filter((singName) => {
            const { schema } = contentTypes[ctUid];

            return schema.singularName !== singName;
          })
        : singularNames;

      const takenPluralNames = isEditing
        ? pluralNames.filter((pluralName) => {
            const { schema } = contentTypes[ctUid];

            return schema.pluralName !== pluralName;
          })
        : pluralNames;

      // return the array of collection names not all normalized
      const collectionNames = Object.values(contentTypes).map((contentType) => {
        return contentType?.schema?.collectionName ?? '';
      });

      const takenCollectionNames = isEditing
        ? collectionNames.filter((collectionName) => {
            const { schema } = contentTypes[ctUid];
            const currentCollectionName = schema.collectionName;

            return collectionName !== currentCollectionName;
          })
        : collectionNames;

      const contentTypeShape = createContentTypeSchema({
        usedContentTypeNames: takenNames,
        reservedModels: reservedNames.models,
        singularNames: takenSingularNames,
        pluralNames: takenPluralNames,
        collectionNames: takenCollectionNames,
      });

      // FIXME
      return extensions.makeValidator(
        ['contentType'],
        contentTypeShape,
        takenNames,
        reservedNames.models,
        takenSingularNames,
        takenPluralNames
      );
    },
    form: {
      base({ actionType }: any) {
        if (actionType === 'create') {
          return contentTypeForm.base.create();
        }

        return contentTypeForm.base.edit();
      },
      advanced({ extensions }: any) {
        const baseForm = contentTypeForm.advanced
          .default()
          .sections.map((section) => section.items)
          .flat();
        const itemsToAdd = extensions.getAdvancedForm(['contentType']);

        return {
          sections: [
            {
              items: [...baseForm, ...itemsToAdd],
            },
          ],
        };
      },
    },
  },
  component: {
    schema(
      alreadyTakenAttributes: Array<Internal.UID.Component>,
      componentCategory: string,
      reservedNames: {
        models: any;
      },
      isEditing = false,
      components: Record<string, any>,
      componentDisplayName: string,
      compoUid: Internal.UID.Component | null = null
    ) {
      const takenNames = isEditing
        ? alreadyTakenAttributes.filter((uid: Internal.UID.Component) => uid !== compoUid)
        : alreadyTakenAttributes;
      const collectionNames = Object.values(components).map((component: any) => {
        return component?.schema?.collectionName;
      });

      const currentCollectionName = createComponentCollectionName(
        componentDisplayName,
        componentCategory
      );

      const takenCollectionNames = isEditing
        ? collectionNames.filter((collectionName) => collectionName !== currentCollectionName)
        : collectionNames;

      return createComponentSchema(
        takenNames,
        reservedNames.models,
        componentCategory,
        takenCollectionNames,
        currentCollectionName
      );
    },
    form: {
      advanced() {
        return {
          sections: componentForm.advanced(),
        };
      },
      base() {
        return {
          sections: componentForm.base(),
        };
      },
    },
  },
  addComponentToDynamicZone: {
    form: {
      advanced() {
        return dynamiczoneForm.advanced.default();
      },
      base({ data }: any) {
        const isCreatingComponent = data?.createComponent ?? false;

        if (isCreatingComponent) {
          return dynamiczoneForm.base.createComponent();
        }

        return dynamiczoneForm.base.default();
      },
    },
  },
  editCategory: {
    schema(allCategories: Array<any>, initialData: any) {
      const allowedCategories = allCategories
        .filter((cat) => cat !== initialData.name)
        .map((cat) => cat.toLowerCase());

      return createCategorySchema(allowedCategories);
    },
    form: {
      advanced: () => ({ sections: [] }),
      base() {
        return categoryForm.base;
      },
    },
  },
};
</file>

<file path="admin/src/components/FormModal/tests/reducer.set-custom-field-data-schema.test.ts">
import * as actions from '../constants';
import { initialState, reducer } from '../reducer';

const mockCustomField = {
  type: 'string',
};

describe('CTB | components | FormModal | reducer | actions | SET_CUSTOM_FIELD_DATA_SCHEMA', () => {
  it('edits a custom field', () => {
    const expected = {
      ...initialState,
      initialData: {
        type: 'string',
        customField: 'plugin::color-picker.color',
        name: 'test',
      },
      modifiedData: {
        type: 'string',
        customField: 'plugin::color-picker.color',
        name: 'test',
      },
    };

    const action = {
      type: actions.SET_CUSTOM_FIELD_DATA_SCHEMA,
      isEditing: true,
      modifiedDataToSetForEditing: {
        type: 'string',
        customField: 'plugin::color-picker.color',
        name: 'test',
      },
    };

    expect(reducer(initialState, action)).toEqual(expected);
  });

  it('adds a custom field', () => {
    const action = {
      type: actions.SET_CUSTOM_FIELD_DATA_SCHEMA,
      customField: mockCustomField,
      isEditing: false,
      modifiedDataToSetForEditing: { name: null },
    };

    const expected = {
      ...initialState,
      modifiedData: {
        type: mockCustomField.type,
      },
    };

    expect(reducer(initialState, action)).toEqual(expected);
  });

  it("adds a custom field's default options", () => {
    const mockCustomFieldWithOptionsPath = {
      ...mockCustomField,
      options: {
        advanced: [
          {
            name: 'regex',
            type: 'text',
            defaultValue: '^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$',
          },
          {
            sectionTitle: {
              id: 'global.settings',
              defaultMessage: 'Settings',
            },
            items: [
              {
                name: 'required',
                type: 'checkbox',
                defaultValue: true,
              },
              {
                name: 'options.format',
                type: 'text',
                defaultValue: 'hex',
              },
            ],
          },
        ],
      },
    };

    const action = {
      type: actions.SET_CUSTOM_FIELD_DATA_SCHEMA,
      customField: mockCustomFieldWithOptionsPath,
      isEditing: false,
      modifiedDataToSetForEditing: { name: null },
    };

    const expected = {
      ...initialState,
      modifiedData: {
        type: mockCustomField.type,
        required: true,
        regex: '^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$',
        options: {
          format: 'hex',
        },
      },
    };

    expect(reducer(initialState, action)).toEqual(expected);
  });
});
</file>

<file path="admin/src/components/FormModal/tests/reducer.test.ts">
import * as actions from '../constants';
import { reducer, initialState } from '../reducer';

describe('CTB | components | FormModal | reducer | actions', () => {
  describe(actions.ON_CHANGE, () => {
    it('Should update the modifiedData object correctly', () => {
      const action = {
        type: actions.ON_CHANGE,
        keys: ['name'],
        value: 'test',
      };

      const state = {
        ...initialState,
        modifiedData: {
          type: 'string',
        },
      };

      const expected = {
        ...initialState,
        modifiedData: {
          name: 'test',
          type: 'string',
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('should remove the default value if the type of date input type has been changed', () => {
      const state = {
        ...initialState,
        modifiedData: {
          name: 'short_movie_time',
          type: 'time',
          default: '00:30:00',
        },
      };
      const action = {
        type: actions.ON_CHANGE,
        keys: ['type'],
        value: 'datetime',
      };
      const expected = {
        ...initialState,
        modifiedData: {
          name: 'short_movie_time',
          type: 'datetime',
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('should not remove the default value if the type of another input type has been changed', () => {
      const state = {
        ...initialState,
        modifiedData: {
          name: 'number_of_movies',
          type: 'integer',
          default: '0',
        },
      };
      const action = {
        type: actions.ON_CHANGE,
        keys: ['type'],
        value: 'biginteger',
      };

      const expected = {
        ...initialState,
        modifiedData: {
          name: 'number_of_movies',
          type: 'biginteger',
          default: '0',
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('ON_CHANGE_RELATION_TARGET', () => {
    it('Should handle the target change correctly for a one side relation (oneWay, manyWay)', () => {
      const state = {
        ...initialState,
        modifiedData: {
          name: 'category test',
          relation: 'oneToOne',
          targetAttribute: null,
          target: 'api::category.category',
          type: 'relation',
        },
      };
      const action = {
        type: actions.ON_CHANGE_RELATION_TARGET,
        target: {
          value: 'api::address.address',
          oneThatIsCreatingARelationWithAnother: 'address',
          selectedContentTypeFriendlyName: 'address',
          targetContentTypeAllowedRelations: null,
        },
      };

      const expected = {
        ...initialState,
        modifiedData: {
          name: 'address',
          relation: 'oneToOne',
          targetAttribute: null,
          target: 'api::address.address',
          type: 'relation',
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should handle the target change correctly for the manyToMany relation', () => {
      const state = {
        ...initialState,
        modifiedData: {
          name: 'categories',
          relation: 'manyToMany',
          targetAttribute: 'addresses',
          target: 'api::category.category',
          type: 'relation',
        },
      };
      const action = {
        type: actions.ON_CHANGE_RELATION_TARGET,
        target: {
          value: 'api::country.country',
          oneThatIsCreatingARelationWithAnother: 'address',
          selectedContentTypeFriendlyName: 'country',
          targetContentTypeAllowedRelations: null,
        },
      };
      const expected = {
        ...initialState,
        modifiedData: {
          name: 'countries',
          relation: 'manyToMany',
          targetAttribute: 'addresses',
          target: 'api::country.country',
          type: 'relation',
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should handle the target change correctly if the target has restricted relations and the relation type is not correct', () => {
      const state = {
        ...initialState,
        modifiedData: {
          name: 'categories',
          relation: 'manyToMany',
          targetAttribute: 'addresses',
          target: 'api::category.category',
          type: 'relation',
        },
      };
      const action = {
        type: actions.ON_CHANGE_RELATION_TARGET,
        target: {
          value: 'api::country.country',
          oneThatIsCreatingARelationWithAnother: 'address',
          selectedContentTypeFriendlyName: 'country',
          targetContentTypeAllowedRelations: ['oneWay'],
        },
      };

      const expected = {
        ...initialState,
        modifiedData: {
          name: 'country',
          relation: 'oneToOne',
          targetAttribute: null,
          target: 'api::country.country',
          type: 'relation',
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should handle the target change correctly if the target has restricted relations and the relation type is correct', () => {
      const state = {
        ...initialState,
        modifiedData: {
          name: 'categories',
          relation: 'oneToMany',
          targetAttribute: null,
          target: 'api::category.category',
          type: 'relation',
        },
      };
      const action = {
        type: actions.ON_CHANGE_RELATION_TARGET,
        target: {
          value: 'api::country.country',
          oneThatIsCreatingARelationWithAnother: 'address',
          selectedContentTypeFriendlyName: 'country',
          targetContentTypeAllowedRelations: ['oneWay', 'manyWay'],
        },
      };

      const expected = {
        ...initialState,
        modifiedData: {
          name: 'countries',
          relation: 'oneToMany',
          targetAttribute: null,
          target: 'api::country.country',
          type: 'relation',
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('ON_CHANGE_RELATION_TYPE', () => {
    it('Should handle the relation type change correctly from oneWay to manyToMany', () => {
      const state = {
        ...initialState,
        modifiedData: {
          name: 'category test',
          relation: 'oneToOne',
          targetAttribute: null,
          target: 'api::category.category',
          type: 'relation',
        },
      };
      const action = {
        type: actions.ON_CHANGE_RELATION_TYPE,
        target: {
          value: 'manyToMany',

          oneThatIsCreatingARelationWithAnother: 'address',
        },
      };

      const expected = {
        ...initialState,
        modifiedData: {
          name: 'category_tests',
          relation: 'manyToMany',
          targetAttribute: 'addresses',
          target: 'api::category.category',
          type: 'relation',
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should handle the relation type change correctly from manyToMany to oneWay', () => {
      const state = {
        ...initialState,
        modifiedData: {
          name: 'category_tests',
          relation: 'manyToMany',
          targetAttribute: 'addresses',
          target: 'api::category.category',
          type: 'relation',
        },
      };
      const action = {
        type: actions.ON_CHANGE_RELATION_TYPE,
        target: {
          value: 'oneWay',
          oneThatIsCreatingARelationWithAnother: 'address',
        },
      };

      const expected = {
        ...initialState,
        modifiedData: {
          name: 'category_test',
          relation: 'oneToOne',
          targetAttribute: null,
          target: 'api::category.category',
          type: 'relation',
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });

    it('Should handle the relation type change correctly from oneToOne to oneToMany', () => {
      const state = {
        ...initialState,
        modifiedData: {
          name: 'category_test',
          relation: 'oneToOne',
          targetAttribute: 'address',
          target: 'api::category.category',
          type: 'relation',
        },
      };
      const action = {
        type: actions.ON_CHANGE_RELATION_TYPE,
        target: {
          value: 'oneToMany',
          oneThatIsCreatingARelationWithAnother: 'address',
        },
      };

      const expected = {
        ...initialState,
        modifiedData: {
          name: 'category_tests',
          relation: 'oneToMany',
          targetAttribute: 'address',
          target: 'api::category.category',
          type: 'relation',
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('RESET_PROPS', () => {
    it('Should return the initialState', () => {
      const state = { ...initialState, modifiedData: 'test' };
      const action = { type: actions.RESET_PROPS };

      expect(reducer(state, action)).toEqual(initialState);
    });
  });

  describe('RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO', () => {
    it('Should reset the state and update the modifiedData object with the component field basic schema', () => {
      const action = {
        type: actions.RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO,
      };
      const state = { ...initialState, modifiedData: 'test' };
      const expected = {
        ...initialState,
        modifiedData: {
          type: 'component',
          repeatable: true,
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('RESET_PROPS_AND_SAVE_CURRENT_DATA', () => {
    it('Should reset the state and update the modifiedData and componentToCreate objects correctly', () => {
      const action = { type: actions.RESET_PROPS_AND_SAVE_CURRENT_DATA };

      const state = {
        ...initialState,
        modifiedData: {
          type: 'component',
          createComponent: true,
          componentToCreate: {
            type: 'component',
            displayName: 'compo',
            icon: 'air-freshener',
            category: 'default',
          },
        },
      };

      const expected = {
        ...initialState,
        componentToCreate: {
          type: 'component',
          displayName: 'compo',
          icon: 'air-freshener',
          category: 'default',
        },
        modifiedData: {
          displayName: 'compo',
          type: 'component',
          repeatable: false,
          component: 'default.compo',
        },
        isCreatingComponentWhileAddingAField: true,
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ', () => {
    it('Should reset the state and prepare the form for adding or creating a component to a dynamic zone', () => {
      const action = {
        type: actions.RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ,
      };

      const state = {
        ...initialState,
        initialData: 'test',
        modifiedData: {
          type: 'dynamiczone',
          components: [],
          name: 'dz',
        },
      };

      const expected = {
        ...initialState,
        modifiedData: {
          type: 'dynamiczone',
          components: [],
          name: 'dz',
          createComponent: true,
          componentToCreate: { type: 'component' },
        },
      };

      expect(reducer(state, action)).toEqual(expected);
    });
  });

  describe('SET_DATA_TO_EDIT', () => {
    it('Should set the state correctly', () => {
      const action = {
        type: actions.SET_DATA_TO_EDIT,
        data: {
          test: true,
        },
      };
      const expected = { ...initialState, modifiedData: action.data, initialData: action.data };

      expect(reducer(initialState, action)).toEqual(expected);
    });
  });

  describe('SET_ATTRIBUTE_DATA_SCHEMA', () => {
    it('Should handle the edition correcty', () => {
      const expected = {
        ...initialState,
        initialData: { test: true },
        modifiedData: { test: true },
      };
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        isEditing: true,
        modifiedDataToSetForEditing: {
          test: true,
        },
      };

      expect(reducer(initialState, action)).toEqual(expected);
    });

    it('Should set the state correctly for a component in step 1', () => {
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        attributeType: 'component',
        nameToSetForRelation: 'address',
        targetUid: 'api::address.address',
        isEditing: false,
        modifiedDataToSetForEditing: { name: null },
        step: '1',
      };
      const expected = {
        ...initialState,
        modifiedData: {
          type: 'component',
          createComponent: true,
          componentToCreate: { type: 'component' },
        },
      };

      expect(reducer(initialState, action)).toEqual(expected);
    });

    it('Should set the state correctly for a component in step 2', () => {
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        attributeType: 'component',
        nameToSetForRelation: 'address',
        targetUid: 'api::address.address',
        isEditing: false,
        modifiedDataToSetForEditing: { name: null },
        step: '2',
      };
      const expected = {
        ...initialState,
        modifiedData: {
          type: 'component',
          repeatable: true,
        },
      };

      expect(reducer(initialState, action)).toEqual(expected);
    });

    it('Should set the state correctly for a dynamiczone', () => {
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        attributeType: 'dynamiczone',
        nameToSetForRelation: 'address',
        targetUid: 'api::address.address',
        isEditing: false,
        modifiedDataToSetForEditing: { name: null },
        step: '2',
      };
      const expected = {
        ...initialState,
        modifiedData: {
          type: 'dynamiczone',
          components: [],
        },
      };

      expect(reducer(initialState, action)).toEqual(expected);
    });

    it('Should set the state correctly for a text', () => {
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        attributeType: 'text',
        nameToSetForRelation: 'address',
        targetUid: 'api::address.address',
        isEditing: false,
        modifiedDataToSetForEditing: { name: null },
        step: null,
      };
      const expected = {
        ...initialState,
        modifiedData: {
          type: 'string',
        },
      };

      expect(reducer(initialState, action)).toEqual(expected);
    });

    it('Should set the state correctly for a number', () => {
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        attributeType: 'number',
        nameToSetForRelation: 'address',
        targetUid: 'api::address.address',
        isEditing: false,
        modifiedDataToSetForEditing: { name: null },
        step: null,
      };
      const expected = { ...initialState, modifiedData: {} };

      expect(reducer(initialState, action)).toEqual(expected);
    });

    it('Should set the state correctly for a date', () => {
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        attributeType: 'date',
        nameToSetForRelation: 'address',
        targetUid: 'api::address.address',
        isEditing: false,
        modifiedDataToSetForEditing: { name: null },
        step: null,
      };
      const expected = { ...initialState, modifiedData: {} };

      expect(reducer(initialState, action)).toEqual(expected);
    });

    it('Should set the state correctly for a media', () => {
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        attributeType: 'media',
        nameToSetForRelation: 'address',
        targetUid: 'api::address.address',
        isEditing: false,
        modifiedDataToSetForEditing: { name: null },
        step: null,
      };
      const expected = {
        ...initialState,
        modifiedData: {
          type: 'media',
          multiple: true,
          allowedTypes: ['images', 'files', 'videos', 'audios'],
        },
      };

      expect(reducer(initialState, action)).toEqual(expected);
    });

    it('Should set the state correctly for an enumeration', () => {
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        attributeType: 'enumeration',
        nameToSetForRelation: 'address',
        targetUid: 'api::address.address',
        isEditing: false,
        modifiedDataToSetForEditing: { name: null },
        step: null,
      };
      const expected = { ...initialState, modifiedData: { type: 'enumeration', enum: [] } };

      expect(reducer(initialState, action)).toEqual(expected);
    });

    it('Should set the state correctly for a relation', () => {
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        attributeType: 'relation',
        nameToSetForRelation: 'address test',
        targetUid: 'api::address.address',
        isEditing: false,
        modifiedDataToSetForEditing: { name: null },
        step: null,
      };
      const expected = {
        ...initialState,
        modifiedData: {
          name: 'address_test',
          relation: 'oneToOne',
          targetAttribute: null,
          target: 'api::address.address',
          type: 'relation',
        },
      };

      expect(reducer(initialState, action)).toEqual(expected);
    });

    it('Should set the state correctly for the other cases', () => {
      const action = {
        type: actions.SET_ATTRIBUTE_DATA_SCHEMA,
        attributeType: 'json',
        nameToSetForRelation: 'address',
        targetUid: 'api::address.address',
        isEditing: false,
        modifiedDataToSetForEditing: { name: null },
        step: null,
      };
      const expected = { ...initialState, modifiedData: { type: 'json', default: null } };

      expect(reducer(initialState, action)).toEqual(expected);
    });
  });

  describe('SET_DYNAMIC_ZONE_DATA_SCHEMA', () => {
    it('Should set the dynamic zone schema correctly', () => {
      const action = {
        type: actions.SET_DYNAMIC_ZONE_DATA_SCHEMA,
        attributeToEdit: {
          type: 'dynamiczone',
          components: [],
          name: 'dz',
          createComponent: false,
          componentToCreate: { type: 'component' },
        },
      };
      const expected = {
        ...initialState,
        modifiedData: action.attributeToEdit,
        initialData: action.attributeToEdit,
      };

      expect(reducer(initialState, action)).toEqual(expected);
    });
  });

  describe('SET_ERRORS', () => {
    it('Should set the formErrors object correctly', () => {
      const action = {
        type: actions.SET_ERRORS,
        errors: {
          test: 'this is required',
        },
      };
      const expected = { ...initialState, formErrors: action.errors };

      expect(reducer(initialState, action)).toEqual(expected);
    });
  });

  describe('Default', () => {
    it('Should return the initialState', () => {
      const action = { type: 'DUMMY' };

      expect(reducer(initialState, action)).toEqual(initialState);
    });
  });
});
</file>

<file path="admin/src/components/FormModal/utils/tests/canEditContentType.test.ts">
import { canEditContentType } from '../canEditContentType';

import { rawData } from './rawData';

describe('canEditContentType', () => {
  it('should allow content type edition if one of attributes is a oneWay or manyWay relation', () => {
    const { postContentType } = rawData;

    expect(
      canEditContentType(postContentType, {
        kind: 'singleType',
      })
    ).toBeTruthy();
  });

  it('should not allow content type edition if one of attributes is not oneWay or manyWay relation', () => {
    const { articleContentType } = rawData;

    expect(
      canEditContentType(articleContentType, {
        kind: 'singleType',
      })
    ).toBeFalsy();
  });

  it('should always allow content type edition if content type is a single type', () => {
    const { homeSingleType } = rawData;

    expect(
      canEditContentType(homeSingleType, {
        kind: 'collectionType',
      })
    ).toBeTruthy();
  });

  it('should always allow content type edition if the kind is not modified', () => {
    const { articleContentType } = rawData;

    expect(
      canEditContentType(articleContentType, {
        kind: 'collectionType',
      })
    ).toBeTruthy();
  });
});
</file>

<file path="admin/src/components/FormModal/utils/tests/rawData.ts">
export const rawData: any = {
  homeSingleType: {
    contentType: {
      uid: 'plugin::myplugins.home',
      schema: {
        name: 'plugin::myplugins.home',
        kind: 'singleType',
        attributes: [
          {
            name: 'category',
            type: 'relation',
            relation: 'oneToOne',
            targetAttribute: null,
            target: 'category',
          },
          { name: 'address', type: 'string' },
        ],
      },
    },
  },
  articleContentType: {
    contentType: {
      uid: 'plugin::myplugins.article',
      schema: {
        name: 'plugin::myplugins.article',
        kind: 'collectionType',
        attributes: [
          {
            name: 'user',
            relation: 'manyToOne',
            type: 'relation',
            target: 'user',
            targetAttribute: 'article',
          },
          { name: 'category', type: 'string' },
        ],
      },
    },
  },
  postContentType: {
    contentType: {
      uid: 'plugin::myplugins.post',
      schema: {
        name: 'plugin::myplugins.post',
        kind: 'collectionType',
        attributes: [
          {
            relation: 'oneToMany',
            targetAttribute: null,
            type: 'relation',
            target: 'user',
            name: 'user',
          },
          { type: 'string', name: 'title' },
        ],
      },
    },
  },
};
</file>

<file path="admin/src/components/FormModal/utils/canEditContentType.ts">
import get from 'lodash/get';

import { getRelationType } from '../../../utils/getRelationType';

import type { AttributeType } from '../../../types';
import type { Internal, Struct } from '@strapi/types';

export type EditableContentTypeSchema = {
  kind: Struct.ContentTypeKind;
  name: string;
  attributes: AttributeType[];
};

export type EditableContentTypeData = {
  contentType: {
    uid: Internal.UID.ContentType;
    schema: EditableContentTypeSchema;
  };
};

type ModifiedData = {
  kind: Struct.ContentTypeKind;
};

export const canEditContentType = (data: Record<string, any>, modifiedData: ModifiedData) => {
  const kind = get(data, ['contentType', 'schema', 'kind'], '');

  // if kind isn't modified or content type is a single type, there is no need to check attributes.
  if (kind === 'singleType' || kind === modifiedData.kind) {
    return true;
  }

  const contentTypeAttributes = get(
    data,
    ['contentType', 'schema', 'attributes'],
    []
  ) as AttributeType[];

  const relationAttributes = contentTypeAttributes.filter(({ relation, type, targetAttribute }) => {
    const relationType = getRelationType(relation, targetAttribute);

    return type === 'relation' && !['oneWay', 'manyWay'].includes(relationType || '');
  });

  return relationAttributes.length === 0;
};
</file>

<file path="admin/src/components/FormModal/utils/createUid.ts">
import { nameToSlug } from '../../../utils/nameToSlug';

import type { Internal } from '@strapi/types';

const createUid = (name: string): Internal.UID.ContentType => {
  const modelName = nameToSlug(name);
  return `api::${modelName}.${modelName}`;
};

// From `content-type-builder/services/Components/createComponentUid`
const createComponentUid = (name: string, category: string): Internal.UID.Component => {
  return `${nameToSlug(category)}.${nameToSlug(name)}`;
};

export { createComponentUid, createUid };
</file>

<file path="admin/src/components/FormModal/utils/customFieldDefaultOptionsReducer.ts">
export const customFieldDefaultOptionsReducer = (acc: any, option: any) => {
  if (option.items) {
    return option.items.reduce(customFieldDefaultOptionsReducer, acc);
  }

  if ('defaultValue' in option) {
    const { name, defaultValue } = option;
    acc.push({ name, defaultValue });
  }

  return acc;
};
</file>

<file path="admin/src/components/FormModal/utils/getAttributesToDisplay.ts">
import { MAX_COMPONENT_DEPTH } from '../../../constants';
import { getComponentDepth } from '../../../utils/getMaxDepth';

import type { IconByType } from '../../AttributeIcon';
import type { NestedComponent } from '../../DataManagerProvider/utils/retrieveNestedComponents';
import type { Internal } from '@strapi/types';

export const getAttributesToDisplay = (
  dataTarget = '',
  targetUid: Internal.UID.Schema,
  nestedComponents: Array<NestedComponent>
): IconByType[][] => {
  const defaultAttributes: IconByType[] = [
    'text',
    'boolean',
    'blocks',
    'json',
    'number',
    'email',
    'date',
    'password',
    'media',
    'enumeration',
    'relation',
    'richtext',
  ];

  const isPickingAttributeForAContentType = dataTarget === 'contentType';

  if (isPickingAttributeForAContentType) {
    return [
      // Insert UID before the last item (richtext)
      [...defaultAttributes.slice(0, -1), 'uid', ...defaultAttributes.slice(-1)],
      ['component', 'dynamiczone'],
    ];
  }

  // this will only run when adding attributes to components
  if (dataTarget) {
    const componentDepth = getComponentDepth(targetUid, nestedComponents);
    const isNestedInAnotherComponent = componentDepth >= MAX_COMPONENT_DEPTH;
    const canAddComponentInAnotherComponent =
      !isPickingAttributeForAContentType && !isNestedInAnotherComponent;
    if (canAddComponentInAnotherComponent) {
      return [defaultAttributes, ['component']];
    }
  }

  return [defaultAttributes];
};
</file>

<file path="admin/src/components/FormModal/utils/getFormInputNames.ts">
export const getFormInputNames = (form: any) =>
  form.reduce((acc: any, current: any) => {
    const names = current.items.reduce((acc: any, current: any) => {
      if (current.name) {
        acc.push(current.name);
      }

      return acc;
    }, []);

    return [...acc, ...names];
  }, []);
</file>

<file path="admin/src/components/FormModal/utils/relations.ts">
/* eslint-disable no-confusing-arrow */

import type { Schema } from '@strapi/types';

const shouldPluralizeName = (nature: Schema.Attribute.RelationKind.Any) =>
  ['manyToMany', 'oneToMany', 'manyWay'].includes(nature) ? 2 : 1;

const shouldPluralizeTargetAttribute = (nature: Schema.Attribute.RelationKind.Any) =>
  ['manyToMany', 'manyToOne'].includes(nature) ? 2 : 1;

export { shouldPluralizeName, shouldPluralizeTargetAttribute };
</file>

<file path="admin/src/components/FormModal/constants.ts">
export const ON_CHANGE = 'ContentTypeBuilder/FormModal/ON_CHANGE';
export const ON_CHANGE_RELATION_TARGET = 'ContentTypeBuilder/FormModal/ON_CHANGE_RELATION_TARGET';
export const ON_CHANGE_RELATION_TYPE = 'ContentTypeBuilder/FormModal/ON_CHANGE_RELATION_TYPE';
export const RESET_PROPS = 'ContentTypeBuilder/FormModal/RESET_PROPS';
export const RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO =
  'ContentTypeBuilder/FormModal/RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO';
export const RESET_PROPS_AND_SAVE_CURRENT_DATA =
  'ContentTypeBuilder/FormModal/RESET_PROPS_AND_SAVE_CURRENT_DATA';
export const RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ =
  'ContentTypeBuilder/FormModal/RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ';
export const SET_DATA_TO_EDIT = 'ContentTypeBuilder/FormModal/SET_DATA_TO_EDIT';
export const SET_ATTRIBUTE_DATA_SCHEMA = 'ContentTypeBuilder/FormModal/SET_ATTRIBUTE_DATA_SCHEMA';
export const SET_CUSTOM_FIELD_DATA_SCHEMA =
  'ContentTypeBuilder/FormModal/SET_CUSTOM_FIELD_DATA_SCHEMA';
export const SET_DYNAMIC_ZONE_DATA_SCHEMA =
  'ContentTypeBuilder/FormModal/SET_DYNAMIC_ZONE_DATA_SCHEMA';
export const SET_ERRORS = 'ContentTypeBuilder/FormModal/SET_ERRORS';
</file>

<file path="admin/src/components/FormModal/dynamiczoneForm.ts">
import { getTrad } from '../../utils/getTrad';

import { componentField } from './component/componentField';
import { componentForm } from './component/componentForm';

export const dynamiczoneForm = {
  advanced: {
    default() {
      return {
        sections: componentForm.advanced(),
      };
    },
  },
  base: {
    createComponent() {
      return {
        sections: [
          { sectionTitle: null, items: [componentField] },
          ...componentForm.base('componentToCreate.'),
        ],
      };
    },
    default() {
      return {
        sections: [
          { sectionTitle: null, items: [componentField] },
          {
            sectionTitle: null,
            items: [
              {
                type: 'pushRight',
                size: 6,
                intlLabel: { id: '', defaultMessage: '' },
                name: 'pushRight',
              },
              {
                name: 'components',
                type: 'select-components',
                intlLabel: {
                  id: getTrad('modalForm.attributes.select-components'),
                  defaultMessage: 'Select the components',
                },
                isMultiple: true,
              },
            ],
          },
        ],
      };
    },
  },
};
</file>

<file path="admin/src/components/FormModal/reducer.ts">
import { produce } from 'immer';
import set from 'lodash/set';
import snakeCase from 'lodash/snakeCase';
import pluralize from 'pluralize';

import { getRelationType } from '../../utils/getRelationType';
import { nameToSlug } from '../../utils/nameToSlug';

import * as actions from './constants';
import { createComponentUid } from './utils/createUid';
import { customFieldDefaultOptionsReducer } from './utils/customFieldDefaultOptionsReducer';
import { shouldPluralizeName, shouldPluralizeTargetAttribute } from './utils/relations';

import type { AnyAction } from '@reduxjs/toolkit';

const initialState: any = {
  formErrors: {},
  modifiedData: {},
  initialData: {},
  componentToCreate: {},
  isCreatingComponentWhileAddingAField: false,
};

const reducer = (state = initialState, action: AnyAction) =>
  // eslint-disable-next-line consistent-return
  produce(state, (draftState: any) => {
    switch (action.type) {
      case actions.ON_CHANGE: {
        const { keys, value } = action;
        const obj = state.modifiedData;
        const hasDefaultValue = Boolean(obj.default);

        // There is no need to remove the default key if the default value isn't defined
        if (hasDefaultValue && keys.length === 1 && keys.includes('type')) {
          const previousType = obj.type;

          if (previousType && ['date', 'datetime', 'time'].includes(previousType)) {
            // return obj.updateIn(keys, () => value).remove('default');
            delete draftState.modifiedData.default;
          }
        }

        set(draftState, ['modifiedData', ...keys], value);

        break;
      }
      case actions.ON_CHANGE_RELATION_TARGET: {
        const {
          target: {
            oneThatIsCreatingARelationWithAnother,
            selectedContentTypeFriendlyName,
            targetContentTypeAllowedRelations,
            value,
          },
        } = action;
        // Special case for the admin user...
        let didChangeRelationTypeBecauseOfRestrictedRelation = false;
        let changedRelationType = null;

        set(draftState, ['modifiedData', 'target'], value);

        const modifiedData = state.modifiedData;

        // Don't change the relation type if the allowed relations are not restricted
        // TODO: replace with an obj { relation: 'x', bidirctional: true|false } when BE ready
        if (Array.isArray(targetContentTypeAllowedRelations)) {
          const currentRelationType = getRelationType(
            modifiedData.relation,
            modifiedData.targetAttribute
          );

          if (!targetContentTypeAllowedRelations.includes(currentRelationType)) {
            const relationToSet = targetContentTypeAllowedRelations[0];
            didChangeRelationTypeBecauseOfRestrictedRelation = true;
            changedRelationType = relationToSet;

            if (relationToSet === 'oneWay') {
              set(draftState, ['modifiedData', 'relation'], 'oneToOne');
            } else if (relationToSet === 'manyWay') {
              set(draftState, ['modifiedData', 'relation'], 'oneToMany');
            } else {
              set(draftState, ['modifiedData', 'relation'], relationToSet);
            }
          }
        }

        let nameToSet;

        if (didChangeRelationTypeBecauseOfRestrictedRelation) {
          nameToSet = pluralize(
            snakeCase(nameToSlug(selectedContentTypeFriendlyName)),
            shouldPluralizeName(changedRelationType)
          );
        } else {
          nameToSet = pluralize(
            snakeCase(nameToSlug(selectedContentTypeFriendlyName)),

            shouldPluralizeName(modifiedData.relation)
          );
        }

        set(draftState, ['modifiedData', 'name'], nameToSet);

        const currentTargetAttribute = state.modifiedData.targetAttribute;

        if (currentTargetAttribute === null) {
          break;
        }

        // Changing the target and the relation is either oneWay or manyWay
        // Case when we need to change the relation to oneWay (ex: admin user)
        if (
          didChangeRelationTypeBecauseOfRestrictedRelation &&
          ['oneWay', 'manyWay'].includes(changedRelationType)
        ) {
          set(draftState, ['modifiedData', 'targetAttribute'], null);

          break;
        }

        const targetAttributeToSet = pluralize(
          snakeCase(nameToSlug(oneThatIsCreatingARelationWithAnother)),
          shouldPluralizeTargetAttribute(modifiedData.relation)
        );

        set(draftState, ['modifiedData', 'targetAttribute'], targetAttributeToSet);

        break;
      }
      case actions.ON_CHANGE_RELATION_TYPE: {
        const {
          target: { oneThatIsCreatingARelationWithAnother, value },
        } = action;

        const currentName = state.modifiedData.name;

        // Switching from oneWay
        if (!['oneWay', 'manyWay'].includes(value)) {
          set(draftState, ['modifiedData', 'relation'], value);
          const currentTargetAttribute = state.modifiedData.targetAttribute;

          set(
            draftState,
            ['modifiedData', 'name'],
            pluralize(snakeCase(nameToSlug(currentName)), shouldPluralizeName(value))
          );

          set(
            draftState,
            ['modifiedData', 'targetAttribute'],
            pluralize(
              currentTargetAttribute ||
                snakeCase(nameToSlug(oneThatIsCreatingARelationWithAnother)),
              shouldPluralizeTargetAttribute(value)
            )
          );

          break;
        }

        if (value === 'oneWay') {
          set(draftState, ['modifiedData', 'relation'], 'oneToOne');
          set(draftState, ['modifiedData', 'targetAttribute'], null);
          set(draftState, ['modifiedData', 'name'], pluralize(snakeCase(currentName), 1));

          break;
        }

        // manyWay
        set(draftState, ['modifiedData', 'relation'], 'oneToMany');
        set(draftState, ['modifiedData', 'targetAttribute'], null);
        set(draftState, ['modifiedData', 'name'], pluralize(snakeCase(currentName), 2));

        break;
      }

      case actions.RESET_PROPS:
        return initialState;
      case actions.RESET_PROPS_AND_SET_FORM_FOR_ADDING_AN_EXISTING_COMPO: {
        // This is run when the user doesn't want to create a new component

        const nextState = {
          ...initialState,
          modifiedData: {
            type: 'component',
            repeatable: true,
            ...action.options,
          },
        };

        return nextState;
      }
      case actions.RESET_PROPS_AND_SAVE_CURRENT_DATA: {
        // This is run when the user has created a new component
        const componentToCreate = state.modifiedData.componentToCreate;
        const modifiedData = {
          displayName: componentToCreate.displayName,
          type: 'component',
          repeatable: false,
          ...action.options,
          component: createComponentUid(componentToCreate.displayName, componentToCreate.category),
        };

        const nextState = {
          ...initialState,
          componentToCreate,
          modifiedData,
          isCreatingComponentWhileAddingAField: state.modifiedData.createComponent,
        };

        return nextState;
      }
      case actions.RESET_PROPS_AND_SET_THE_FORM_FOR_ADDING_A_COMPO_TO_A_DZ: {
        const createdDZ = state.modifiedData;
        const dataToSet = {
          ...createdDZ,
          createComponent: true,
          componentToCreate: { type: 'component' },
        };

        return { ...initialState, modifiedData: dataToSet };
      }
      case actions.SET_DATA_TO_EDIT: {
        draftState.modifiedData = action.data;
        draftState.initialData = action.data;
        break;
      }
      case actions.SET_ATTRIBUTE_DATA_SCHEMA: {
        const {
          attributeType,
          isEditing,
          modifiedDataToSetForEditing,
          nameToSetForRelation,
          targetUid,
          step,
          options = {},
        } = action;

        if (isEditing) {
          draftState.modifiedData = modifiedDataToSetForEditing;
          draftState.initialData = modifiedDataToSetForEditing;

          break;
        }

        let dataToSet;

        if (attributeType === 'component') {
          if (step === '1') {
            dataToSet = {
              type: 'component',
              createComponent: true,
              componentToCreate: { type: 'component' },
            };
          } else {
            dataToSet = {
              ...options,
              type: 'component',
              repeatable: true,
            };
          }
        } else if (attributeType === 'dynamiczone') {
          dataToSet = {
            ...options,
            type: 'dynamiczone',
            components: [],
          };
        } else if (attributeType === 'text') {
          dataToSet = { ...options, type: 'string' };
        } else if (attributeType === 'number' || attributeType === 'date') {
          dataToSet = options;
        } else if (attributeType === 'media') {
          dataToSet = {
            allowedTypes: ['images', 'files', 'videos', 'audios'],
            type: 'media',
            multiple: true,
            ...options,
          };
        } else if (attributeType === 'enumeration') {
          dataToSet = { ...options, type: 'enumeration', enum: [] };
        } else if (attributeType === 'relation') {
          dataToSet = {
            name: snakeCase(nameToSetForRelation),
            relation: 'oneToOne',
            targetAttribute: null,
            target: targetUid,
            type: 'relation',
          };
        } else {
          dataToSet = { ...options, type: attributeType, default: null };
        }

        draftState.modifiedData = dataToSet;

        break;
      }
      case actions.SET_CUSTOM_FIELD_DATA_SCHEMA: {
        const { customField, isEditing, modifiedDataToSetForEditing, options = {} } = action;

        if (isEditing) {
          draftState.modifiedData = modifiedDataToSetForEditing;
          draftState.initialData = modifiedDataToSetForEditing;

          break;
        }

        draftState.modifiedData = { ...options, type: customField.type };

        const allOptions = [
          ...(customField?.options?.base || []),
          ...(customField?.options?.advanced || []),
        ];

        const optionDefaults = allOptions.reduce(customFieldDefaultOptionsReducer, []);

        if (optionDefaults.length) {
          optionDefaults.forEach(({ name, defaultValue }: { name: string; defaultValue: string }) =>
            set(draftState.modifiedData, name, defaultValue)
          );
        }

        break;
      }
      case actions.SET_DYNAMIC_ZONE_DATA_SCHEMA: {
        draftState.modifiedData = action.attributeToEdit;
        draftState.initialData = action.attributeToEdit;
        break;
      }
      case actions.SET_ERRORS: {
        draftState.formErrors = action.errors;
        break;
      }
      default:
        return draftState;
    }
  });

export { initialState, reducer };
</file>

<file path="admin/src/components/FormModal/selectors.ts">
import { createSelector } from '@reduxjs/toolkit';

import { pluginId } from '../../pluginId';

import { initialState } from './reducer';

/**
 * Direct selector to the formModal state domain
 */
const formModalDomain = () => (state: any) => state[`${pluginId}_formModal`] || initialState;

/**
 * Other specific selectors
 */

/**
 * Default selector used by formModal
 */

export const makeSelectFormModal = () =>
  createSelector(formModalDomain(), (substate) => {
    return substate;
  });

export { formModalDomain };
</file>

<file path="admin/src/components/FormModalNavigationProvider/tests/formModalNavigationProvider.test.ts">
import { act, renderHook } from '@testing-library/react';

import { useFormModalNavigation } from '../../../hooks/useFormModalNavigation';
import { INITIAL_STATE_DATA } from '../constants';
import { FormModalNavigationProvider, State } from '../FormModalNavigationProvider';

const removeFunctionsFromObject = (state: State) => {
  const stringified = JSON.stringify(state);
  const parsed = JSON.parse(stringified);

  return parsed;
};

describe('FromModalNavigationProvider', () => {
  it('sets the initial state', () => {
    const { result } = renderHook(() => useFormModalNavigation(), {
      wrapper: FormModalNavigationProvider,
    });

    const currentStateWithoutFunctions = removeFunctionsFromObject(result.current);
    expect(currentStateWithoutFunctions).toEqual(INITIAL_STATE_DATA);
  });

  it('updates the state when selecting a custom field for a new attribute', () => {
    const { result } = renderHook(() => useFormModalNavigation(), {
      wrapper: FormModalNavigationProvider,
    });

    act(() => {
      (result.current as any).onClickSelectCustomField({
        attributeType: 'text',
        customFieldUid: 'plugin::mycustomfields.color',
      });
    });

    const currentStateWithoutFunctions = removeFunctionsFromObject(result.current);
    const expected = {
      ...INITIAL_STATE_DATA,
      actionType: 'create',
      modalType: 'customField',
      attributeType: 'text',
      customFieldUid: 'plugin::mycustomfields.color',
    };

    expect(currentStateWithoutFunctions).toEqual(expected);
  });

  it('updates the state when editing a custom field attribute', () => {
    const { result } = renderHook(() => useFormModalNavigation(), {
      wrapper: FormModalNavigationProvider,
    });

    act(() => {
      (result.current as any).onOpenModalEditCustomField({
        forTarget: 'contentType',
        targetUid: 'api::test.test',
        attributeName: 'color',
        attributeType: 'text',
        customFieldUid: 'plugin::mycustomfields.color',
      });
    });

    const currentStateWithoutFunctions = removeFunctionsFromObject(result.current);
    const expected = {
      ...INITIAL_STATE_DATA,
      isOpen: true,
      modalType: 'customField',
      actionType: 'edit',
      forTarget: 'contentType',
      targetUid: 'api::test.test',
      attributeName: 'color',
      attributeType: 'text',
      customFieldUid: 'plugin::mycustomfields.color',
    };

    expect(currentStateWithoutFunctions).toEqual(expected);
  });
});
</file>

<file path="admin/src/components/FormModalNavigationProvider/tests/index.test.ts">
import { act, renderHook } from '@testing-library/react';

import { useFormModalNavigation } from '../../../hooks/useFormModalNavigation';
import { INITIAL_STATE_DATA } from '../constants';
import { FormModalNavigationProvider, State } from '../FormModalNavigationProvider';

const removeFunctionsFromObject = (state: State) => {
  const stringified = JSON.stringify(state);
  const parsed = JSON.parse(stringified);

  return parsed;
};

describe('FromModalNavigationProvider', () => {
  it('sets the initial state', () => {
    const { result } = renderHook(() => useFormModalNavigation(), {
      wrapper: FormModalNavigationProvider,
    });

    const currentStateWithoutFunctions = removeFunctionsFromObject(result.current);

    expect(currentStateWithoutFunctions).toEqual(INITIAL_STATE_DATA);
  });

  it('updates the state when selecting a custom field for a new attribute', () => {
    const { result } = renderHook(() => useFormModalNavigation(), {
      wrapper: FormModalNavigationProvider,
    });

    act(() => {
      (result.current as any).onClickSelectCustomField({
        attributeType: 'text',
        customFieldUid: 'plugin::mycustomfields.color',
      });
    });

    const currentStateWithoutFunctions = removeFunctionsFromObject(result.current);
    const expected = {
      ...INITIAL_STATE_DATA,
      actionType: 'create',
      modalType: 'customField',
      attributeType: 'text',
      customFieldUid: 'plugin::mycustomfields.color',
    };

    expect(currentStateWithoutFunctions).toEqual(expected);
  });

  it('updates the state when editing a custom field attribute', () => {
    const { result } = renderHook(() => useFormModalNavigation(), {
      wrapper: FormModalNavigationProvider,
    });

    act(() => {
      (result.current as any).onOpenModalEditCustomField({
        forTarget: 'contentType',
        targetUid: 'api::test.test',
        attributeName: 'color',
        attributeType: 'text',
        customFieldUid: 'plugin::mycustomfields.color',
      });
    });

    const currentStateWithoutFunctions = removeFunctionsFromObject(result.current);
    const expected = {
      ...INITIAL_STATE_DATA,
      isOpen: true,
      modalType: 'customField',
      actionType: 'edit',
      forTarget: 'contentType',
      targetUid: 'api::test.test',
      attributeName: 'color',
      attributeType: 'text',
      customFieldUid: 'plugin::mycustomfields.color',
    };

    expect(currentStateWithoutFunctions).toEqual(expected);
  });
});
</file>

<file path="admin/src/components/FormModalNavigationProvider/constants.ts">
const INITIAL_STATE_DATA = {
  actionType: null,
  attributeName: null,
  attributeType: null,
  categoryName: null,
  dynamicZoneTarget: null,
  forTarget: null,
  modalType: null,
  isOpen: false,
  showBackLink: false,
  kind: null,
  step: null,
  targetUid: null,
  customFieldUid: null,
  activeTab: 'basic',
};

export { INITIAL_STATE_DATA };
</file>

<file path="admin/src/components/IconPicker/constants.ts">
import * as Icons from '@strapi/icons';
import * as Symbols from '@strapi/icons/symbols';

export type Icon = (typeof Icons)[keyof typeof Icons] | (typeof Symbols)[keyof typeof Symbols];

const COMPONENT_ICONS: Record<string, Icon> = {
  alien: Icons.Alien,
  apps: Icons.GridNine,
  archive: Icons.Archive,
  arrowDown: Icons.ArrowDown,
  arrowLeft: Icons.ArrowLeft,
  arrowRight: Icons.ArrowRight,
  arrowUp: Icons.ArrowUp,
  attachment: Icons.Paperclip,
  bell: Icons.Bell,
  bold: Icons.Bold,
  book: Icons.Book,
  briefcase: Icons.Briefcase,
  brush: Icons.PaintBrush,
  bulletList: Icons.BulletList,
  calendar: Icons.Calendar,
  car: Icons.Car,
  cast: Icons.Cast,
  chartBubble: Icons.ChartBubble,
  chartCircle: Icons.ChartCircle,
  chartPie: Icons.ChartPie,
  check: Icons.Check,
  clock: Icons.Clock,
  cloud: Icons.Cloud,
  code: Icons.Code,
  cog: Icons.Cog,
  collapse: Icons.Collapse,
  command: Icons.Command,
  connector: Icons.Faders,
  crop: Icons.Crop,
  crown: Icons.Crown,
  cup: Icons.Coffee,
  cursor: Icons.Cursor,
  dashboard: Icons.SquaresFour,
  database: Icons.Database,
  discuss: Icons.Discuss,
  doctor: Icons.Stethoscope,
  earth: Icons.Earth,
  emotionHappy: Icons.EmotionHappy,
  emotionUnhappy: Icons.EmotionUnhappy,
  envelop: Icons.Mail,
  exit: Icons.SignOut,
  expand: Icons.Expand,
  eye: Icons.Eye,
  feather: Icons.Feather,
  file: Icons.File,
  fileError: Icons.FileError,
  filePdf: Icons.FilePdf,
  filter: Icons.Filter,
  folder: Icons.Folder,
  gate: Icons.CastleTurret,
  gift: Icons.Gift,
  globe: Icons.Globe,
  grid: Icons.GridFour,
  handHeart: Icons.HandHeart,
  hashtag: Icons.Hashtag,
  headphone: Icons.Headphones,
  heart: Icons.Heart,
  house: Icons.House,
  information: Icons.Information,
  italic: Icons.Italic,
  key: Icons.Key,
  landscape: Icons.Images,
  layer: Icons.ListPlus,
  layout: Icons.Layout,
  lightbulb: Icons.Lightbulb,
  link: Icons.Link,
  lock: Icons.Lock,
  magic: Icons.Magic,
  manyToMany: Icons.ManyToMany,
  manyToOne: Icons.ManyToOne,
  manyWays: Icons.ManyWays,
  medium: Symbols.Medium,
  message: Icons.Message,
  microphone: Icons.Microphone,
  monitor: Icons.Monitor,
  moon: Icons.Moon,
  music: Icons.MusicNotes,
  oneToMany: Icons.OneToMany,
  oneToOne: Icons.OneToOne,
  oneWay: Icons.OneWay,
  paint: Icons.PaintBrush,
  paintBrush: Icons.PaintBrush,
  paperPlane: Icons.PaperPlane,
  pencil: Icons.Pencil,
  phone: Icons.Phone,
  picture: Icons.Image,
  pin: Icons.Pin,
  pinMap: Icons.PinMap,
  plane: Icons.Plane,
  play: Icons.Play,
  plus: Icons.Plus,
  priceTag: Icons.PriceTag,
  puzzle: Icons.PuzzlePiece,
  question: Icons.Question,
  quote: Icons.Quotes,
  refresh: Icons.ArrowClockwise,
  restaurant: Icons.Restaurant,
  rocket: Icons.Rocket,
  rotate: Icons.ArrowsCounterClockwise,
  scissors: Icons.Scissors,
  search: Icons.Search,
  seed: Icons.Plant,
  server: Icons.Server,
  shield: Icons.Shield,
  shirt: Icons.Shirt,
  shoppingCart: Icons.ShoppingCart,
  slideshow: Icons.PresentationChart,
  stack: Icons.Stack,
  star: Icons.Star,
  store: Icons.Store,
  strikeThrough: Icons.StrikeThrough,
  sun: Icons.Sun,
  television: Icons.Television,
  thumbDown: Icons.ThumbDown,
  thumbUp: Icons.ThumbUp,
  train: Icons.Train,
  twitter: Symbols.X,
  typhoon: Icons.Typhoon,
  underline: Icons.Underline,
  user: Icons.User,
  volumeMute: Icons.VolumeMute,
  volumeUp: Icons.VolumeUp,
  walk: Icons.Walk,
  wheelchair: Icons.Wheelchair,
  write: Icons.Feather,
};

export { COMPONENT_ICONS };
</file>

<file path="admin/src/components/IconPicker/index.ts">
/* eslint-disable check-file/no-index */
export * from './IconPicker';
</file>

<file path="admin/src/contexts/DataManagerContext.ts">
/* eslint-disable check-file/filename-naming-convention */
import { createContext } from 'react';

import type { SchemaType, Component } from '../types';
import type { Internal } from '@strapi/types';

// TODO V5 Convert this any types to real types
export interface CustomFieldAttributeParams {
  attributeToSet: Record<string, any>;
  forTarget: SchemaType;
  targetUid: Internal.UID.Schema;
  initialAttribute: Record<string, any>;
}
export interface DataManagerContextValue {
  addAttribute: (
    attributeToSet: Record<string, any>,
    forTarget: SchemaType,
    targetUid: Internal.UID.Schema,
    isEditing?: boolean,
    initialAttribute?: Record<string, any>,
    shouldAddComponentToData?: boolean
  ) => void;
  addCustomFieldAttribute: (params: CustomFieldAttributeParams) => void;
  editCustomFieldAttribute: (params: CustomFieldAttributeParams) => void;
  addCreatedComponentToDynamicZone: (dynamicZoneTarget: string, componentsToAdd: string[]) => void;
  createSchema: (
    data: Record<string, any>,
    schemaType: SchemaType,
    uid: Internal.UID.Schema,
    componentCategory?: string,
    shouldAddComponentToData?: boolean
  ) => void;
  changeDynamicZoneComponents: (dynamicZoneTarget: string, newComponents: string[]) => void;
  removeAttribute: (
    mainDataKey: string,
    attributeToRemoveName: string,
    componentUid?: string
  ) => void;
  deleteCategory: (categoryUid: string) => void;
  deleteData: () => void;
  editCategory: (categoryUid: string, body: any) => void;
  removeComponentFromDynamicZone: (dzName: string, componentToRemoveIndex: number) => void;
  setModifiedData: () => void;
  sortedContentTypesList: any[]; // Define the actual type
  submitData: (additionalContentTypeData?: Record<string, any>) => Promise<void>;
  updateSchema: (
    data: Record<string, any>,
    schemaType: SchemaType,
    componentUID: Internal.UID.Component
  ) => void;
  components: Record<Internal.UID.Component, Component>;
  componentsGroupedByCategory: Record<string, Component[]>;
  componentsThatHaveOtherComponentInTheirAttributes: any[]; // Define the actual type
  contentTypes: Record<string, any>;
  initialData: Record<string, any>;
  isInContentTypeView: boolean;
  isInDevelopmentMode?: boolean;
  modifiedData: Record<string, any>;
  nestedComponents: any[]; // Define the actual type
  reservedNames: {
    models: string[];
    attributes: string[];
  };
  allComponentsCategories: any[];
}

// @ts-expect-error need to pass initial value to params
export const DataManagerContext = createContext<DataManagerContextValue>();
</file>

<file path="admin/src/contexts/FormModalNavigationContext.ts">
/* eslint-disable check-file/filename-naming-convention */
import * as React from 'react';

import { INITIAL_STATE_DATA } from '../components/FormModalNavigationProvider/constants';

import type {
  ModalEventProps,
  State,
} from '../components/FormModalNavigationProvider/FormModalNavigationProvider';
import type { SchemaType } from '../types';
import type { Internal } from '@strapi/types';

export interface FormModalNavigationContextValue {
  onCloseModal: () => void;
  onOpenModalAddField: (options: {
    forTarget: SchemaType;
    targetUid?: Internal.UID.Schema;
  }) => void;
  onClickSelectField: (option: ModalEventProps) => void;
  onClickSelectCustomField: (option: ModalEventProps) => void;
  onNavigateToChooseAttributeModal: (options: ModalEventProps) => void;
  onNavigateToAddCompoToDZModal: (options: ModalEventProps) => void;
  onOpenModalAddComponentsToDZ: (options: ModalEventProps) => void;
  onNavigateToCreateComponentStep2: () => void;
  onOpenModalCreateSchema: (options: State) => void;
  onOpenModalEditCategory: (categoryName: string) => void;
  onOpenModalEditField: (options: ModalEventProps) => void;
  onOpenModalEditCustomField: (options: ModalEventProps) => void;
  onOpenModalEditSchema: (options: ModalEventProps) => void;
  setFormModalNavigationState: (value: React.SetStateAction<typeof INITIAL_STATE_DATA>) => void;
  actionType: string;
  attributeName: string;
  attributeType: string;
  customFieldUid: string;
  categoryName: string;
  dynamicZoneTarget: string;
  forTarget: SchemaType;
  modalType: string;
  isOpen: boolean;
  showBackLink: boolean;
  kind: string;
  step: string;
  targetUid: Internal.UID.Schema;
  activeTab: string;
  setActiveTab: (value: React.SetStateAction<string>) => void;
}

// @ts-expect-error need to pass initial value to params
export const FormModalNavigationContext = React.createContext<FormModalNavigationContextValue>();
</file>

<file path="admin/src/hooks/useDataManager.ts">
import { useContext } from 'react';

import { DataManagerContext } from '../contexts/DataManagerContext';

export const useDataManager = () => useContext(DataManagerContext);
</file>

<file path="admin/src/hooks/useFormModalNavigation.ts">
import { useContext } from 'react';

import { FormModalNavigationContext } from '../contexts/FormModalNavigationContext';

export const useFormModalNavigation = () => useContext(FormModalNavigationContext);
</file>

<file path="admin/src/translations/tests/plural.test.ts">
import translations from '../en.json';

describe('translations', () => {
  describe('plural syntax', () => {
    it('should avoid .plural/.singular syntax', () => {
      Object.keys(translations).forEach((translationKey) => {
        const keyParts = translationKey.split('.');
        const lastKeyPart = keyParts.pop();

        // Skip if the key cannot be splitted
        // Fail only if a PAIR of .singular/.plural keys is found
        if (keyParts.length > 1 && lastKeyPart === 'singular') {
          keyParts.push('plural');
          const pluralKey = keyParts.join('.') as keyof typeof translations;

          expect(translations[pluralKey]).toBeUndefined();
        }
      });
    });
  });
});
</file>

<file path="admin/src/utils/tests/formAPI.test.ts">
import * as yup from 'yup';

import { formsAPI } from '../formAPI';

describe('formsAPI', () => {
  describe('makeValidator', () => {
    it('verifies the validity of a schema', () => {
      // Arrange
      const initShape = yup.object();
      const types = {
        types: {
          contentType: {
            validators: [() => ({ i18n: yup.string().required(), other: yup.number().required() })],
          },
        },
      };
      const target = ['contentType'];

      // Act
      const schema = formsAPI.makeValidator.bind(types)(target, initShape, [
        'api::country.country',
      ]);

      // Assert
      expect(() =>
        schema.validateSync({
          pluginOptions: {},
        })
      ).toThrow('pluginOptions.other is a required field');

      expect(() =>
        schema.validateSync({
          pluginOptions: {
            other: 'string, not number',
          },
        })
      ).toThrow(
        'pluginOptions.other must be a `number` type, but the final value was: `NaN` (cast from the value `"string, not number"`).'
      );

      expect(() =>
        schema.validateSync({
          pluginOptions: {
            other: 1,
            i18n: 'valid',
          },
        })
      ).not.toThrow();
    });
  });

  describe('mutateContentTypeSchema', () => {
    it('should call the mutation with the correct arguments', () => {
      const mutation = jest.fn((data) => data);
      formsAPI.addContentTypeSchemaMutation(mutation);

      expect(formsAPI.contentTypeSchemaMutations).toHaveLength(1);

      const returnedData = formsAPI.mutateContentTypeSchema({ ok: true }, { ok: false });

      expect(mutation).toHaveBeenCalledWith({ ok: true }, { ok: false });
      expect(returnedData).toEqual({ ok: true });
    });
  });
});
</file>

<file path="admin/src/utils/tests/getMaxDepth.test.ts">
import { getChildrenMaxDepth, getComponentDepth } from '../getMaxDepth';

import type { ComponentWithChildren } from '../../components/DataManagerProvider/utils/retrieveComponentsThatHaveComponents';
import type { NestedComponent } from '../../components/DataManagerProvider/utils/retrieveNestedComponents';

const componentsWithChildComponents: Array<ComponentWithChildren> = [
  {
    component: 'basic.parent-compo',
    childComponents: [
      {
        component: 'basic.nested-compo1',
      },
    ],
  },
  {
    component: 'basic.nested-compo5',
    childComponents: [
      {
        component: 'basic.nested-compo6',
      },
    ],
  },
  {
    component: 'basic.nested-compo4',
    childComponents: [
      {
        component: 'basic.nested-compo5',
      },
    ],
  },
  {
    component: 'basic.nested-compo3',
    childComponents: [
      {
        component: 'basic.nested-compo4',
      },
    ],
  },
  {
    component: 'basic.nested-compo2',
    childComponents: [
      {
        component: 'basic.nested-compo3',
      },
    ],
  },
  {
    component: 'basic.nested-compo1',
    childComponents: [
      {
        component: 'basic.nested-compo2',
      },
    ],
  },
  {
    component: 'basic.another-parent-compo',
    childComponents: [
      {
        component: 'basic.nested-compo6',
      },
    ],
  },
  {
    component: 'default.openingtimes',
    childComponents: [
      {
        component: 'default.dish',
      },
      {
        component: 'basic.nested-compo3',
      },
    ],
  },
  {
    component: 'default.closingperiod',
    childComponents: [
      {
        component: 'default.dish',
      },
    ],
  },
];

const nestedComponents: Array<NestedComponent> = [
  {
    component: 'default.dish',
    uidsOfAllParents: ['default.openingtimes', 'default.closingperiod'],
  },
  {
    component: 'basic.nested-compo1',
    uidsOfAllParents: ['basic.parent-compo'],
  },
  {
    component: 'basic.nested-compo6',
    uidsOfAllParents: ['basic.nested-compo5', 'basic.another-parent-compo'],
  },
  {
    component: 'basic.nested-compo5',
    uidsOfAllParents: ['basic.nested-compo4'],
  },
  {
    component: 'basic.nested-compo4',
    uidsOfAllParents: ['basic.nested-compo3'],
  },
  {
    component: 'basic.nested-compo3',
    uidsOfAllParents: ['basic.nested-compo2'],
  },
  {
    component: 'basic.nested-compo2',
    uidsOfAllParents: ['basic.nested-compo1'],
  },
];

describe('Component Depth Calculations', () => {
  describe('getMaxDepth', () => {
    it('A component with no child component should have 0 max depth', () => {
      const componentsMaxDepth = getChildrenMaxDepth(
        'basic.nested-compo6',
        componentsWithChildComponents
      );

      expect(componentsMaxDepth).toEqual(0);
    });

    it('should accurately give the max depth of components children', () => {
      const componentsMaxDepth = getChildrenMaxDepth(
        'default.openingtimes',
        componentsWithChildComponents
      );

      expect(componentsMaxDepth).toEqual(4);
    });
  });

  describe('getComponentDepth', () => {
    it('A component depth should reflect its position in the component tree', () => {
      expect(getComponentDepth('basic.nested-compo1', nestedComponents)).toEqual(1);
      expect(getComponentDepth('basic.nested-compo4', nestedComponents)).toEqual(4);
      expect(getComponentDepth('basic.nested-compo6', nestedComponents)).toEqual(6);
    });
  });
});
</file>

<file path="admin/src/utils/tests/getRelationType.test.ts">
/* eslint-disable @typescript-eslint/ban-ts-comment */
import { getRelationType } from '../getRelationType';

describe('CTB | utils | getRelationType', () => {
  it('Should return oneWay', () => {
    const relation = 'oneToOne';

    expect(getRelationType(relation, null)).toEqual('oneWay');
    expect(getRelationType(relation, undefined)).toEqual('oneWay');
  });

  it('Should return manyWay', () => {
    const relation = 'oneToMany';

    expect(getRelationType(relation, null)).toEqual('manyWay');
    expect(getRelationType(relation, undefined)).toEqual('manyWay');
  });

  it('Should return the relation when the target attribute is defined', () => {
    const relation = 'test';
    // @ts-expect-error
    expect(getRelationType(relation, 'test')).toEqual('test');
    // @ts-expect-error
    expect(getRelationType(relation, 'test')).toEqual('test');
  });
});
</file>

<file path="admin/src/utils/tests/getYupInnerErrors.test.ts">
import { ValidationError } from 'yup';

import { getYupInnerErrors } from '../getYupInnerErrors';

describe('getYupInnerErrors', () => {
  test('can extract relevant parameters from an error', () => {
    const maxError = {
      value: { number: 6 },
      name: 'ValidationError',
      message: 'components.Input.error.validation.max',
      errors: ['components.Input.error.validation.max'],
      inner: [
        {
          errors: ['components.Input.error.validation.max'],
          message: 'components.Input.error.validation.max',
          name: 'ValidationError',
          params: { value: 6, originalValue: 6, path: 'number', max: 5 },
          path: 'number',
          type: 'max',
          value: 6,
          inner: [],
        },
      ],
    } satisfies ValidationError;

    expect(getYupInnerErrors(maxError)).toMatchObject({
      number: {
        id: 'components.Input.error.validation.max',
        defaultMessage: 'components.Input.error.validation.max',
        values: { max: 5 },
      },
    });
  });

  test('can extract error messages from multiple errors', () => {
    const multipleErrors = {
      value: { number: 6, json: 'invalid json' },
      name: 'ValidationError',
      message: '2 errors occurred',
      errors: ['components.Input.error.validation.json', 'components.Input.error.validation.max'],
      inner: [
        {
          errors: ['components.Input.error.validation.json'],
          message: 'components.Input.error.validation.json',
          name: 'ValidationError',
          params: { value: 'invalid json', originalValue: 'invalid json', path: 'json' },
          path: 'json',
          type: 'isJSON',
          value: 'invalid json',
          inner: [],
        },
        {
          errors: ['components.Input.error.validation.max'],
          message: 'components.Input.error.validation.max',
          name: 'ValidationError',
          params: { value: 6, originalValue: 6, path: 'number', max: 5 },
          path: 'number',
          type: 'max',
          value: 6,
          inner: [],
        },
      ],
    } satisfies ValidationError;

    expect(getYupInnerErrors(multipleErrors)).toMatchObject({
      json: {
        id: 'components.Input.error.validation.json',
        defaultMessage: 'components.Input.error.validation.json',
        values: {},
      },
      number: {
        id: 'components.Input.error.validation.max',
        defaultMessage: 'components.Input.error.validation.max',
        values: { max: 5 },
      },
    });
  });

  test('can extract errors from dynamic zones errors', () => {
    const dynamicZoneErrors = {
      errors: ['components.Input.error.validation.max'],
      message: 'components.Input.error.validation.max',
      name: 'ValidationError',
      value: {
        dynamicZone: [
          {
            __component: 'component',
            number: 6,
          },
        ],
      },
      inner: [
        {
          errors: ['components.Input.error.validation.max'],
          message: 'components.Input.error.validation.max',
          name: 'ValidationError',
          params: { value: 6, originalValue: 6, path: 'dynamicZone[0].number', max: 5 },
          path: 'dynamicZone[0].number',
          type: 'max',
          value: 6,
          inner: [],
        },
      ],
    } satisfies ValidationError;

    expect(getYupInnerErrors(dynamicZoneErrors)).toMatchObject({
      'dynamicZone.0.number': {
        id: 'components.Input.error.validation.max',
        defaultMessage: 'components.Input.error.validation.max',
        values: { max: 5 },
      },
    });
  });
});
</file>

<file path="admin/src/utils/tests/isAllowedContentTypesForRelations.test.ts">
import { isAllowedContentTypesForRelations } from '../isAllowedContentTypesForRelations';

import type { ContentType } from '../../types';

describe('CTB | utils | isAllowedContentTypesForRelations', () => {
  it('should be falsy if the model is a single type', () => {
    const contentType: ContentType = {
      visible: true,
      name: 'plugin::users-permissions.user',
      title: 'User',
      plugin: 'users-permissions',
      uid: 'plugin::users-permissions.user',
      to: '/plugins/content-type-builder/content-types/plugin::users-permissions.user',
      kind: 'singleType',
      restrictRelationsTo: null,
    };

    expect(isAllowedContentTypesForRelations(contentType)).toBeFalsy();
  });

  it('should be falsy if the restricted relations is an empty array', () => {
    const contentType: ContentType = {
      visible: true,
      name: 'plugin::users-permissions.user',
      title: 'User',
      plugin: 'users-permissions',
      uid: 'plugin::users-permissions.user',
      to: '/plugins/content-type-builder/content-types/plugin::users-permissions.user',
      kind: 'collectionType',
      restrictRelationsTo: [],
    };

    expect(isAllowedContentTypesForRelations(contentType)).toBeFalsy();
  });

  it('should be truthy if the model is a collection type and the restricted relations is null', () => {
    const contentType: ContentType = {
      visible: true,
      name: 'plugin::users-permissions.user',
      title: 'User',
      plugin: 'users-permissions',
      uid: 'plugin::users-permissions.user',
      to: '/plugins/content-type-builder/content-types/plugin::users-permissions.user',
      kind: 'collectionType',
      restrictRelationsTo: null,
    };

    expect(isAllowedContentTypesForRelations(contentType)).toBeTruthy();
  });

  it('should be truthy if the model is a collection type and the restricted relations is not empty array', () => {
    const contentType: ContentType = {
      visible: true,
      name: 'plugin::users-permissions.user',
      title: 'User',
      plugin: 'users-permissions',
      uid: 'plugin::users-permissions.user',
      to: '/plugins/content-type-builder/content-types/plugin::users-permissions.user',
      kind: 'collectionType',
      restrictRelationsTo: ['oneWay', 'manyWay'],
    };

    expect(isAllowedContentTypesForRelations(contentType)).toBeTruthy();
  });

  it('should be falsy if restrictRelationsTo is undefined', () => {
    const contentType: ContentType = {
      visible: true,
      name: 'plugin::users-permissions.user',
      title: 'User',
      plugin: 'users-permissions',
      uid: 'plugin::users-permissions.user',
      to: '/plugins/content-type-builder/content-types/plugin::users-permissions.user',
      kind: 'collectionType',
    };

    expect(isAllowedContentTypesForRelations(contentType)).toBeFalsy();
  });

  it('should be falsy if kind is undefined', () => {
    const contentType: ContentType = {
      visible: true,
      name: 'plugin::users-permissions.user',
      title: 'User',
      plugin: 'users-permissions',
      uid: 'plugin::users-permissions.user',
      to: '/plugins/content-type-builder/content-types/plugin::users-permissions.user',
      restrictRelationsTo: ['oneWay', 'manyWay'],
    };

    expect(isAllowedContentTypesForRelations(contentType)).toBeFalsy();
  });
});
</file>

<file path="admin/src/utils/tests/makeUnique.test.ts">
import { makeUnique } from '../makeUnique';

describe('CTB | utils | makeUnique', () => {
  it('Should remove the duplicate elements', () => {
    const data = ['a', 'b', 'c', 'aa', 'a', 'bb', 'b'];
    const expected = ['a', 'b', 'c', 'aa', 'bb'];

    expect(makeUnique(data)).toEqual(expected);
  });
});
</file>

<file path="admin/src/utils/tests/parseDateValue.test.ts">
import { parseDateValue } from '../parseDateValue';

describe('parseDateValue', () => {
  it('should return undefined for null, undefined', () => {
    expect(parseDateValue(null)).toBeUndefined();
    expect(parseDateValue(undefined)).toBeUndefined();
  });

  it('should return a valid Date object for Date input', () => {
    const testDate = new Date('2024-09-04');
    expect(parseDateValue(testDate)).toEqual(testDate);
  });

  it('should return undefined for invalid Date object', () => {
    expect(parseDateValue(new Date('Invalid Date'))).toBeUndefined();
  });

  it('should return a Date object for valid string date input', () => {
    const result = parseDateValue('2024-09-04');
    expect(result).toBeInstanceOf(Date);
    expect(result?.toISOString()).toBe('2024-09-04T00:00:00.000Z');
  });

  it('should return a Date object for valid number (timestamp) input', () => {
    const timestamp = 1725433710049;
    const result = parseDateValue(timestamp);
    expect(result).toBeInstanceOf(Date);
    expect(result?.toISOString()).toBe('2024-09-04T07:08:30.049Z');
  });

  it('should return undefined for invalid string date', () => {
    expect(parseDateValue('not-a-date')).toBeUndefined();
  });

  it('should return undefined for invalid number date', () => {
    expect(parseDateValue(NaN)).toBeUndefined();
  });

  it('should return undefined for unexpected types', () => {
    expect(parseDateValue({} as any)).toBeUndefined();
  });
});
</file>

<file path="admin/src/utils/tests/prefixPluginTranslations.test.ts">
import { prefixPluginTranslations } from '../prefixPluginTranslations';

describe('prefixPluginTranslations', () => {
  it('should prefix plugin translations keys with plugin ID', () => {
    const trad = {
      key1: 'Value 1',
      key2: 'Value 2',
    };
    const pluginId = 'myPlugin';
    const expectedOutput = {
      'myPlugin.key1': 'Value 1',
      'myPlugin.key2': 'Value 2',
    };

    const result = prefixPluginTranslations(trad, pluginId);

    expect(result).toEqual(expectedOutput);
  });

  it('should return an empty object when given an empty object', () => {
    const trad = {};
    const pluginId = 'myPlugin';
    const expectedOutput = {};

    const result = prefixPluginTranslations(trad, pluginId);

    expect(result).toEqual(expectedOutput);
  });

  it('should throw TypeError if pluginId is provided as an empty string', () => {
    const trad = {
      key1: 'Value 1',
    };
    const pluginId = '';

    expect(() => {
      prefixPluginTranslations(trad, pluginId);
    }).toThrowError(new TypeError("pluginId can't be empty"));
  });
});
</file>

<file path="admin/src/utils/tests/timeFormat.test.ts">
import { handleTimeChange, handleTimeChangeEvent } from '../timeFormat';

describe('Time Logic', () => {
  describe('handleTimeChange', () => {
    it('should remove seconds from time string', () => {
      const result = handleTimeChange({
        value: '14:30:45.000',
        onChange: jest.fn(),
        name: 'timeField',
        type: 'time',
      });
      expect(result).toBe('14:30');
    });

    it('should not modify time string without seconds', () => {
      const result = handleTimeChange({
        value: '14:30',
        onChange: jest.fn(),
        name: 'timeField',
        type: 'time',
      });
      expect(result).toBe('14:30');
    });

    it('should return undefined for undefined input', () => {
      const result = handleTimeChange({
        value: undefined,
        onChange: jest.fn(),
        name: 'timeField',
        type: 'time',
      });
      expect(result).toBeUndefined();
    });
  });

  describe('handleTimeChangeEvent', () => {
    it('should add seconds and milliseconds to time string', () => {
      const onChange = jest.fn();
      handleTimeChangeEvent(onChange, 'timeField', 'time', '14:30');
      expect(onChange).toHaveBeenCalledWith({
        target: { name: 'timeField', value: '14:30:00.000', type: 'time' },
      });
    });

    it('should not modify time string with seconds and milliseconds', () => {
      const onChange = jest.fn();
      handleTimeChangeEvent(onChange, 'timeField', 'time', '14:30:00.000');
      expect(onChange).toHaveBeenCalledWith({
        target: { name: 'timeField', value: '14:30:00.000', type: 'time' },
      });
    });

    it('should handle undefined input', () => {
      const onChange = jest.fn();
      handleTimeChangeEvent(onChange, 'timeField', 'time', undefined);
      expect(onChange).toHaveBeenCalledWith({
        target: { name: 'timeField', value: undefined, type: 'time' },
      });
    });
  });
});
</file>

<file path="admin/src/utils/findAttribute.ts">
import { AttributeType } from '../types';

export const findAttribute = (attributes: AttributeType[], attributeToFind: string) => {
  return attributes.find(({ name }) => name === attributeToFind);
};
</file>

<file path="admin/src/utils/formAPI.ts">
import cloneDeep from 'lodash/cloneDeep';
import get from 'lodash/get';
import * as yup from 'yup';
// TODO V5 Convert any into real types
export const formsAPI: any = {
  components: {
    inputs: {} as Record<string, any>,
    add({ id, component }: { id: string; component: any }) {
      if (!this.inputs[id]) {
        this.inputs[id] = component;
      }
    },
  },
  types: {
    attribute: {
      // test: {
      //   validators: [],
      //   form: {
      //     advanced: [
      //       /* cb */
      //     ],
      //     base: [
      //       /* cb */
      //     ],
      //   },
      // },
    },
    contentType: {
      validators: [],
      form: {
        advanced: [],
        base: [],
      },
    },
    component: {
      validators: [],
      form: {
        advanced: [],
        base: [],
      },
    },
  },
  contentTypeSchemaMutations: [],
  addContentTypeSchemaMutation(cb: any) {
    this.contentTypeSchemaMutations.push(cb);
  },
  extendContentType({ validator, form: { advanced, base } }: any) {
    const { contentType } = this.types;

    contentType.validators.push(validator);
    contentType.form.advanced.push(advanced);
    contentType.form.base.push(base);
  },
  extendFields(fields: any, { validator, form: { advanced, base } }: any) {
    const formType = this.types.attribute;

    fields.forEach((field: any) => {
      if (!formType[field]) {
        formType[field] = {
          validators: [],
          form: {
            advanced: [
              /* cb */
            ],
            base: [
              /* cb */
            ],
          },
        };
      }

      formType[field].validators.push(validator);
      formType[field].form.advanced.push(advanced);
      formType[field].form.base.push(base);
    });
  },

  getAdvancedForm(target: any, props = null) {
    const sectionsToAdd = get(this.types, [...target, 'form', 'advanced'], []).reduce(
      (acc: any, current: any) => {
        const sections = current(props);

        return [...acc, ...sections];
      },
      []
    );

    return sectionsToAdd;
  },

  makeCustomFieldValidator(attributeShape: any, validator: any, ...validatorArgs: any) {
    // When no validator, return the attribute shape
    if (!validator) return attributeShape;

    // Otherwise extend the shape with the provided validator
    return attributeShape.shape({ options: yup.object().shape(validator(validatorArgs)) });
  },

  makeValidator(target: any, initShape: any, ...args: any) {
    const validators = get(this.types, [...target, 'validators'], []);

    const pluginOptionsShape = validators.reduce((acc: any, current: any) => {
      const pluginOptionShape = current(args);

      return { ...acc, ...pluginOptionShape };
    }, {});

    return initShape.shape({ pluginOptions: yup.object().shape(pluginOptionsShape) });
  },
  mutateContentTypeSchema(data: Record<string, unknown>, initialData: Record<string, unknown>) {
    let enhancedData: any = cloneDeep(data);

    const refData: any = cloneDeep(initialData);

    this.contentTypeSchemaMutations.forEach((cb: any) => {
      enhancedData = cb(enhancedData, refData);
    });

    return enhancedData;
  },
};
</file>

<file path="admin/src/utils/getAttributeDisplayedType.ts">
export const getAttributeDisplayedType = (type: string) => {
  let displayedType;

  switch (type) {
    case 'date':
    case 'datetime':
    case 'time':
    case 'timestamp':
      displayedType = 'date';
      break;
    case 'integer':
    case 'biginteger':
    case 'decimal':
    case 'float':
      displayedType = 'number';
      break;
    case 'string':
    case 'text':
      displayedType = 'text';
      break;
    case '':
      displayedType = 'relation';
      break;
    default:
      displayedType = type;
  }

  return displayedType;
};
</file>

<file path="admin/src/utils/getMaxDepth.ts">
import type { ComponentWithChildren } from '../components/DataManagerProvider/utils/retrieveComponentsThatHaveComponents';
import type { NestedComponent } from '../components/DataManagerProvider/utils/retrieveNestedComponents';
import type { Internal } from '@strapi/types';

const findComponent = <T extends { component: Internal.UID.Component }>(
  componentUid: Internal.UID.Schema,
  components: Array<T>
) => {
  return components.find((c) => c.component === componentUid);
};

/**
 * Recursively calculates the maximum depth of nested child components
 * for a given component UID.
 *
 * @param componentUid - The UID of the component to start from.
 * @param components - The array of all components with their child components.
 * @param currentDepth - The current depth of the recursion. Defaults to 0.
 * @returns The maximum depth of the nested child components.
 */
export const getChildrenMaxDepth = (
  componentUid: Internal.UID.Component,
  components: Array<ComponentWithChildren>,
  currentDepth = 0
) => {
  const component = findComponent(componentUid, components);

  // If the component doesn't exist or has no child components, return the current depth.
  if (!component || !component.childComponents || component.childComponents.length === 0) {
    return currentDepth;
  }

  let maxDepth = currentDepth;

  // Iterate through each child component to calculate their respective depths.
  component.childComponents.forEach((child) => {
    // Recursively calculate the depth of the child component.
    const depth = getChildrenMaxDepth(child.component, components, currentDepth + 1);
    // Update the maximum depth if the child's depth is greater.
    if (depth > maxDepth) {
      maxDepth = depth;
    }
  });

  return maxDepth;
};

/**
 * Calculates the depth of a component within a nested component tree.
 * Depth is defined as the level at which the component is nested.
 * For example, a component at Depth 3 is the third nested component.
 *
 * @param component - The UID of the component to find the depth for.
 * @param components - The array of all nested components.
 * @returns The depth level of the component within the nested tree.
 */
export const getComponentDepth = (
  component: Internal.UID.Schema,
  components: Array<NestedComponent>
) => {
  /**
   * Helper function to recursively calculate the depth of a component.
   *
   * @param currentComponent - The current component being inspected.
   * @param currentLevel - The current level of depth in the tree.
   * @returns An array of depth levels found for the component.
   */
  const getDepth = (currentComponent: NestedComponent, currentLevel: number): Array<number> => {
    const levels = [];
    levels.push(currentLevel);

    // If the component has no parent UIDs, return the current levels
    if (!currentComponent.uidsOfAllParents) {
      return levels;
    }

    // Iterate over each parent UID to calculate their respective depths
    for (const parentUid of currentComponent.uidsOfAllParents) {
      const parentComponent = findComponent(parentUid, components);
      if (parentComponent) {
        levels.push(...getDepth(parentComponent, currentLevel + 1));
      }
    }

    return levels;
  };

  const nestedCompo = findComponent(component, components);
  // return depth 0 if component is not nested
  if (!nestedCompo) {
    return 0;
  }
  const compoDepth = Math.max(...getDepth(nestedCompo, 1));
  return compoDepth;
};
</file>

<file path="admin/src/utils/getRelationType.ts">
import type { Schema } from '@strapi/types';

/**
 *
 * Retrieves the relation type
 */
export const getRelationType = (
  relation: Schema.Attribute.RelationKind.WithTarget | undefined,
  targetAttribute?: string | null
) => {
  const hasNotTargetAttribute = targetAttribute === undefined || targetAttribute === null;

  if (relation === 'oneToOne' && hasNotTargetAttribute) {
    return 'oneWay';
  }

  if (relation === 'oneToMany' && hasNotTargetAttribute) {
    return 'manyWay';
  }

  return relation;
};
</file>

<file path="admin/src/utils/getTrad.ts">
import { pluginId } from '../pluginId';

export const getTrad = (id: string) => `${pluginId}.${id}`;
</file>

<file path="admin/src/utils/getYupInnerErrors.ts">
import type { MessageDescriptor, PrimitiveType } from 'react-intl';
import type { ValidationError } from 'yup';

interface TranslationMessage extends MessageDescriptor {
  values?: Record<string, PrimitiveType>;
}

const extractValuesFromYupError = (
  errorType?: string | undefined,
  errorParams?: Record<string, any> | undefined
) => {
  if (!errorType || !errorParams) {
    return {};
  }

  return {
    [errorType]: errorParams[errorType],
  };
};

const getYupInnerErrors = (error: ValidationError) =>
  (error?.inner || []).reduce<Record<string, TranslationMessage>>((acc, currentError) => {
    if (currentError.path) {
      acc[currentError.path.split('[').join('.').split(']').join('')] = {
        id: currentError.message,
        defaultMessage: currentError.message,
        values: extractValuesFromYupError(currentError?.type, currentError?.params),
      };
    }

    return acc;
  }, {});

export { getYupInnerErrors };
</file>

<file path="admin/src/utils/index.ts">
/* eslint-disable check-file/no-index */
export { getTrad } from './getTrad';
export { isAllowedContentTypesForRelations } from './isAllowedContentTypesForRelations';
</file>

<file path="admin/src/utils/isAllowedContentTypesForRelations.ts">
import type { ContentType } from '../types';

export const isAllowedContentTypesForRelations = (contentType: ContentType) => {
  return (
    contentType.kind === 'collectionType' &&
    (contentType.restrictRelationsTo === null ||
      (Array.isArray(contentType.restrictRelationsTo) &&
        contentType.restrictRelationsTo.length > 0))
  );
};
</file>

<file path="admin/src/utils/makeUnique.ts">
const makeUnique = <T extends string>(array: T[]): T[] => [...new Set(array)];

export { makeUnique };
</file>

<file path="admin/src/utils/nameToSlug.ts">
import slugify from '@sindresorhus/slugify';

export const nameToSlug = (name: string) => slugify(name, { separator: '-' });
</file>

<file path="admin/src/utils/parseDateValue.ts">
export const parseDateValue = (value: unknown): Date | undefined => {
  if (value instanceof Date && isValidDate(value)) {
    return value;
  }

  if (typeof value === 'string' || typeof value === 'number') {
    const date = new Date(value);
    if (isValidDate(date)) {
      return date;
    }
  }
};

const isValidDate = (date: Date): boolean => !isNaN(date.getTime());
</file>

<file path="admin/src/utils/prefixPluginTranslations.ts">
type TradOptions = Record<string, string>;

const prefixPluginTranslations = (trad: TradOptions, pluginId: string): TradOptions => {
  if (!pluginId) {
    throw new TypeError("pluginId can't be empty");
  }
  return Object.keys(trad).reduce((acc, current) => {
    acc[`${pluginId}.${current}`] = trad[current];
    return acc;
  }, {} as TradOptions);
};

export { prefixPluginTranslations };
</file>

<file path="admin/src/utils/startsWithANumber.ts">
export const startsWithANumber = (value: string) => /^[0-9]/.test(value);
</file>

<file path="admin/src/utils/timeFormat.ts">
type TimeChangeHandler = (params: {
  target: { name: string; value: string | undefined; type: string };
}) => void;

type TimeChangeParams = {
  value?: string;
  onChange: TimeChangeHandler;
  name: string;
  type: string;
};

// The backend sends a value which has the following format: '00:45:00.000'
// but the time picker only supports hours & minutes so we need to mutate the value
const removeSeconds = (time: string): string => {
  const [hours, minutes] = time.split(':');
  return `${hours}:${minutes}`;
};

// we need to send back the value with the same '00:45:00.000' format
const addSecondsAndMilliseconds = (time: string): string => {
  return time.split(':').length === 2 ? `${time}:00.000` : time;
};

const formatTimeForInput = (value?: string): string | undefined => {
  if (!value) return;
  return value.split(':').length > 2 ? removeSeconds(value) : value;
};

const formatTimeForOutput = (value?: string): string | undefined => {
  if (!value) return undefined;
  return addSecondsAndMilliseconds(value);
};

export const handleTimeChange = ({ value }: TimeChangeParams): string | undefined => {
  const formattedInputTime = formatTimeForInput(value);

  return formattedInputTime;
};

export const handleTimeChangeEvent = (
  onChange: TimeChangeHandler,
  name: string,
  type: string,
  time?: string
): void => {
  const formattedOutputTime = formatTimeForOutput(time);

  onChange({
    target: {
      name,
      value: formattedOutputTime,
      type,
    },
  });
};
</file>

<file path="admin/src/utils/toRegressedEnumValue.ts">
import slugify from '@sindresorhus/slugify';

export const toRegressedEnumValue = (value: string | undefined) => {
  if (!value) {
    return '';
  }
  return slugify(value, {
    decamelize: false,
    lowercase: false,
    separator: '_',
  });
};
</file>

<file path="admin/src/constants.ts">
export const PERMISSIONS = {
  // This permission regards the main component (App) and is used to tell
  // If the plugin link should be displayed in the menu
  // And also if the plugin is accessible. This use case is found when a user types the url of the
  // plugin directly in the browser
  main: [{ action: 'plugin::content-type-builder.read', subject: null }],
};

export const MAX_COMPONENT_DEPTH = 6;
</file>

<file path="admin/src/exports.ts">
export {
  /**
   * @private
   * @description This hook is private and should only be used internally.
   * Pending a refactor to a more generic reload watcher outside of the content
   * type builder.
   */
  useAutoReloadOverlayBlocker as private_useAutoReloadOverlayBlocker,
  /**
   * @private
   * @description This provider is private and should only be used internally.
   * Pending a refactor to a more generic reload watcher outside of the content
   * type builder.
   */
  AutoReloadOverlayBlockerProvider as private_AutoReloadOverlayBlockerProvider,
} from './components/AutoReloadOverlayBlocker';
</file>

<file path="admin/src/index.ts">
import { Layout } from '@strapi/icons';

import pluginPkg from '../../package.json';

import { PERMISSIONS } from './constants';
import { pluginId } from './pluginId';
import { reducers } from './reducers';
import { formsAPI } from './utils/formAPI';
import { prefixPluginTranslations } from './utils/prefixPluginTranslations';

const name = pluginPkg.strapi.name;

// eslint-disable-next-line import/no-default-export
export default {
  register(app: any) {
    app.addReducers(reducers);
    app.addMenuLink({
      to: `plugins/${pluginId}`,
      icon: Layout,
      intlLabel: {
        id: `${pluginId}.plugin.name`,
        defaultMessage: 'Content-Type Builder',
      },
      permissions: PERMISSIONS.main,
      Component: () => import('./pages/App'),
      position: 5,
    });

    app.registerPlugin({
      id: pluginId,
      name,
      // Internal APIs exposed by the CTB for the other plugins to use
      apis: {
        forms: formsAPI,
      },
    });
  },
  bootstrap() {},
  async registerTrads({ locales }: { locales: string[] }) {
    const importedTrads = await Promise.all(
      locales.map((locale) => {
        return import(`./translations/${locale}.json`)
          .then(({ default: data }) => {
            return {
              data: prefixPluginTranslations(data, pluginId),
              locale,
            };
          })
          .catch(() => {
            return {
              data: {},
              locale,
            };
          });
      })
    );

    return Promise.resolve(importedTrads);
  },
};

export * from './exports';
</file>

<file path="admin/src/pluginId.ts">
import pluginPkg from '../../package.json';

export const pluginId = pluginPkg.name.replace(/^@strapi\//i, '');
</file>

<file path="admin/src/reducers.ts">
import { reducer } from './components/DataManagerProvider/reducer';
import { reducer as formModalReducer } from './components/FormModal/reducer';
import { pluginId } from './pluginId';

export const reducers = {
  [`${pluginId}_formModal`]: formModalReducer,
  [`${pluginId}_dataManagerProvider`]: reducer,
};
</file>

<file path="admin/src/types.ts">
import type { Internal, Schema } from '@strapi/types';

export type IntlLabel = {
  id: string;
  defaultMessage: string;
  values?: Record<string, any>;
};

export type SchemaType = 'contentType' | 'component' | 'components';

export type DifferentAttributesKind = 'Populatable' | 'NonPopulatable' | 'Any';

export type AttributeType = Schema.Attribute.AnyAttribute & {
  name?: string;
  target?: string;
  targetAttribute?: string | null;
  customField?: any;
  default?: any;
  repeatable?: boolean;
  [key: string]: any;
};

export interface Component {
  uid: Internal.UID.Component;
  category?: string;
  schema: any;
  isTemporary?: boolean;
  attributes?: AttributeType[];
  [key: string]: any;
}

export interface ContentType {
  uid?: Internal.UID.ContentType;
  isTemporary?: boolean;
  visible?: boolean;
  name?: string;
  title?: string;
  plugin?: string;
  to?: string;
  kind?: 'singleType' | 'collectionType';
  restrictRelationsTo?: unknown;
  schema?: any;
  [key: string]: any;
}

export type Components = Record<string, Component>;

export type ContentTypes = Record<string, ContentType>;
export interface DataManagerStateType {
  components: Components;
  contentTypes?: ContentTypes;
  initialComponents: Components;
  initialContentTypes: ContentTypes;
  initialData: Record<string, any>;
  modifiedData: {
    components: Components;
    contentTypes: ContentTypes;
    contentType?: ContentType;
    component?: Component;
  };
  reservedNames: Record<string, string>;
  isLoading: boolean;
  isLoadingForDataToBeSet: boolean;
  [key: string]: any;
}
</file>

<file path="admin/.eslintrc.js">
module.exports = {
  root: true,
  overrides: [
    {
      files: ['**/*.ts', '**/*.tsx'],
      extends: ['custom/front/typescript'],
    },
  ],
};
</file>

<file path="server/src/controllers/validation/__tests__/common.test.ts">
import { yup } from '@strapi/utils';
import { isValidName } from '../common';
import type { CommonTestConfig } from '../common';

function runTest(test: CommonTestConfig, value: string) {
  return () => yup.string().test(test).validateSync(value);
}

describe('isValidName', () => {
  test('Validates names', () => {
    expect(runTest(isValidName, '89121')).toThrow();
    expect(runTest(isValidName, '_zada')).toThrow();
    expect(runTest(isValidName, 'AZopd azd a*$')).toThrow();
    expect(runTest(isValidName, 'azda-azdazd')).toThrow();
    expect(runTest(isValidName, '')).not.toThrow();

    expect(runTest(isValidName, 'SomeValidName')).not.toThrow();
    expect(runTest(isValidName, 'Some_azdazd_azdazd')).not.toThrow();
    expect(runTest(isValidName, 'Som122e_azdazd_azdazd')).not.toThrow();
  });
});
</file>

<file path="server/src/controllers/validation/__tests__/component.test.ts">
import * as builder from '../../../services/builder';
import { validateComponentInput, validateUpdateComponentInput } from '../component';

const componentValidation = {
  validateComponentInput,
  validateUpdateComponentInput,
} as const;

describe('Component validator', () => {
  global.strapi = {
    contentTypes: {},
    plugins: {
      'content-type-builder': {
        services: {
          builder,
        },
      },
    },
  } as any;

  describe.each([
    'validateComponentInput',
    'validateUpdateComponentInput',
  ] as (keyof typeof componentValidation)[])('%p', (method) => {
    test('can validate a regular component', async () => {
      const input = {
        components: [],
        component: {
          category: 'default',
          displayName: 'mycompo',
          icon: 'calendar',
          attributes: {
            title: {
              type: 'string',
            },
          },
        },
      } as any; // TODO TS: use yup.schemaOf

      expect.assertions(1);

      await componentValidation[method](input).then((data: any) => {
        expect(data).toBe(input);
      });
    });

    test('can use custom keys in attributes', async () => {
      const input = {
        components: [],
        component: {
          category: 'default',
          displayName: 'mycompo',
          icon: 'calendar',
          attributes: {
            title: {
              type: 'string',
              myCustomKey: true,
            },
          },
        },
      } as any; // TODO TS: use yup.schemaOf

      expect.assertions(1);

      await componentValidation[method](input).then((data) => {
        expect(data).toBe(input);
      });
    });

    test('cannot use custom keys at root', async () => {
      const input = {
        myCustomKey: true,
        components: [],
        component: {
          category: 'default',
          displayName: 'mycompo',
          icon: 'calendar',
          attributes: {
            title: {
              type: 'string',
            },
          },
        },
      } as any; // TODO TS: use yup.schemaOf

      expect.assertions(1);

      await expect(componentValidation[method](input)).rejects.toBeDefined();
    });
  });
});
</file>

<file path="server/src/controllers/validation/__tests__/content-type.test.ts">
/* eslint-disable @typescript-eslint/ban-ts-comment */
import * as builder from '../../../services/builder';
import {
  validateKind,
  validateUpdateContentTypeInput,
  validateContentTypeInput,
  CreateContentTypeInput,
} from '../content-type';

describe('Content type validator', () => {
  global.strapi = {
    contentTypes: {},
    plugins: {
      'content-type-builder': {
        services: {
          builder,
        },
      },
    },
  } as any;

  describe('validateKind', () => {
    it('Only allows for single and collection types', async () => {
      await expect(validateKind('wrong')).rejects.toBeDefined();
    });

    it('allows singleType and collectionType', async () => {
      await expect(validateKind('singleType')).resolves.toBe('singleType');
      await expect(validateKind('collectionType')).resolves.toBe('collectionType');
    });

    it('allows undefined', async () => {
      // @ts-ignore-error test that it can handle undefined as expected, even if it's invalid typescript
      await expect(validateKind()).resolves.toBeUndefined();
    });
  });

  describe('Prevents use of reservedNames in attributes', () => {
    test('Throws when reserved names are used', async () => {
      const data = {
        contentType: {
          singularName: 'test',
          pluralName: 'tests',
          displayName: 'Test',
          attributes: {
            entryId: {
              type: 'string',
              default: '',
            },
          },
        },
      } as unknown as CreateContentTypeInput;

      expect.assertions(1);

      await validateUpdateContentTypeInput(data).catch((err) => {
        expect(err).toMatchObject({
          name: 'ValidationError',
          message:
            'Attribute keys cannot be one of id, document_id, created_at, updated_at, published_at, created_by_id, updated_by_id, created_by, updated_by, entry_id, status, localizations, meta, locale, __component, __contentType, strapi*, _strapi*, __strapi*',
          details: {
            errors: [
              {
                path: ['contentType', 'attributes', 'entryId'],
                message:
                  'Attribute keys cannot be one of id, document_id, created_at, updated_at, published_at, created_by_id, updated_by_id, created_by, updated_by, entry_id, status, localizations, meta, locale, __component, __contentType, strapi*, _strapi*, __strapi*',
                name: 'ValidationError',
              },
            ],
          },
        });
      });
    });

    test('Uses snake_case to compare reserved name', async () => {
      const data = {
        contentType: {
          singularName: 'test',
          pluralName: 'tests',
          displayName: 'Test',
          attributes: {
            ENTRY_ID: {
              type: 'string',
              default: '',
            },
          },
        },
      } as unknown as CreateContentTypeInput;

      expect.assertions(1);

      await validateUpdateContentTypeInput(data).catch((err) => {
        expect(err).toMatchObject({
          name: 'ValidationError',
          message:
            'Attribute keys cannot be one of id, document_id, created_at, updated_at, published_at, created_by_id, updated_by_id, created_by, updated_by, entry_id, status, localizations, meta, locale, __component, __contentType, strapi*, _strapi*, __strapi*',
          details: {
            errors: [
              {
                path: ['contentType', 'attributes', 'ENTRY_ID'],
                message:
                  'Attribute keys cannot be one of id, document_id, created_at, updated_at, published_at, created_by_id, updated_by_id, created_by, updated_by, entry_id, status, localizations, meta, locale, __component, __contentType, strapi*, _strapi*, __strapi*',
                name: 'ValidationError',
              },
            ],
          },
        });
      });
    });
  });

  describe('Prevents use of reservedNames in models', () => {
    const reservedNames = ['singularName', 'pluralName'];

    test.each(reservedNames)('Throws when reserved model names are used in %s', async (name) => {
      const data = {
        contentType: {
          singularName: name === 'singularName' ? 'date-time' : 'not-reserved-single',
          pluralName: name === 'pluralName' ? 'date-time' : 'not-reserved-plural',
          displayName: 'Test',
          attributes: {
            notReserved: {
              type: 'string',
              default: '',
            },
          },
        },
      } as unknown as CreateContentTypeInput;

      expect.assertions(1);

      await validateUpdateContentTypeInput(data).catch((err) => {
        expect(err).toMatchObject({
          name: 'ValidationError',
          message: `Content Type name cannot be one of boolean, date, date_time, time, upload, document, then, strapi*, _strapi*, __strapi*`,
          details: {
            errors: [
              {
                path: ['contentType', name],
                message: `Content Type name cannot be one of boolean, date, date_time, time, upload, document, then, strapi*, _strapi*, __strapi*`,
                name: 'ValidationError',
              },
            ],
          },
        });
      });
    });
  });

  describe('validateContentTypeInput', () => {
    test('Can use custom keys', async () => {
      const input = {
        contentType: {
          displayName: 'test',
          singularName: 'test',
          pluralName: 'tests',
          attributes: {
            views: {
              type: 'integer',
              myCustomKey: 10000,
            },
            title: {
              type: 'string',
              myCustomKey: true,
            },
          },
        },
      } as unknown as CreateContentTypeInput;

      expect.assertions(1);

      await validateContentTypeInput(input).then((data: any) => {
        expect(data.contentType.attributes).toBe(input?.contentType?.attributes);
      });
    });
  });

  describe('validateUpdateContentTypeInput', () => {
    test('Deletes empty defaults', async () => {
      const data = {
        contentType: {
          displayName: 'test',
          singularName: 'test',
          pluralName: 'tests',
          attributes: {
            slug: {
              type: 'string',
              default: '',
            },
          },
        },
        components: [
          {
            uid: 'edit.edit',
            displayName: 'test',
            icon: 'calendar',
            category: 'test',
            attributes: {
              title: {
                type: 'string',
                default: '',
              },
            },
          },
          {
            tmpUID: 'random.random',
            displayName: 'test2',
            icon: 'calendar',
            category: 'test',
            attributes: {
              title: {
                type: 'string',
                default: '',
              },
            },
          },
        ],
      } as any;

      await validateUpdateContentTypeInput(data).then(() => {
        expect(data.contentType.attributes.slug.default).toBeUndefined();
        expect(data.components[0]?.attributes?.title.default).toBeUndefined();
        expect(data.components[1]?.attributes?.title.default).toBe('');
      });
    });

    test('Deleted UID target fields are removed from input data', async () => {
      const data = {
        contentType: {
          displayName: 'test',
          singularName: 'test',
          pluralName: 'tests',
          attributes: {
            slug: {
              type: 'uid',
              targetField: 'deletedField',
            },
          },
        },
      } as unknown as CreateContentTypeInput;

      expect.assertions(1);

      await validateUpdateContentTypeInput(data).then(() => {
        // @ts-expect-error We are confirming that this invalid field does not exist
        expect(data.contentType?.attributes?.slug.targetField).toBeUndefined();
      });
    });

    // TODO: This test seems like it can be completely removed because it's from v3
    test('Can use custom keys', async () => {
      const input: CreateContentTypeInput = {
        contentType: {
          displayName: 'test',
          singularName: 'test',
          pluralName: 'tests',
          attributes: {
            views: {
              type: 'integer',
              myCustomKey: 10000,
            },
            title: {
              type: 'string',
              myCustomKey: true,
            },
          },
        },
      } as any;

      expect.assertions(1);

      await validateUpdateContentTypeInput(input).then((data) => {
        expect(data.contentType.attributes).toBe(input.contentType?.attributes);
      });
    });
  });
});
</file>

<file path="server/src/controllers/validation/__tests__/data-transform.test.ts">
import type { Struct } from '@strapi/types';
import { removeEmptyDefaults, removeDeletedUIDTargetFields } from '../data-transform';

describe('Data transform', () => {
  describe('removeEmptyDefaults', () => {
    test('Clears defaults', () => {
      const data = {
        attributes: {
          test: {
            default: '',
          },
        },
      } as any;

      removeEmptyDefaults(data);

      expect(data).toEqual({
        attributes: {
          test: {
            default: undefined,
          },
        },
      });
    });
  });

  describe('removeDeletedUIDTargetFields', () => {
    test('Set targetField to undefined when it doesnt exist', () => {
      const data = {
        attributes: {
          slug: {
            type: 'uid',
            targetField: 'random',
          },
        },
      } as Pick<Struct.ContentTypeSchema, 'attributes'> as Struct.ContentTypeSchema;

      removeDeletedUIDTargetFields(data);

      expect(data).toEqual({
        attributes: {
          slug: {
            type: 'uid',
            targetField: undefined,
          },
        },
      });
    });
  });
});
</file>

<file path="server/src/controllers/validation/__tests__/types.test.ts">
import type { Schema, Struct } from '@strapi/types';
import { getTypeValidator } from '../types';

describe('Type validators', () => {
  test('pluginOptions can be used', () => {
    const attributes = {
      title: {
        type: 'string',
        pluginOptions: {
          i18n: {
            localized: false,
          },
        },
      },
    } satisfies Struct.SchemaAttributes;

    const validator = getTypeValidator(attributes.title, {
      types: ['string'],
      attributes,
    });

    expect(validator.isValidSync(attributes.title)).toBe(true);
  });

  test('can use custom keys', () => {
    const attributes = {
      title: {
        type: 'string',
        // @ts-expect-error - As of now, custom keys are not typed in schema attributes
        myCustomKey: true,
      },
    } satisfies Struct.SchemaAttributes;

    const validator = getTypeValidator(attributes.title, {
      types: ['string'],
      attributes,
    });

    expect(validator.isValidSync(attributes.title)).toBe(true);
  });

  describe('Dynamiczone type validator', () => {
    test('Components cannot be empty', () => {
      const attributes = {
        dz: {
          type: 'dynamiczone',
          components: [],
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.dz, {
        types: ['dynamiczone'],
        attributes,
      });

      expect(validator.isValidSync(attributes.dz)).toBeFalsy();
    });

    test('Components must have at least one item', () => {
      const attributes = {
        dz: {
          type: 'dynamiczone',
          components: ['default.compoA', 'default.compoB'],
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.dz, {
        types: ['dynamiczone'],
        attributes,
      });

      expect(validator.isValidSync(attributes.dz)).toBeTruthy();
    });
  });

  describe('UID type validator', () => {
    test('Target field can be null', () => {
      const attributes = {
        slug: {
          type: 'uid',
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(validator.isValidSync(attributes.slug)).toBe(true);
    });

    test('Target field must point to an existing field', () => {
      const attributes = {
        slug: {
          type: 'uid',
          targetField: 'unknown',
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(validator.isValidSync(attributes.slug)).toBe(false);
    });

    test('Target field can be a string', () => {
      const attributes = {
        title: {
          type: 'string',
        },
        slug: {
          type: 'uid',
          targetField: 'title',
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(validator.isValidSync(attributes.slug)).toBe(true);
    });

    test('Target field can be a text', () => {
      const attributes = {
        title: {
          type: 'text',
        },
        slug: {
          type: 'uid',
          targetField: 'title',
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(validator.isValidSync(attributes.slug)).toBe(true);
    });

    test('Target field must have a type', () => {
      const attributes = {
        relation: {
          type: 'relation',
          relation: 'oneToOne',
          target: 'api::foo.foo',
        },
        slug: {
          type: 'uid',
          targetField: 'relation',
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(validator.isValidSync(attributes.slug)).toBe(false);
    });

    test.each([
      'media',
      'richtext',
      'json',
      'enumeration',
      'password',
      'email',
      'integer',
      'biginteger',
      'float',
      'decimal',
      'date',
      'time',
      'datetime',
      'timestamp',
      'boolean',
    ] as const)('Target field cannot be %s', (type) => {
      const attributes = {
        title: {
          type,
        } as Schema.Attribute.AnyAttribute,
        slug: {
          type: 'uid',
          targetField: 'title',
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(validator.isValidSync(attributes.slug)).toBe(false);
    });

    test.each([
      ['basic-uid-value1911', true],
      ['uid_with_underscore', true],
      ['tilde~_isAllowed', true],
      ['dots.are.allowed', true],
      ['no-accents', false],
      ['no-special$-chars&@', false],
      ['some-invalid&&e-uid', false],
      ['some/azdazd/', false],
      ['some(azdazd)', false],
      ['some=azdazd', false],
      ['some?azdazd=azdaz', false],
    ])('Default value must match regex %s => %s', (value, isValid) => {
      const attributes = {
        slug: {
          type: 'uid',
          default: value,
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(validator.isValidSync(attributes.slug)).toBe(isValid);
    });

    test('Default should not be defined if targetField is defined', () => {
      const attributes = {
        title: {
          type: 'string',
        },
        slug: {
          type: 'uid',
          targetField: 'title',
          default: 'some-value',
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(() => validator.validateSync(attributes.slug)).toThrow(
        'cannot define a default UID if the targetField is set'
      );
    });

    test('maxLength cannot be smaller then minLength', () => {
      const attributes = {
        slug: {
          type: 'uid',
          minLength: 120,
          maxLength: 119,
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(() => validator.validateSync(attributes.slug)).toThrow(
        'maxLength must be greater or equal to minLength'
      );
    });

    test('maxLength can be equal to minLength', () => {
      const attributes = {
        slug: {
          type: 'uid',
          minLength: 120,
          maxLength: 120,
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(validator.isValidSync(attributes.slug)).toBe(true);
    });

    test('maxLength cannot be over 256', () => {
      const attributes = {
        slug: {
          type: 'uid',
          maxLength: 257,
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.slug, {
        types: ['uid'],
        attributes,
      });

      expect(validator.isValidSync(attributes.slug)).toBe(false);
    });
  });

  describe('media type', () => {
    test('Validates allowedTypes', () => {
      // @ts-expect-error - Silence the cast as Struct.SchemaAttributes since allowedTypes expects one of 'audios',
      //                    'files', 'images' or 'videos'. This value is tested on purpose to catch an error
      const attributes = {
        img: {
          type: 'media',
          allowedTypes: ['nonexistent'],
        },
      } as Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.img, {
        types: ['media'],
        attributes,
      });

      expect(validator.isValidSync(attributes.img)).toBe(false);
    });

    test('Cannot set all with other allowedTypes', () => {
      const attributes = {
        img: {
          type: 'media',
          // FIXME: Added an any cast as allowedTypes should have a different definition in the CTB context (allows 'all')
          allowedTypes: ['all', 'videos'] as any,
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.img, {
        types: ['media'],
        attributes,
      });

      expect(validator.isValidSync(attributes.img)).toBe(false);
    });

    test('Can set multiple allowedTypes', () => {
      const attributes = {
        img: {
          type: 'media',
          allowedTypes: ['files', 'videos'],
        },
      } satisfies Struct.SchemaAttributes;

      const validator = getTypeValidator(attributes.img, {
        types: ['media'],
        attributes,
      });

      expect(validator.isValidSync(attributes.img)).toBe(true);
    });

    test.each(['audios', 'images', 'files', 'videos'] as const)(
      '%s is an allowed types',
      (type) => {
        const attributes = {
          img: {
            type: 'media',
            allowedTypes: [type],
          },
        } satisfies Struct.SchemaAttributes;

        const validator = getTypeValidator(attributes.img, {
          types: ['media'],
          attributes,
        });

        expect(validator.isValidSync(attributes.img)).toBe(true);
      }
    );
  });
});
</file>

<file path="server/src/controllers/validation/common.ts">
/* eslint-disable no-template-curly-in-string */
import { yup, strings } from '@strapi/utils';
import _ from 'lodash';
import { TestConfig } from 'yup';

export const validators = {
  required: yup.boolean(),
  unique: yup.boolean(),
  minLength: yup.number().integer().positive(),
  maxLength: yup.number().integer().positive(),
};

export const NAME_REGEX = /^[A-Za-z][_0-9A-Za-z]*$/;
export const COLLECTION_NAME_REGEX = /^[A-Za-z][-_0-9A-Za-z]*$/;
export const CATEGORY_NAME_REGEX = /^[A-Za-z][-_0-9A-Za-z]*$/;
export const ICON_REGEX = /^[A-Za-z0-9][-A-Za-z0-9]*$/;
export const UID_REGEX = /^[A-Za-z0-9-_.~]*$/;

export type CommonTestConfig = TestConfig<unknown | undefined, Record<string, unknown>>;

export const isValidName: CommonTestConfig = {
  name: 'isValidName',
  message: `\${path} must match the following regex: ${NAME_REGEX}`,
  test: (val: unknown) => val === '' || NAME_REGEX.test(val as string),
};

export const isValidIcon: CommonTestConfig = {
  name: 'isValidIcon',
  message: `\${path} is not a valid icon name. Make sure your icon name starts with an alphanumeric character and only includes alphanumeric characters or dashes.`,
  test: (val) => val === '' || ICON_REGEX.test(val as string),
};

export const isValidUID: CommonTestConfig = {
  name: 'isValidUID',
  message: `\${path} must match the following regex: ${UID_REGEX}`,
  test: (val) => val === '' || UID_REGEX.test(val as string),
};

export const isValidCategoryName: CommonTestConfig = {
  name: 'isValidCategoryName',
  message: `\${path} must match the following regex: ${CATEGORY_NAME_REGEX}`,
  test: (val) => val === '' || CATEGORY_NAME_REGEX.test(val as string),
};

export const isValidCollectionName: CommonTestConfig = {
  name: 'isValidCollectionName',
  message: `\${path} must match the following regex: ${COLLECTION_NAME_REGEX}`,
  test: (val) => val === '' || COLLECTION_NAME_REGEX.test(val as string),
};

export const isValidKey = (key: string): CommonTestConfig => ({
  name: 'isValidKey',
  message: `Attribute name '${key}' must match the following regex: ${NAME_REGEX}`,
  test: () => NAME_REGEX.test(key),
});

export const isValidEnum: CommonTestConfig = {
  name: 'isValidEnum',
  message: '${path} should not start with number',
  test: (val) => val === '' || !strings.startsWithANumber(val as string),
};

export const areEnumValuesUnique: CommonTestConfig = {
  name: 'areEnumValuesUnique',
  message: '${path} cannot contain duplicate values',
  test(values) {
    const filtered = [...new Set(values as string[])];

    return filtered.length === (values as string[]).length;
  },
};

export const isValidRegExpPattern: CommonTestConfig = {
  name: 'isValidRegExpPattern',
  message: '${path} must be a valid RexExp pattern string',
  test: (val) => val === '' || !!new RegExp(val as string),
};

export const isValidDefaultJSON: CommonTestConfig = {
  name: 'isValidDefaultJSON',
  message: '${path} is not a valid JSON',
  test(val) {
    if (val === undefined) {
      return true;
    }

    if (_.isNumber(val) || _.isNull(val) || _.isObject(val) || _.isArray(val)) {
      return true;
    }

    try {
      JSON.parse(val as string);

      return true;
    } catch (err) {
      return false;
    }
  },
};
</file>

<file path="server/src/controllers/validation/component-category.ts">
import { yup, validateYupSchema } from '@strapi/utils';
import { isValidCategoryName } from './common';

const componentCategorySchema = yup
  .object({
    name: yup.string().min(3).test(isValidCategoryName).required('name.required'),
  })
  .noUnknown();

export default validateYupSchema(componentCategorySchema);
</file>

<file path="server/src/controllers/validation/component.ts">
import _ from 'lodash';
import { yup, validateYupSchema } from '@strapi/utils';

import type { Struct } from '@strapi/types';
import { modelTypes, DEFAULT_TYPES } from '../../services/constants';
import { isValidCategoryName, isValidIcon } from './common';
import { createSchema } from './model-schema';
import { removeEmptyDefaults } from './data-transform';

export const VALID_RELATIONS = ['oneToOne', 'oneToMany'];
export const VALID_TYPES = [...DEFAULT_TYPES, 'component', 'customField'];

export const componentSchema = createSchema(VALID_TYPES, VALID_RELATIONS, {
  modelType: modelTypes.COMPONENT,
})
  .shape({
    displayName: yup.string().min(1).required('displayName.required'),
    icon: yup.string().nullable().test(isValidIcon),
    category: yup.string().nullable().test(isValidCategoryName).required('category.required'),
  })
  .required()
  .noUnknown();

export const nestedComponentSchema = yup.array().of(
  componentSchema
    .shape({
      uid: yup.string(),
      tmpUID: yup.string(),
    })
    .test({
      name: 'mustHaveUIDOrTmpUID',
      message: 'Component must have a uid or a tmpUID',
      test(attr: unknown) {
        if (_.has(attr, 'uid') && _.has(attr, 'tmpUID')) return false;
        if (!_.has(attr, 'uid') && !_.has(attr, 'tmpUID')) return false;
        return true;
      },
    })
    .required()
    .noUnknown()
);

export const componentInputSchema = yup
  .object({
    component: componentSchema,
    components: nestedComponentSchema,
  })
  .noUnknown();

export const validateComponentInput = validateYupSchema(componentInputSchema);

const updateComponentInputSchema = yup
  .object({
    component: componentSchema,
    components: nestedComponentSchema,
  })
  .noUnknown();

export const validateUpdateComponentInput = (data: {
  component?: Struct.ComponentSchema;
  components?: Struct.ComponentSchema[];
}) => {
  if (_.has(data, 'component') && data.component) {
    removeEmptyDefaults(data.component);
  }

  if (_.has(data, 'components') && Array.isArray(data.components)) {
    data.components.forEach((data) => {
      if (_.has(data, 'uid')) {
        removeEmptyDefaults(data);
      }
    });
  }

  return validateYupSchema(updateComponentInputSchema)(data);
};
</file>

<file path="server/src/controllers/validation/content-type.ts">
/* eslint-disable no-template-curly-in-string */ // yup templates need to be in this format

import { flatMap, getOr, has, snakeCase } from 'lodash/fp';
import { yup, validateYupSchema } from '@strapi/utils';

import type { Struct, Internal } from '@strapi/types';
import { getService } from '../../utils';
import { modelTypes, DEFAULT_TYPES, typeKinds } from '../../services/constants';
import { createSchema } from './model-schema';
import { removeEmptyDefaults, removeDeletedUIDTargetFields } from './data-transform';
import { nestedComponentSchema } from './component';

// Input flattens some fields of the "info" into the root type
export type CreateContentTypeInput = {
  contentType?: Partial<Struct.ContentTypeSchema> & Partial<Struct.ContentTypeSchemaInfo>;
  components?: Array<
    Partial<Struct.ComponentSchema> &
      Partial<Struct.SchemaInfo> & { tmpUID?: Internal.UID.Component }
  >;
  singularName: Struct.ContentTypeSchemaInfo['singularName'];
  attributes: Struct.SchemaAttributes & Record<string, any>;
  kind: Struct.ContentTypeKind;
  collectionName?: Struct.CollectionTypeSchema['collectionName'];
  pluralName: Struct.ContentTypeSchemaInfo['pluralName'];
  displayName: Struct.ContentTypeSchemaInfo['displayName'];
  description: Struct.ContentTypeSchemaInfo['description'];
  options?: Struct.SchemaOptions;
  draftAndPublish?: Struct.SchemaOptions['draftAndPublish'];
  pluginOptions?: Struct.ContentTypeSchema['pluginOptions'];
  config?: object;
};

/**
 * Allowed relation per type kind
 */
const VALID_RELATIONS = {
  [typeKinds.SINGLE_TYPE]: [
    'oneToOne',
    'oneToMany',
    'morphOne',
    'morphMany',
    'morphToOne',
    'morphToMany',
  ],
  [typeKinds.COLLECTION_TYPE]: [
    'oneToOne',
    'oneToMany',
    'manyToOne',
    'manyToMany',
    'morphOne',
    'morphMany',
    'morphToOne',
    'morphToMany',
  ],
} as const;

/**
 * Allowed types
 */
const VALID_TYPES = [...DEFAULT_TYPES, 'uid', 'component', 'dynamiczone', 'customField'];

/**
 * Returns a yup schema to validate a content type payload
 */
const createContentTypeSchema = (data: CreateContentTypeInput, { isEdition = false } = {}) => {
  const kind: keyof typeof VALID_RELATIONS = getOr(
    typeKinds.COLLECTION_TYPE,
    'contentType.kind',
    data
  );
  const contentTypeSchema = createSchema(VALID_TYPES, VALID_RELATIONS[kind] || [], {
    modelType: modelTypes.CONTENT_TYPE,
  })
    .shape({
      displayName: yup.string().min(1).required(),
      singularName: yup
        .string()
        .min(1)
        .test(nameIsAvailable(isEdition))
        .test(forbiddenContentTypeNameValidator())
        .isKebabCase()
        .required(),
      pluralName: yup
        .string()
        .min(1)
        .test(nameIsAvailable(isEdition))
        .test(nameIsNotExistingCollectionName(isEdition)) // TODO: v5: require singularName to not match a collection name
        .test(forbiddenContentTypeNameValidator())
        .isKebabCase()
        .required(),
    })
    .test(
      'singularName-not-equal-pluralName',
      '${path}: singularName and pluralName should be different',
      (value) => value.singularName !== value.pluralName
    );

  return yup
    .object({
      // FIXME .noUnknown(false) will strip off the unwanted properties without throwing an error
      // Why not having .noUnknown() ? Because we want to be able to add options relatable to EE features
      // without having any reference to them in CE.
      // Why not handle an "options" object in the content-type ? The admin panel needs lots of rework
      // to be able to send this options object instead of top-level attributes.
      // @nathan-pichon 20/02/2023
      contentType: contentTypeSchema.required().noUnknown(false),
      components: nestedComponentSchema,
    })
    .noUnknown();
};

/**
 * Validator for content type creation
 */
export const validateContentTypeInput = (data: CreateContentTypeInput) => {
  return validateYupSchema(createContentTypeSchema(data))(data);
};

/**
 * Validator for content type edition
 */
export const validateUpdateContentTypeInput = (data: CreateContentTypeInput) => {
  if (has('contentType', data)) {
    removeEmptyDefaults(data.contentType);
    removeDeletedUIDTargetFields(data.contentType as Struct.ContentTypeSchema);
  }

  if (has('components', data) && Array.isArray(data.components)) {
    data.components.forEach((comp) => {
      if (has('uid', comp)) {
        removeEmptyDefaults(comp as Struct.ComponentSchema);
      }
    });
  }

  return validateYupSchema(createContentTypeSchema(data, { isEdition: true }))(data);
};

const forbiddenContentTypeNameValidator = () => {
  const reservedNames = getService('builder').getReservedNames().models;

  return {
    name: 'forbiddenContentTypeName',
    message: `Content Type name cannot be one of ${reservedNames.join(', ')}`,
    test(value: unknown) {
      if (typeof value !== 'string') {
        return true;
      }

      return !getService('builder').isReservedModelName(value);
    },
  };
};

const nameIsAvailable = (isEdition: boolean) => {
  // TODO TS: if strapi.contentTypes (ie, ContentTypes) works as an ArrayLike and is used like this, we may want to ensure it is typed so that it can be without using as
  const usedNames = flatMap((ct: Struct.ContentTypeSchema) => {
    return [ct.info?.singularName, ct.info?.pluralName];
  })(strapi.contentTypes as any);

  return {
    name: 'nameAlreadyUsed',
    message: 'contentType: name `${value}` is already being used by another content type.',
    test(value: unknown) {
      // don't check on edition
      if (isEdition) return true;

      // ignore if not a string (will be caught in another validator)
      if (typeof value !== 'string') {
        return true;
      }

      // compare snake case to check the actual column names that will be used in the database
      return usedNames.every((usedName) => snakeCase(usedName) !== snakeCase(value));
    },
  };
};

const nameIsNotExistingCollectionName = (isEdition: boolean) => {
  const usedNames = Object.keys(strapi.contentTypes).map(
    (key) => strapi.contentTypes[key as Internal.UID.ContentType].collectionName
  ) as string[];

  return {
    name: 'nameAlreadyUsed',
    message: 'contentType: name `${value}` is already being used by another content type.',
    test(value: unknown) {
      // don't check on edition
      if (isEdition) return true;

      // ignore if not a string (will be caught in another validator)
      if (typeof value !== 'string') {
        return true;
      }

      // compare snake case to check the actual column names that will be used in the database
      return usedNames.every((usedName) => snakeCase(usedName) !== snakeCase(value));
    },
  };
};

/**
 * Validates type kind
 */
const kindSchema = yup.string().oneOf([typeKinds.SINGLE_TYPE, typeKinds.COLLECTION_TYPE]);

export const validateKind = validateYupSchema(kindSchema);
</file>

<file path="server/src/controllers/validation/data-transform.ts">
import type { Struct } from '@strapi/types';
import _ from 'lodash';
import { hasDefaultAttribute } from '../../utils/typeguards';

export const removeEmptyDefaults = (
  data: Partial<Struct.ContentTypeSchema> | Partial<Struct.ComponentSchema> | undefined
) => {
  const { attributes } = data || {};

  Object.keys(attributes!).forEach((attributeName) => {
    const attribute = attributes![attributeName];

    if (hasDefaultAttribute(attribute) && attribute.default === '') {
      attribute.default = undefined;
    }
  });
};

export const removeDeletedUIDTargetFields = (data: Struct.ContentTypeSchema) => {
  if (_.has(data, 'attributes')) {
    Object.values(data.attributes).forEach((attribute) => {
      if (
        attribute.type === 'uid' &&
        !_.isUndefined(attribute.targetField) &&
        !_.has(data.attributes, attribute.targetField)
      ) {
        attribute.targetField = undefined;
      }
    });
  }
};
</file>

<file path="server/src/controllers/validation/model-schema.ts">
import { yup } from '@strapi/utils';
import _ from 'lodash';
import { snakeCase } from 'lodash/fp';
import { modelTypes, typeKinds } from '../../services/constants';
import { getService } from '../../utils';
import { isValidKey, isValidCollectionName } from './common';
import { getTypeValidator } from './types';
import { getRelationValidator } from './relations';

type ModelTypeInput = (typeof modelTypes)[keyof typeof modelTypes];

type CreateAttributesInput = {
  types: ReadonlyArray<string>;
  relations: ReadonlyArray<string>;
  modelType?: ModelTypeInput;
};

export const createSchema = (
  types: CreateAttributesInput['types'],
  relations: CreateAttributesInput['relations'],
  { modelType }: { modelType?: ModelTypeInput } = {}
) => {
  const shape = {
    description: yup.string(),
    options: yup.object(),
    pluginOptions: yup.object(),
    collectionName: yup.string().nullable().test(isValidCollectionName),
    attributes: createAttributesValidator({ types, relations, modelType }),
    draftAndPublish: yup.boolean(),
  } as any;

  if (modelType === modelTypes.CONTENT_TYPE) {
    shape.kind = yup.string().oneOf([typeKinds.SINGLE_TYPE, typeKinds.COLLECTION_TYPE]).nullable();
  }

  return yup.object(shape).noUnknown();
};

const createAttributesValidator = ({ types, modelType, relations }: CreateAttributesInput) => {
  return yup.lazy((attributes) => {
    return yup
      .object()
      .shape(
        _.mapValues(attributes, (attribute, key) => {
          if (isForbiddenKey(key)) {
            return forbiddenValidator();
          }

          if (isConflictingKey(key, attributes)) {
            return conflictingKeysValidator(key);
          }

          if (attribute.type === 'relation') {
            return getRelationValidator(attribute, relations).test(isValidKey(key));
          }

          if (_.has(attribute, 'type')) {
            return getTypeValidator(attribute, { types, modelType, attributes }).test(
              isValidKey(key)
            );
          }

          return typeOrRelationValidator;
        })
      )
      .required('attributes.required');
  });
};

const isConflictingKey = (key: string, attributes: Record<string, any>) => {
  const snakeCaseKey = snakeCase(key);

  return Object.keys(attributes).some((existingKey) => {
    if (existingKey === key) return false; // don't compare against itself
    return snakeCase(existingKey) === snakeCaseKey;
  });
};

const isForbiddenKey = (key: string) => {
  return getService('builder').isReservedAttributeName(key);
};

const forbiddenValidator = () => {
  const reservedNames = [...getService('builder').getReservedNames().attributes];

  return yup.mixed().test({
    name: 'forbiddenKeys',
    message: `Attribute keys cannot be one of ${reservedNames.join(', ')}`,
    test: () => false,
  });
};

const conflictingKeysValidator = (key: string) => {
  return yup.mixed().test({
    name: 'conflictingKeys',
    message: `Attribute ${key} conflicts with an existing key`,
    test: () => false,
  });
};

const typeOrRelationValidator = yup.object().test({
  name: 'mustHaveTypeOrTarget',
  message: 'Attribute must have either a type or a target',
  test: () => false,
});
</file>

<file path="server/src/controllers/validation/relations.ts">
import { isUndefined } from 'lodash/fp';
import { yup } from '@strapi/utils';
import type { TestContext, TestFunction } from 'yup';
import type { Schema, UID } from '@strapi/types';
import { typeKinds, coreUids } from '../../services/constants';
import { isValidName } from './common';

const STRAPI_USER_RELATIONS = ['oneToOne', 'oneToMany'];

const isValidRelation = (validNatures: ReadonlyArray<string>): TestFunction<string | undefined> =>
  function (this: TestContext, value) {
    // NOTE: In case of an undefined value, delegate the check to .required()
    if (value === undefined) {
      return true;
    }

    if (this.parent.target === coreUids.STRAPI_USER) {
      if (!validNatures.includes(value) || !isUndefined(this.parent.targetAttribute)) {
        return this.createError({
          path: this.path,
          message: `must be one of the following values: ${STRAPI_USER_RELATIONS.join(', ')}`,
        });
      }
    }

    return validNatures.includes(value)
      ? true
      : this.createError({
          path: this.path,
          message: `must be one of the following values: ${validNatures.join(', ')}`,
        });
  };

export const getRelationValidator = (
  attribute: Schema.Attribute.Relation,
  allowedRelations: ReadonlyArray<string>
) => {
  const contentTypesUIDs = Object.keys(strapi.contentTypes)
    .filter((key) => strapi.contentTypes[key as UID.ContentType].kind === typeKinds.COLLECTION_TYPE)
    .filter((key) => !key.startsWith(coreUids.PREFIX) || key === coreUids.STRAPI_USER)
    .concat(['__self__', '__contentType__']);

  const base = {
    type: yup.string().oneOf(['relation']).required(),
    relation: yup.string().test('isValidRelation', isValidRelation(allowedRelations)).required(),
    configurable: yup.boolean().nullable(),
    private: yup.boolean().nullable(),
    pluginOptions: yup.object(),
  };

  switch (attribute.relation) {
    case 'oneToOne':
    case 'oneToMany':
    case 'manyToOne':
    case 'manyToMany':
    case 'morphOne':
    case 'morphMany': {
      return yup.object({
        ...base,
        target: yup.string().oneOf(contentTypesUIDs).required(),
        targetAttribute: yup.string().test(isValidName).nullable(),
      });
    }
    case 'morphToOne':
    case 'morphToMany':
    default: {
      return yup.object({ ...base });
    }
  }
};
</file>

<file path="server/src/controllers/validation/types.ts">
import _ from 'lodash';
import { yup } from '@strapi/utils';

import type { TestContext } from 'yup';
import type { Schema, Struct } from '@strapi/types';

import { modelTypes, VALID_UID_TARGETS } from '../../services/constants';
import {
  validators,
  areEnumValuesUnique,
  isValidDefaultJSON,
  isValidName,
  isValidEnum,
  isValidUID,
  isValidRegExpPattern,
} from './common';

export type GetTypeValidatorOptions = {
  types: ReadonlyArray<string>;
  attributes?: Struct.SchemaAttributes;
  modelType?: (typeof modelTypes)[keyof typeof modelTypes];
};

const maxLengthIsGreaterThanOrEqualToMinLength = {
  name: 'isGreaterThanMin',
  message: 'maxLength must be greater or equal to minLength',
  test(this: TestContext, value: unknown) {
    const { minLength } = this.parent;
    return !(!_.isUndefined(minLength) && !_.isUndefined(value) && (value as number) < minLength);
  },
};

export const getTypeValidator = (
  attribute: Schema.Attribute.AnyAttribute,
  { types, modelType, attributes }: GetTypeValidatorOptions
) => {
  return yup.object({
    type: yup
      .string()
      .oneOf([...types])
      .required(),
    configurable: yup.boolean().nullable(),
    private: yup.boolean().nullable(),
    pluginOptions: yup.object(),
    ...getTypeShape(attribute, { modelType, attributes }),
  } as any);
};

const getTypeShape = (attribute: Schema.Attribute.AnyAttribute, { attributes }: any = {}) => {
  switch (attribute.type) {
    /**
     * complex types
     */

    case 'media': {
      return {
        multiple: yup.boolean(),
        required: validators.required,
        allowedTypes: yup
          .array()
          .of(yup.string().oneOf(['images', 'videos', 'files', 'audios']))
          .min(1),
      };
    }

    case 'uid': {
      return {
        required: validators.required,
        targetField: yup
          .string()
          .oneOf(
            Object.keys(attributes!).filter((key) =>
              VALID_UID_TARGETS.includes(_.get(attributes![key] as any, 'type'))
            )
          )
          .nullable(),
        default: yup
          .string()
          .test(
            'isValidDefaultUID',
            'cannot define a default UID if the targetField is set',
            function (value) {
              const { targetField } = this.parent;
              return !!(_.isNil(targetField) || _.isNil(value));
            }
          )
          .test(isValidUID),
        minLength: validators.minLength,
        maxLength: validators.maxLength.max(256).test(maxLengthIsGreaterThanOrEqualToMinLength),
        options: yup.object().shape({
          separator: yup.string(),
          lowercase: yup.boolean(),
          decamelize: yup.boolean(),
          customReplacements: yup.array().of(yup.array().of(yup.string()).min(2).max(2)),
          preserveLeadingUnderscore: yup.boolean(),
        }),
      };
    }

    /**
     * scalar types
     */
    case 'string':
    case 'text': {
      return {
        default: yup.string(),
        required: validators.required,
        unique: validators.unique,
        minLength: validators.minLength,
        maxLength: validators.maxLength,
        regex: yup.string().test(isValidRegExpPattern),
      };
    }
    case 'richtext': {
      return {
        default: yup.string(),
        required: validators.required,
        minLength: validators.minLength,
        maxLength: validators.maxLength,
      };
    }
    case 'blocks': {
      return {
        required: validators.required,
      };
    }
    case 'json': {
      return {
        default: yup.mixed().test(isValidDefaultJSON),
        required: validators.required,
      };
    }
    case 'enumeration': {
      return {
        enum: yup
          .array()
          .of(yup.string().test(isValidEnum).required())
          .min(1)
          .test(areEnumValuesUnique)
          .required(),
        default: yup.string().when('enum', (enumVal) => yup.string().oneOf(enumVal)),
        enumName: yup.string().test(isValidName),
        required: validators.required,
      };
    }
    case 'password': {
      return {
        required: validators.required,
        minLength: validators.minLength,
        maxLength: validators.maxLength,
      };
    }
    case 'email': {
      return {
        default: yup.string().email(),
        required: validators.required,
        unique: validators.unique,
        minLength: validators.minLength,
        maxLength: validators.maxLength,
      };
    }
    case 'integer': {
      return {
        default: yup.number().integer(),
        required: validators.required,
        unique: validators.unique,
        min: yup.number().integer(),
        max: yup.number().integer(),
      };
    }
    case 'biginteger': {
      return {
        default: yup.string().nullable().matches(/^\d*$/),
        required: validators.required,
        unique: validators.unique,
        min: yup.string().nullable().matches(/^\d*$/),
        max: yup.string().nullable().matches(/^\d*$/),
      };
    }
    case 'float': {
      return {
        default: yup.number(),
        required: validators.required,
        unique: validators.unique,
        min: yup.number(),
        max: yup.number(),
      };
    }
    case 'decimal': {
      return {
        default: yup.number(),
        required: validators.required,
        unique: validators.unique,
        min: yup.number(),
        max: yup.number(),
      };
    }
    case 'time':
    case 'datetime':
    case 'date': {
      return {
        default: yup.string(),
        required: validators.required,
        unique: validators.unique,
      };
    }
    case 'boolean': {
      return {
        default: yup.boolean(),
        required: validators.required,
      };
    }

    case 'component': {
      return {
        required: validators.required,
        repeatable: yup.boolean(),
        // TODO: Add correct server validation for nested components
        component: yup.string().required(),
        min: yup.number(),
        max: yup.number(),
      };
    }

    case 'dynamiczone': {
      return {
        required: validators.required,
        components: yup
          .array()
          .of(yup.string().required())
          .test('isArray', '${path} must be an array', (value) => Array.isArray(value))
          .min(1),
        min: yup.number(),
        max: yup.number(),
      };
    }

    default: {
      return {};
    }
  }
};
</file>

<file path="server/src/controllers/builder.ts">
import type { Context } from 'koa';
import { getService } from '../utils';

export default {
  getReservedNames(ctx: Context) {
    ctx.body = getService('builder').getReservedNames();
  },
};
</file>

<file path="server/src/controllers/component-categories.ts">
import type { Context } from 'koa';
import { getService } from '../utils';
import validateComponentCategory from './validation/component-category';

export default {
  async editCategory(ctx: Context) {
    const body = ctx.request.body as any;

    try {
      await validateComponentCategory(body);
    } catch (error) {
      return ctx.send({ error }, 400);
    }

    const { name } = ctx.params;

    strapi.reload.isWatching = false;

    const componentCategoryService = getService('component-categories');

    const newName = await componentCategoryService.editCategory(name, body);

    setImmediate(() => strapi.reload());

    ctx.send({ name: newName });
  },

  async deleteCategory(ctx: Context) {
    const { name } = ctx.params;

    strapi.reload.isWatching = false;

    const componentCategoryService = getService('component-categories');

    await componentCategoryService.deleteCategory(name);

    setImmediate(() => strapi.reload());

    ctx.send({ name });
  },
};
</file>

<file path="server/src/controllers/components.ts">
import _ from 'lodash';
import type { Context } from 'koa';
import type { UID } from '@strapi/types';
import { getService } from '../utils';
import { validateComponentInput, validateUpdateComponentInput } from './validation/component';

/**
 * Components controller
 */

export default {
  /**
   * GET /components handler
   * Returns a list of available components
   * @param {Object} ctx - koa context
   */
  async getComponents(ctx: Context) {
    const componentService = getService('components');
    const componentUIDs = Object.keys(strapi.components) as UID.Component[];

    const data = componentUIDs.map((uid) => {
      return componentService.formatComponent(strapi.components[uid]);
    });

    ctx.send({ data });
  },

  /**
   * GET /components/:uid
   * Returns a specific component
   * @param {Object} ctx - koa context
   */
  async getComponent(ctx: Context) {
    const { uid } = ctx.params;

    const component = strapi.components[uid];

    if (!component) {
      return ctx.send({ error: 'component.notFound' }, 404);
    }

    const componentService = getService('components');

    ctx.send({ data: componentService.formatComponent(component) });
  },

  /**
   * POST /components
   * Creates a component and returns its infos
   * @param {Object} ctx - koa context
   */
  async createComponent(ctx: Context) {
    const body = ctx.request.body as any;

    try {
      await validateComponentInput(body);
    } catch (error) {
      return ctx.send({ error }, 400);
    }

    try {
      strapi.reload.isWatching = false;

      const componentService = getService('components');

      const component = await componentService.createComponent({
        component: body.component,
        components: body.components,
      });

      setImmediate(() => strapi.reload());

      ctx.send({ data: { uid: component.uid } }, 201);
    } catch (error) {
      strapi.log.error(error);
      ctx.send({ error: (error as any)?.message || 'Unknown error' }, 400);
    }
  },

  /**
   * PUT /components/:uid
   * Updates a component and return its infos
   * @param {Object} ctx - koa context - enhanced koa context
   */
  async updateComponent(ctx: Context) {
    const { uid } = ctx.params;
    const body = ctx.request.body as any;

    if (!_.has(strapi.components, uid)) {
      return ctx.send({ error: 'component.notFound' }, 404);
    }

    try {
      await validateUpdateComponentInput(body);
    } catch (error) {
      return ctx.send({ error }, 400);
    }

    try {
      strapi.reload.isWatching = false;

      const componentService = getService('components');

      const component = (await componentService.editComponent(uid, {
        component: body.component,
        components: body.components,
      })) as any;

      setImmediate(() => strapi.reload());

      ctx.send({ data: { uid: component.uid } });
    } catch (error) {
      strapi.log.error(error);

      ctx.send({ error: (error as any)?.message || 'Unknown error' }, 400);
    }
  },

  /**
   * DELETE /components/:uid
   * Deletes a components and returns its old infos
   * @param {Object} ctx - koa context
   */
  async deleteComponent(ctx: Context) {
    const { uid } = ctx.params;

    if (!_.has(strapi.components, uid)) {
      return ctx.send({ error: 'component.notFound' }, 404);
    }

    try {
      strapi.reload.isWatching = false;

      const componentService = getService('components');

      const component = await componentService.deleteComponent(uid);

      setImmediate(() => strapi.reload());

      ctx.send({ data: { uid: component.uid } });
    } catch (error) {
      strapi.log.error(error);
      ctx.send({ error: (error as any)?.message || 'Unknown error' }, 400);
    }
  },
};
</file>

<file path="server/src/controllers/content-types.ts">
import _ from 'lodash';
import type { Context } from 'koa';
import type {} from 'koa-body';
import type { Internal } from '@strapi/types';
import { getService } from '../utils';
import {
  validateContentTypeInput,
  validateUpdateContentTypeInput,
  validateKind,
} from './validation/content-type';

export default {
  async getContentTypes(ctx: Context) {
    const { kind } = ctx.query;

    try {
      await validateKind(kind);
    } catch (error) {
      return ctx.send({ error }, 400);
    }

    const contentTypeService = getService('content-types');

    const contentTypes = Object.keys(strapi.contentTypes)
      .filter(
        (uid) =>
          !kind ||
          _.get(strapi.contentTypes[uid as Internal.UID.ContentType], 'kind', 'collectionType') ===
            kind
      )
      .map((uid) =>
        contentTypeService.formatContentType(strapi.contentTypes[uid as Internal.UID.ContentType])
      );

    ctx.send({
      data: contentTypes,
    });
  },

  getContentType(ctx: Context) {
    const { uid } = ctx.params;

    const contentType = strapi.contentTypes[uid];

    if (!contentType) {
      return ctx.send({ error: 'contentType.notFound' }, 404);
    }

    const contentTypeService = getService('content-types');

    ctx.send({ data: contentTypeService.formatContentType(contentType) });
  },

  async createContentType(ctx: Context) {
    const body = ctx.request.body as any;

    try {
      await validateContentTypeInput(body);
    } catch (error) {
      return ctx.send({ error }, 400);
    }

    try {
      strapi.reload.isWatching = false;

      const contentTypeService = getService('content-types');

      const contentType = await contentTypeService.createContentType({
        contentType: body.contentType,
        components: body.components,
      });

      const metricsPayload = {
        eventProperties: {
          kind: contentType.kind,
        },
      };

      if (_.isEmpty(strapi.apis)) {
        await strapi.telemetry.send('didCreateFirstContentType', metricsPayload);
      } else {
        await strapi.telemetry.send('didCreateContentType', metricsPayload);
      }

      setImmediate(() => strapi.reload());

      ctx.send({ data: { uid: contentType.uid } }, 201);
    } catch (err) {
      strapi.log.error(err);
      await strapi.telemetry.send('didNotCreateContentType', {
        eventProperties: { error: (err as Error).message || err },
      });
      ctx.send({ error: (err as Error).message || 'Unknown error' }, 400);
    }
  },

  async updateContentType(ctx: Context) {
    const { uid } = ctx.params;
    const body = ctx.request.body as any;

    if (!_.has(strapi.contentTypes, uid)) {
      return ctx.send({ error: 'contentType.notFound' }, 404);
    }

    try {
      await validateUpdateContentTypeInput(body);
    } catch (error) {
      return ctx.send({ error }, 400);
    }

    try {
      strapi.reload.isWatching = false;

      const contentTypeService = getService('content-types');

      const component = await contentTypeService.editContentType(uid, {
        contentType: body.contentType,
        components: body.components,
      });

      setImmediate(() => strapi.reload());

      ctx.send({ data: { uid: component.uid } }, 201);
    } catch (error) {
      strapi.log.error(error);
      ctx.send({ error: (error as Error)?.message || 'Unknown error' }, 400);
    }
  },

  async deleteContentType(ctx: Context) {
    const { uid } = ctx.params;

    if (!_.has(strapi.contentTypes, uid)) {
      return ctx.send({ error: 'contentType.notFound' }, 404);
    }

    try {
      strapi.reload.isWatching = false;

      const contentTypeService = getService('content-types');

      const component = await contentTypeService.deleteContentType(uid);

      setImmediate(() => strapi.reload());

      ctx.send({ data: { uid: component.uid } });
    } catch (error) {
      strapi.log.error(error);
      ctx.send({ error: (error as Error)?.message || 'Unknown error' }, 400);
    }
  },
};
</file>

<file path="server/src/controllers/index.ts">
import builder from './builder';
import componentCategories from './component-categories';
import components from './components';
import contentTypes from './content-types';

const exportObject = {
  builder,
  'component-categories': componentCategories,
  components,
  'content-types': contentTypes,
};

export default exportObject;
</file>

<file path="server/src/routes/admin.ts">
export default {
  type: 'admin',
  routes: [
    {
      method: 'GET',
      path: '/reserved-names',
      handler: 'builder.getReservedNames',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'GET',
      path: '/content-types',
      handler: 'content-types.getContentTypes',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'GET',
      path: '/content-types/:uid',
      handler: 'content-types.getContentType',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'POST',
      path: '/content-types',
      handler: 'content-types.createContentType',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'PUT',
      path: '/content-types/:uid',
      handler: 'content-types.updateContentType',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'DELETE',
      path: '/content-types/:uid',
      handler: 'content-types.deleteContentType',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'GET',
      path: '/components',
      handler: 'components.getComponents',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'GET',
      path: '/components/:uid',
      handler: 'components.getComponent',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'POST',
      path: '/components',
      handler: 'components.createComponent',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'PUT',
      path: '/components/:uid',
      handler: 'components.updateComponent',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'DELETE',
      path: '/components/:uid',
      handler: 'components.deleteComponent',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'PUT',
      path: '/component-categories/:name',
      handler: 'component-categories.editCategory',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
    {
      method: 'DELETE',
      path: '/component-categories/:name',
      handler: 'component-categories.deleteCategory',
      config: {
        policies: [
          {
            name: 'admin::hasPermissions',
            config: { actions: ['plugin::content-type-builder.read'] },
          },
        ],
      },
    },
  ],
};
</file>

<file path="server/src/routes/content-api.ts">
export default {
  type: 'content-api',
  routes: [
    {
      method: 'GET',
      path: '/content-types',
      handler: 'content-types.getContentTypes',
    },
    {
      method: 'GET',
      path: '/content-types/:uid',
      handler: 'content-types.getContentType',
    },
    {
      method: 'GET',
      path: '/components',
      handler: 'components.getComponents',
    },
    {
      method: 'GET',
      path: '/components/:uid',
      handler: 'components.getComponent',
    },
  ],
};
</file>

<file path="server/src/routes/index.ts">
import admin from './admin';
import contentApi from './content-api';

export default {
  admin,
  'content-api': contentApi,
};
</file>

<file path="server/src/services/__tests__/content-types.test.ts">
import type { Struct } from '@strapi/types';
import { formatContentType } from '../content-types';

describe('Content types service', () => {
  describe('format ContentType', () => {
    const contentType = {
      uid: 'test-uid',
      kind: 'singleType',
      plugin: 'some-plugin',
      modelName: 'my-name',
      collectionName: 'tests',
      info: {
        displayName: 'My name',
        singularName: 'my-name',
        pluralName: 'my-names',
        description: 'My description',
      },
      options: {},
      pluginOptions: {
        'content-manager': {
          visible: true,
        },
      },
      attributes: {
        title: {
          type: 'string',
        },
      },
    } as unknown as Struct.ContentTypeSchema;

    it('Returns consistent schemas', () => {
      expect(formatContentType(contentType)).toMatchSnapshot();
    });

    it('Sets default kind', () => {
      expect(
        formatContentType({
          ...contentType,
          kind: undefined,
        })
      ).toMatchObject({
        schema: {
          kind: 'collectionType',
        },
      });
    });
  });
});
</file>

<file path="server/src/services/schema-builder/component-builder.ts">
import path from 'path';
import type { Internal } from '@strapi/types';
import _ from 'lodash';
import pluralize from 'pluralize';

import { strings, errors } from '@strapi/utils';
import { isConfigurable } from '../../utils/attributes';
import createSchemaHandler from './schema-handler';

const { ApplicationError } = errors;

export default function createComponentBuilder() {
  return {
    createComponentUID({ category, displayName }: any) {
      return `${strings.nameToSlug(category)}.${strings.nameToSlug(displayName)}`;
    },

    createNewComponentUIDMap(components: object[]) {
      return components.reduce((uidMap: any, component: any) => {
        uidMap[component.tmpUID] = this.createComponentUID(component);
        return uidMap;
      }, {});
    },

    /**
     * create a component in the tmpComponent map
     */
    createComponent(this: any, infos: any) {
      const uid = this.createComponentUID(infos);

      if (this.components.has(uid)) {
        throw new ApplicationError('component.alreadyExists');
      }

      const handler = createSchemaHandler({
        dir: path.join(strapi.dirs.app.components, strings.nameToSlug(infos.category)),
        filename: `${strings.nameToSlug(infos.displayName)}.json`,
      });

      // TODO: create a utility for this
      // Duplicate in admin/src/components/FormModal/forms/utils/createCollectionName.ts
      const collectionName = `components_${strings.nameToCollectionName(
        infos.category
      )}_${strings.nameToCollectionName(pluralize(infos.displayName))}`;

      this.components.forEach((compo: any) => {
        if (compo.schema.collectionName === collectionName) {
          throw new ApplicationError('component.alreadyExists');
        }
      });

      handler
        .setUID(uid)
        .set('collectionName', collectionName)
        .set(['info', 'displayName'], infos.displayName)
        .set(['info', 'icon'], infos.icon)
        .set(['info', 'description'], infos.description)
        .set('pluginOptions', infos.pluginOptions)
        .set('config', infos.config)
        .setAttributes(this.convertAttributes(infos.attributes));

      if (this.components.size === 0) {
        strapi.telemetry.send('didCreateFirstComponent');
      } else {
        strapi.telemetry.send('didCreateComponent');
      }

      this.components.set(uid, handler);

      return handler;
    },

    /**
     * create a component in the tmpComponent map
     */
    editComponent(this: any, infos: any) {
      const { uid } = infos;

      if (!this.components.has(uid)) {
        throw new errors.ApplicationError('component.notFound');
      }

      const component = this.components.get(uid);

      const [, nameUID] = uid.split('.');

      const newCategory = strings.nameToSlug(infos.category);
      const newUID = `${newCategory}.${nameUID}`;

      if (newUID !== uid && this.components.has(newUID)) {
        throw new errors.ApplicationError('component.edit.alreadyExists');
      }

      const newDir = path.join(strapi.dirs.app.components, newCategory);

      const oldAttributes = component.schema.attributes;

      const newAttributes = _.omitBy(infos.attributes, (attr, key) => {
        return _.has(oldAttributes, key) && !isConfigurable(oldAttributes[key]);
      });

      component
        .setUID(newUID)
        .setDir(newDir)
        .set(['info', 'displayName'], infos.displayName)
        .set(['info', 'icon'], infos.icon)
        .set(['info', 'description'], infos.description)
        .set('pluginOptions', infos.pluginOptions)
        .setAttributes(this.convertAttributes(newAttributes));

      if (newUID !== uid) {
        this.components.forEach((compo: any) => {
          compo.updateComponent(uid, newUID);
        });

        this.contentTypes.forEach((ct: any) => {
          ct.updateComponent(uid, newUID);
        });
      }

      return component;
    },

    deleteComponent(this: any, uid: Internal.UID.Component) {
      if (!this.components.has(uid)) {
        throw new errors.ApplicationError('component.notFound');
      }

      this.components.forEach((compo: any) => {
        compo.removeComponent(uid);
      });

      this.contentTypes.forEach((ct: any) => {
        ct.removeComponent(uid);
      });

      return this.components.get(uid).delete();
    },
  };
}
</file>

<file path="server/src/services/schema-builder/content-type-builder.ts">
import path from 'path';
import _ from 'lodash';

import { strings, errors } from '@strapi/utils';
import type { Schema, Internal } from '@strapi/types';
import { isRelation, isConfigurable } from '../../utils/attributes';
import { typeKinds } from '../constants';
import createSchemaHandler from './schema-handler';
import { CreateContentTypeInput } from '../../controllers/validation/content-type';

const { ApplicationError } = errors;

const reuseUnsetPreviousProperties = (
  newAttribute: Schema.Attribute.AnyAttribute,
  oldAttribute: Schema.Attribute.AnyAttribute
) => {
  _.defaults(
    newAttribute,
    _.omit(oldAttribute, [
      'configurable',
      'required',
      'private',
      'unique',
      'pluginOptions',
      'inversedBy',
      'mappedBy',
    ])
  );
};

export default function createComponentBuilder() {
  return {
    setRelation(this: any, { key, uid, attribute }: any) {
      if (!_.has(attribute, 'target')) {
        return;
      }

      const targetCT = this.contentTypes.get(attribute.target);
      const targetAttribute = targetCT.getAttribute(attribute.targetAttribute);

      if (!attribute.targetAttribute) {
        return;
      }

      targetCT.setAttribute(
        attribute.targetAttribute,
        generateRelation({ key, attribute, uid, targetAttribute })
      );
    },

    unsetRelation(this: any, attribute: any) {
      if (!_.has(attribute, 'target')) {
        return;
      }

      const targetCT = this.contentTypes.get(attribute.target);

      const targetAttributeName = attribute.inversedBy || attribute.mappedBy;
      const targetAttribute = targetCT.getAttribute(targetAttributeName);

      if (!targetAttribute) return;

      return targetCT.deleteAttribute(targetAttributeName);
    },

    /**
     * Creates a content type in memory to be written to files later on
     */
    createContentType(this: any, infos: CreateContentTypeInput) {
      const uid = createContentTypeUID(infos);

      if (this.contentTypes.has(uid)) {
        throw new ApplicationError('contentType.alreadyExists');
      }

      const contentType = createSchemaHandler({
        modelName: infos.singularName,
        dir: path.join(
          strapi.dirs.app.api,
          infos.singularName,
          'content-types',
          infos.singularName
        ),
        filename: `schema.json`,
      });

      this.contentTypes.set(uid, contentType);

      // support self referencing content type relation
      Object.keys(infos.attributes).forEach((key) => {
        const { target } = infos.attributes[key];
        if (target === '__self__') {
          infos.attributes[key].target = uid;
        }
      });

      contentType
        .setUID(uid)
        .set('kind', infos.kind || typeKinds.COLLECTION_TYPE)
        .set(
          'collectionName',
          infos.collectionName || strings.nameToCollectionName(infos.pluralName)
        )
        .set('info', {
          singularName: infos.singularName,
          pluralName: infos.pluralName,
          displayName: infos.displayName,
          description: infos.description,
        })
        .set('options', {
          ...(infos.options ?? {}),
          draftAndPublish: infos.draftAndPublish,
        })
        .set('pluginOptions', infos.pluginOptions)
        .set('config', infos.config)
        .setAttributes(this.convertAttributes(infos.attributes));

      Object.keys(infos.attributes).forEach((key) => {
        const attribute = infos.attributes[key];

        if (isRelation(attribute)) {
          if (['manyToMany', 'oneToOne'].includes(attribute.relation)) {
            if (attribute.target === uid && attribute.targetAttribute !== undefined) {
              // self referencing relation
              const targetAttribute = infos.attributes[attribute.targetAttribute];

              if (targetAttribute.dominant === undefined) {
                attribute.dominant = true;
              } else {
                attribute.dominant = false;
              }
            } else {
              attribute.dominant = true;
            }
          }

          this.setRelation({
            key,
            uid,
            attribute,
          });
        }
      });

      return contentType;
    },

    editContentType(this: any, infos: any) {
      const { uid } = infos;

      if (!this.contentTypes.has(uid)) {
        throw new ApplicationError('contentType.notFound');
      }

      const contentType = this.contentTypes.get(uid);

      const oldAttributes = contentType.schema.attributes;

      const newAttributes = _.omitBy(infos.attributes, (attr, key) => {
        return _.has(oldAttributes, key) && !isConfigurable(oldAttributes[key]);
      });

      const newKeys = _.difference(Object.keys(newAttributes), Object.keys(oldAttributes));
      const deletedKeys = _.difference(Object.keys(oldAttributes), Object.keys(newAttributes));
      const remainingKeys = _.intersection(Object.keys(oldAttributes), Object.keys(newAttributes));

      // remove old relations
      deletedKeys.forEach((key) => {
        const attribute = oldAttributes[key];

        const targetAttributeName = attribute.inversedBy || attribute.mappedBy;

        // if the old relation has a target attribute. we need to remove it in the target type
        if (isConfigurable(attribute) && isRelation(attribute) && !_.isNil(targetAttributeName)) {
          this.unsetRelation(attribute);
        }
      });

      remainingKeys.forEach((key) => {
        const oldAttribute = oldAttributes[key];
        const newAttribute = newAttributes[key];

        if (!isRelation(oldAttribute) && isRelation(newAttribute)) {
          return this.setRelation({
            key,
            uid,
            attribute: newAttributes[key],
          });
        }

        if (isRelation(oldAttribute) && !isRelation(newAttribute)) {
          return this.unsetRelation(oldAttribute);
        }

        if (isRelation(oldAttribute) && isRelation(newAttribute)) {
          const oldTargetAttributeName = oldAttribute.inversedBy || oldAttribute.mappedBy;

          const sameRelation = oldAttribute.relation === newAttribute.relation;
          const targetAttributeHasChanged = oldTargetAttributeName !== newAttribute.targetAttribute;

          if (!sameRelation || targetAttributeHasChanged) {
            this.unsetRelation(oldAttribute);
          }

          // keep extra options that were set manually on oldAttribute
          reuseUnsetPreviousProperties(newAttribute, oldAttribute);

          if (oldAttribute.inversedBy) {
            newAttribute.dominant = true;
          } else if (oldAttribute.mappedBy) {
            newAttribute.dominant = false;
          }

          return this.setRelation({
            key,
            uid,
            attribute: newAttribute,
          });
        }
      });

      // add new relations
      newKeys.forEach((key) => {
        const attribute = newAttributes[key];

        if (isRelation(attribute)) {
          if (['manyToMany', 'oneToOne'].includes(attribute.relation)) {
            if (attribute.target === uid && attribute.targetAttribute !== undefined) {
              // self referencing relation
              const targetAttribute = newAttributes[attribute.targetAttribute];

              if (targetAttribute.dominant === undefined) {
                attribute.dominant = true;
              } else {
                attribute.dominant = false;
              }
            } else {
              attribute.dominant = true;
            }
          }

          this.setRelation({
            key,
            uid,
            attribute,
          });
        }
      });

      contentType
        .set('kind', infos.kind || contentType.schema.kind)
        .set(['info', 'displayName'], infos.displayName)
        .set(['info', 'description'], infos.description)
        .set('options', {
          ...(infos.options ?? {}),
          draftAndPublish: infos.draftAndPublish,
        })
        .set('pluginOptions', infos.pluginOptions)
        .setAttributes(this.convertAttributes(newAttributes));

      return contentType;
    },

    deleteContentType(this: any, uid: string) {
      if (!this.contentTypes.has(uid)) {
        throw new ApplicationError('contentType.notFound');
      }

      this.components.forEach((compo: any) => {
        compo.removeContentType(uid);
      });

      this.contentTypes.forEach((ct: any) => {
        ct.removeContentType(uid);
      });

      return this.contentTypes.get(uid).delete();
    },
  };
}

/**
 * Returns a uid from a content type infos
 *
 * @param {object} options options
 * @param {string} options.singularName content-type singularName
 * @returns {string} uid
 */
const createContentTypeUID = ({
  singularName,
}: {
  singularName: string;
}): Internal.UID.ContentType => `api::${singularName}.${singularName}`;

const generateRelation = ({ key, attribute, uid, targetAttribute = {} }: any) => {
  const opts: any = {
    type: 'relation',
    target: uid,
    autoPopulate: targetAttribute.autoPopulate,
    private: targetAttribute.private || undefined,
    pluginOptions: targetAttribute.pluginOptions || undefined,
  };

  switch (attribute.relation) {
    case 'oneToOne': {
      opts.relation = 'oneToOne';

      if (attribute.dominant) {
        opts.mappedBy = key;
      } else {
        opts.inversedBy = key;
      }
      break;
    }
    case 'oneToMany': {
      opts.relation = 'manyToOne';
      opts.inversedBy = key;
      break;
    }
    case 'manyToOne': {
      opts.relation = 'oneToMany';
      opts.mappedBy = key;
      break;
    }
    case 'manyToMany': {
      opts.relation = 'manyToMany';

      if (attribute.dominant) {
        opts.mappedBy = key;
      } else {
        opts.inversedBy = key;
      }

      break;
    }
    default:
  }

  // we do this just to make sure we have the same key order when writing to files
  const { type, relation, target, ...restOptions } = opts;

  return {
    type,
    relation,
    target,
    ...restOptions,
  };
};
</file>

<file path="server/src/services/schema-builder/index.ts">
import { join } from 'path';
import _ from 'lodash';

import { errors } from '@strapi/utils';
import createSchemaHandler from './schema-handler';
import createComponentBuilder from './component-builder';
import createContentTypeBuilder from './content-type-builder';

/**
 * Creates a content type schema builder instance
 */
export default function createBuilder() {
  const components = Object.values(strapi.components).map((componentInput) => ({
    category: componentInput.category,
    modelName: componentInput.modelName,
    plugin: componentInput.modelName,
    uid: componentInput.uid,
    filename: componentInput.__filename__,
    dir: join(strapi.dirs.app.components, componentInput.category),
    schema: componentInput.__schema__,
    config: componentInput.config,
  }));

  const contentTypes = Object.values<any>(strapi.contentTypes).map((contentTypeInput) => {
    const dir = contentTypeInput.plugin
      ? join(
          strapi.dirs.app.extensions,
          contentTypeInput.plugin,
          'content-types',
          contentTypeInput.info.singularName
        )
      : join(
          strapi.dirs.app.api,
          contentTypeInput.apiName,
          'content-types',
          contentTypeInput.info.singularName
        );

    return {
      modelName: contentTypeInput.modelName,
      plugin: contentTypeInput.plugin,
      uid: contentTypeInput.uid,
      filename: 'schema.json',
      dir,
      schema: contentTypeInput.__schema__,
      config: contentTypeInput.config,
    };
  });

  return createSchemaBuilder({
    components,
    contentTypes,
  });
}

type SchemaBuilderOptions = {
  components: any;
  contentTypes: any;
};

function createSchemaBuilder({ components, contentTypes }: SchemaBuilderOptions) {
  const tmpComponents = new Map();
  const tmpContentTypes = new Map();

  // init temporary ContentTypes
  Object.keys(contentTypes).forEach((key) => {
    tmpContentTypes.set(contentTypes[key].uid, createSchemaHandler(contentTypes[key]));
  });

  // init temporary components
  Object.keys(components).forEach((key) => {
    tmpComponents.set(components[key].uid, createSchemaHandler(components[key]));
  });

  return {
    get components() {
      return tmpComponents;
    },
    get contentTypes() {
      return tmpContentTypes;
    },

    /**
     * Convert Attributes received from the API to the right syntax
     */
    convertAttributes(attributes: any) {
      return Object.keys(attributes).reduce(
        (acc, key) => {
          const attribute = attributes[key];

          const { configurable, private: isPrivate } = attribute;

          const baseProperties = {
            private: isPrivate === true ? true : undefined,
            configurable: configurable === false ? false : undefined,
          };

          if (attribute.type === 'relation') {
            const { target, relation, targetAttribute, dominant, ...restOfProperties } = attribute;

            const attr = {
              type: 'relation',
              relation,
              target,
              ...restOfProperties,
              ...baseProperties,
            };

            acc[key] = attr;

            if (target && !this.contentTypes.has(target)) {
              throw new errors.ApplicationError(`target: ${target} does not exist`);
            }

            if (_.isNil(targetAttribute)) {
              return acc;
            }

            if (['oneToOne', 'manyToMany'].includes(relation) && dominant === true) {
              attr.inversedBy = targetAttribute;
            } else if (['oneToOne', 'manyToMany'].includes(relation) && dominant === false) {
              attr.mappedBy = targetAttribute;
            } else if (['oneToOne', 'manyToOne', 'manyToMany'].includes(relation)) {
              attr.inversedBy = targetAttribute;
            } else if (['oneToMany'].includes(relation)) {
              attr.mappedBy = targetAttribute;
            }

            return acc;
          }

          acc[key] = {
            ...attribute,
            ...baseProperties,
          };

          return acc;
        },
        {} as Record<string, unknown>
      );
    },

    ...createComponentBuilder(),
    ...createContentTypeBuilder(),

    /**
     * Write all type to files
     */
    writeFiles() {
      const schemas = [
        ...Array.from(tmpComponents.values()),
        ...Array.from(tmpContentTypes.values()),
      ];

      return Promise.all(schemas.map((schema) => schema.flush()))
        .catch((error) => {
          strapi.log.error('Error writing schema files');
          strapi.log.error(error);
          return this.rollback();
        })
        .catch((error) => {
          strapi.log.error(
            'Error rolling back schema files. You might need to fix your files manually'
          );
          strapi.log.error(error);

          throw new errors.ApplicationError('Invalid schema edition');
        });
    },

    /**
     * rollback all files
     */
    rollback() {
      return Promise.all(
        [...Array.from(tmpComponents.values()), ...Array.from(tmpContentTypes.values())].map(
          (schema) => schema.rollback()
        )
      );
    },
  };
}
</file>

<file path="server/src/services/schema-builder/schema-handler.ts">
import path from 'path';
import type { Internal, Struct } from '@strapi/types';
import fse from 'fs-extra';
import _ from 'lodash';

import { isConfigurable } from '../../utils/attributes';

export type Infos = {
  category?: string;
  modelName?: string;
  plugin?: string;
  uid?: Internal.UID.ContentType;
  dir: string;
  filename: string;
  schema?: Struct.ContentTypeSchema;
};

export default function createSchemaHandler(infos: Infos) {
  const { category, modelName, plugin, uid, dir, filename, schema } = infos;

  const initialState = {
    modelName,
    plugin,
    category,
    uid,
    dir,
    filename,
    schema:
      schema ||
      ({
        info: {},
        options: {},
        attributes: {},
      } as Struct.ContentTypeSchema),
  };

  const state = _.cloneDeep(initialState);

  // always keep it the same to rollback
  Object.freeze(initialState.schema);

  let modified = false;
  let deleted = false;

  return {
    get modelName() {
      return initialState.modelName;
    },

    get plugin() {
      return initialState.plugin;
    },

    get category() {
      return initialState.category;
    },

    get kind() {
      return _.get(state.schema, 'kind', 'collectionType');
    },

    get uid() {
      return state.uid;
    },

    get writable() {
      return _.get(state, 'plugin') !== 'admin';
    },

    setUID(val: Internal.UID.ContentType) {
      modified = true;

      state.uid = val;
      return this;
    },

    setDir(val: string) {
      modified = true;

      state.dir = val;
      return this;
    },

    get schema() {
      return _.cloneDeep(state.schema);
    },

    setSchema(val: Struct.ContentTypeSchema) {
      modified = true;

      state.schema = _.cloneDeep(val);
      return this;
    },

    // get a particular path inside the schema
    get(path: string[]) {
      return _.get(state.schema, path);
    },

    // set a particular path inside the schema
    set(path: string[] | string, val: unknown) {
      if (!state.schema) return this;

      modified = true;

      const value = _.defaultTo(val, _.get(state.schema, path));
      _.set(state.schema, path, value);

      return this;
    },

    // delete a particular path inside the schema
    unset(path: string[]) {
      modified = true;

      _.unset(state.schema, path);

      return this;
    },

    delete() {
      deleted = true;
      return this;
    },

    getAttribute(key: string) {
      return this.get(['attributes', key]);
    },

    setAttribute(key: string, attribute: any) {
      return this.set(['attributes', key], attribute);
    },

    deleteAttribute(key: string) {
      return this.unset(['attributes', key]);
    },

    setAttributes(newAttributes: Struct.SchemaAttributes) {
      if (!this.schema) return this;

      // delete old configurable attributes
      for (const key in this.schema.attributes) {
        if (isConfigurable((this.schema.attributes as any)[key])) {
          this.deleteAttribute(key);
        }
      }

      // set new Attributes
      for (const key of Object.keys(newAttributes)) {
        this.setAttribute(key, newAttributes[key as keyof Struct.SchemaAttributes]);
      }

      return this;
    },

    removeContentType(uid: Internal.UID.ContentType) {
      if (!state.schema) return this;

      const attributes = state.schema.attributes as Record<string, any>;

      Object.keys(attributes).forEach((key) => {
        const attribute = attributes[key];

        if (attribute.target === uid) {
          this.deleteAttribute(key);
        }
      });

      return this;
    },

    // utils
    removeComponent(uid: Internal.UID.Component) {
      if (!state.schema) return this;

      const attributes = state.schema.attributes as Record<string, any>;

      Object.keys(attributes).forEach((key) => {
        const attr = attributes[key];

        if (attr.type === 'component' && attr.component === uid) {
          this.deleteAttribute(key);
        }

        if (
          attr.type === 'dynamiczone' &&
          Array.isArray(attr.components) &&
          attr.components.includes(uid)
        ) {
          const updatedComponentList = attributes[key].components.filter(
            (val: string) => val !== uid
          );
          this.set(['attributes', key, 'components'], updatedComponentList);
        }
      });

      return this;
    },

    updateComponent(uid: Internal.UID.Component, newUID: Internal.UID.Component) {
      if (!state.schema) return this;

      const attributes = state.schema.attributes as Record<string, any>;

      Object.keys(attributes).forEach((key) => {
        const attr = attributes[key];

        if (attr.type === 'component' && attr.component === uid) {
          this.set(['attributes', key, 'component'], newUID);
        }

        if (
          attr.type === 'dynamiczone' &&
          Array.isArray(attr.components) &&
          attr.components.includes(uid)
        ) {
          const updatedComponentList = attr.components.map((val: string) =>
            val === uid ? newUID : val
          );

          this.set(['attributes', key, 'components'], updatedComponentList);
        }
      });

      return this;
    },

    // save the schema to disk
    async flush() {
      if (!this.writable) {
        return;
      }

      const initialPath = path.join(initialState.dir, initialState.filename);
      const filePath = path.join(state.dir, state.filename);

      if (deleted) {
        await fse.remove(initialPath);

        const list = await fse.readdir(initialState.dir);
        if (list.length === 0) {
          await fse.remove(initialState.dir);
        }

        return;
      }

      if (modified) {
        if (!state.schema) return Promise.resolve();

        await fse.ensureFile(filePath);

        await fse.writeJSON(
          filePath,
          {
            kind: state.schema.kind,
            collectionName: state.schema.collectionName,
            info: state.schema.info,
            options: state.schema.options,
            pluginOptions: state.schema.pluginOptions,
            attributes: state.schema.attributes,
            config: (state.schema as any).config,
          },
          { spaces: 2 }
        );

        // remove from oldPath
        if (initialPath !== filePath) {
          await fse.remove(initialPath);

          const list = await fse.readdir(initialState.dir);
          if (list.length === 0) {
            await fse.remove(initialState.dir);
          }
        }

        return;
      }

      return Promise.resolve();
    },

    // reset the schema to its initial value
    async rollback() {
      if (!this.writable) {
        return;
      }

      const initialPath = path.join(initialState.dir, initialState.filename);
      const filePath = path.join(state.dir, state.filename);

      // it was a creation so it needs to be deleted
      if (!initialState.uid) {
        await fse.remove(filePath);

        const list = await fse.readdir(state.dir);
        if (list.length === 0) {
          await fse.remove(state.dir);
        }
        return;
      }

      if (modified || deleted) {
        await fse.ensureFile(initialPath);
        await fse.writeJSON(initialPath, initialState.schema, { spaces: 2 });

        // remove
        if (initialPath !== filePath) {
          await fse.remove(filePath);

          const list = await fse.readdir(state.dir);
          if (list.length === 0) {
            await fse.remove(state.dir);
          }
        }
      }

      return Promise.resolve();
    },
  };
}
</file>

<file path="server/src/services/api-handler.ts">
import * as path from 'path';
import * as fse from 'fs-extra';
import type { Internal } from '@strapi/types';

/**
 * Deletes the API folder of a contentType
 */
export async function clear(uid: Internal.UID.ContentType) {
  // TODO double check if this is the correct way to get the apiName
  const { apiName, modelName } = strapi.contentTypes[uid] as any;

  const apiFolder = path.join(strapi.dirs.app.api, apiName);

  await recursiveRemoveFiles(apiFolder, createDeleteApiFunction(modelName));
  await deleteBackup(uid);
}

/**
 * Backups the API folder of a contentType
 * @param {string} uid content type uid
 */
export async function backup(uid: Internal.UID.ContentType) {
  const { apiName } = strapi.contentTypes[uid] as any;

  const apiFolder = path.join(strapi.dirs.app.api, apiName);
  const backupFolder = path.join(strapi.dirs.app.api, '.backup', apiName);

  // backup the api folder
  await fse.copy(apiFolder, backupFolder);
}

/**
 * Deletes an API backup folder
 */
async function deleteBackup(uid: Internal.UID.ContentType) {
  const { apiName } = strapi.contentTypes[uid] as any;

  const backupFolder = path.join(strapi.dirs.app.api, '.backup');
  const apiBackupFolder = path.join(strapi.dirs.app.api, '.backup', apiName);

  await fse.remove(apiBackupFolder);

  const list = await fse.readdir(backupFolder);
  if (list.length === 0) {
    await fse.remove(backupFolder);
  }
}

/**
 * Rollbacks the API folder of a contentType
 */
export async function rollback(uid: Internal.UID.ContentType) {
  const { apiName } = strapi.contentTypes[uid] as any;

  const apiFolder = path.join(strapi.dirs.app.api, apiName);
  const backupFolder = path.join(strapi.dirs.app.api, '.backup', apiName);

  try {
    await fse.access(backupFolder);
  } catch {
    throw new Error('Cannot rollback api that was not backed up');
  }

  await fse.remove(apiFolder);
  await fse.copy(backupFolder, apiFolder);
  await deleteBackup(uid);
}

/**
 * Creates a delete function to clear an api folder
 */
const createDeleteApiFunction = (baseName: string) => {
  /**
   * Delets a file in an api.
   * Will only update routes.json instead of deleting it if other routes are present
   */
  return async (filePath: string) => {
    const fileName = path.basename(filePath, path.extname(filePath));

    const isSchemaFile = filePath.endsWith(`${baseName}/schema.json`);
    if (fileName === baseName || isSchemaFile) {
      return fse.remove(filePath);
    }
  };
};

/**
 * Deletes a folder recursively using a delete function
 * @param {string} folder folder to delete
 */
const recursiveRemoveFiles = async (folder: string, deleteFn: (file: string) => unknown) => {
  const filesName = await fse.readdir(folder);

  for (const fileName of filesName) {
    const filePath = path.join(folder, fileName);

    const stat = await fse.stat(filePath);

    if (stat.isDirectory()) {
      await recursiveRemoveFiles(filePath, deleteFn);
    } else {
      await deleteFn(filePath);
    }
  }

  const files = await fse.readdir(folder);
  if (files.length === 0) {
    await fse.remove(folder);
  }
};
</file>

<file path="server/src/services/builder.ts">
import { snakeCase } from 'lodash/fp';

// use snake_case
export const reservedAttributes = [
  // TODO: these need to come from a centralized place so we don't break things accidentally in the future and can share them outside the CTB, for example on Strapi bootstrap prior to schema db sync

  // ID fields
  'id',
  'document_id',

  // Creator fields
  'created_at',
  'updated_at',
  'published_at',
  'created_by_id',
  'updated_by_id',
  // does not actually conflict because the fields are called *_by_id but we'll leave it to avoid confusion
  'created_by',
  'updated_by',

  // Used for Strapi functionality
  'entry_id',
  'status',
  'localizations',
  'meta',
  'locale',
  '__component',
  '__contentType',

  // We support ending with * to denote prefixes
  'strapi*',
  '_strapi*',
  '__strapi*',
];

// use snake_case
export const reservedModels = [
  'boolean',
  'date',
  'date_time',
  'time',
  'upload',
  'document',
  'then', // no longer an issue but still restricting for being a javascript keyword

  // We support ending with * to denote prefixes
  'strapi*',
  '_strapi*',
  '__strapi*',
];

export const getReservedNames = () => {
  return {
    models: reservedModels,
    attributes: reservedAttributes,
  };
};

// compare snake case to check the actual column names that will be used in the database
export const isReservedModelName = (name: string) => {
  const snakeCaseName = snakeCase(name);
  if (reservedModels.includes(snakeCaseName)) {
    return true;
  }

  if (
    reservedModels
      .filter((key) => key.endsWith('*'))
      .map((key) => key.slice(0, -1))
      .some((prefix) => snakeCaseName.startsWith(prefix))
  ) {
    return true;
  }

  return false;
};

// compare snake case to check the actual column names that will be used in the database
export const isReservedAttributeName = (name: string) => {
  const snakeCaseName = snakeCase(name);
  if (reservedAttributes.includes(snakeCaseName)) {
    return true;
  }

  if (
    reservedAttributes
      .filter((key) => key.endsWith('*'))
      .map((key) => key.slice(0, -1))
      .some((prefix) => snakeCaseName.startsWith(prefix))
  ) {
    return true;
  }

  return false;
};
</file>

<file path="server/src/services/component-categories.ts">
import { join } from 'path';
import { strings, errors } from '@strapi/utils';
import type { Struct } from '@strapi/types';
import createBuilder from './schema-builder';

type Infos = {
  name: string;
};

interface WorkingComponent extends Struct.ComponentSchema {
  setUID: (uid: string) => WorkingComponent;
  setDir: (dir: string) => WorkingComponent;
  updateComponent: (oldUID: string, newUID: string) => void;
}

/**
 * Edit a category name and move components to the write folder
 */
export const editCategory = async (name: string, infos: Infos) => {
  const newName = strings.nameToSlug(infos.name);

  // don't do anything the name doesn't change
  if (name === newName) return;

  if (!categoryExists(name)) {
    throw new errors.ApplicationError('category not found');
  }

  if (categoryExists(newName)) {
    throw new errors.ApplicationError('Name already taken');
  }

  const builder = createBuilder();

  builder.components.forEach((component: WorkingComponent) => {
    const oldUID = component.uid;
    const newUID = `${newName}.${component.modelName}`;

    // only edit the components in this specific category
    if (component.category !== name) return;

    component.setUID(newUID).setDir(join(strapi.dirs.app.components, newName));

    builder.components.forEach((compo: WorkingComponent) => {
      compo.updateComponent(oldUID, newUID);
    });

    builder.contentTypes.forEach((ct: WorkingComponent) => {
      ct.updateComponent(oldUID, newUID);
    });
  });

  await builder.writeFiles();

  return newName;
};

/**
 * Deletes a category and its components
 */
export const deleteCategory = async (name: string) => {
  if (!categoryExists(name)) {
    throw new errors.ApplicationError('category not found');
  }

  const builder = createBuilder();

  builder.components.forEach((component) => {
    if (component.category === name) {
      builder.deleteComponent(component.uid);
    }
  });

  await builder.writeFiles();
};

/**
 * Checks if a category exists
 */
const categoryExists = (name: string) => {
  const matchingIndex = Object.values(strapi.components).findIndex(
    (component) => component.category === name
  );

  return matchingIndex > -1;
};
</file>

<file path="server/src/services/components.ts">
import type { Internal, Struct } from '@strapi/types';
import { get, has } from 'lodash';

import { formatAttributes, replaceTemporaryUIDs } from '../utils/attributes';
import createBuilder from './schema-builder';

/**
 * Formats a component attributes
 */
export const formatComponent = (component: any) => {
  const { uid, modelName, connection, collectionName, info, category } = component;

  return {
    uid,
    category,
    apiId: modelName,
    schema: {
      displayName: get(info, 'displayName'),
      description: get(info, 'description', ''),
      icon: get(info, 'icon'),
      connection,
      collectionName,
      pluginOptions: component.pluginOptions,
      attributes: formatAttributes(component),
    },
  };
};

/**
 * Creates a component and handle the nested components sent with it
 */
export const createComponent = async ({ component, components = [] }: any) => {
  const builder = createBuilder();

  const uidMap = builder.createNewComponentUIDMap(components);
  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);

  const newComponent = builder.createComponent(replaceTmpUIDs(component));

  components.forEach((component: any) => {
    if (!has(component, 'uid')) {
      return builder.createComponent(replaceTmpUIDs(component));
    }

    return builder.editComponent(replaceTmpUIDs(component));
  });

  await builder.writeFiles();

  strapi.eventHub.emit('component.create', { component: newComponent });

  return newComponent;
};

type ComponentToCreate = {
  component: Struct.ComponentSchema;
  components?: Struct.ComponentSchema[];
};

export const editComponent = async (
  uid: Internal.UID.Component,
  { component, components = [] }: ComponentToCreate
) => {
  const builder = createBuilder();

  const uidMap = builder.createNewComponentUIDMap(components);
  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);

  const updatedComponent = builder.editComponent({
    uid,
    ...replaceTmpUIDs(component),
  });

  components.forEach((component) => {
    if (!has(component, 'uid')) {
      return builder.createComponent(replaceTmpUIDs(component));
    }

    return builder.editComponent(replaceTmpUIDs(component));
  });

  await builder.writeFiles();

  strapi.eventHub.emit('component.update', { component: updatedComponent });

  return updatedComponent;
};

export const deleteComponent = async (uid: Internal.UID.Component) => {
  const builder = createBuilder();

  const deletedComponent = builder.deleteComponent(uid);

  await builder.writeFiles();

  strapi.eventHub.emit('component.delete', { component: deletedComponent });

  return deletedComponent;
};
</file>

<file path="server/src/services/constants.ts">
export const modelTypes = {
  CONTENT_TYPE: 'CONTENT_TYPE',
  COMPONENT: 'COMPONENT',
} as const;

export const typeKinds = {
  SINGLE_TYPE: 'singleType',
  COLLECTION_TYPE: 'collectionType',
} as const;

export const DEFAULT_TYPES = [
  // advanced types
  'media',

  // scalar types
  'string',
  'text',
  'richtext',
  'blocks',
  'json',
  'enumeration',
  'password',
  'email',
  'integer',
  'biginteger',
  'float',
  'decimal',
  'date',
  'time',
  'datetime',
  'timestamp',
  'boolean',

  'relation',
] as const;

export const VALID_UID_TARGETS = ['string', 'text'] as const;

export const coreUids = {
  STRAPI_USER: 'admin::user',
  PREFIX: 'strapi::',
} as const;

export const pluginsUids = {
  UPLOAD_FILE: 'plugin::upload.file',
} as const;
</file>

<file path="server/src/services/content-types.ts">
import _ from 'lodash';
import { getOr } from 'lodash/fp';
import { contentTypes as contentTypesUtils, errors } from '@strapi/utils';
import type { UID, Struct } from '@strapi/types';
import { formatAttributes, replaceTemporaryUIDs } from '../utils/attributes';
import createBuilder from './schema-builder';
import { coreUids, pluginsUids } from './constants';

const { ApplicationError } = errors;

export const isContentTypeVisible = (model: Struct.ContentTypeSchema) =>
  getOr(true, 'pluginOptions.content-type-builder.visible', model) === true;

export const getRestrictRelationsTo = (contentType: Struct.ContentTypeSchema) => {
  const { uid } = contentType;
  if (uid === coreUids.STRAPI_USER) {
    // TODO: replace with an obj { relation: 'x', bidirectional: true|false }
    return ['oneWay', 'manyWay'];
  }

  if (
    uid.startsWith(coreUids.PREFIX) ||
    uid === pluginsUids.UPLOAD_FILE ||
    !isContentTypeVisible(contentType)
  ) {
    return [];
  }

  return null;
};

/**
 * Format a contentType info to be used by the front-end
 */
export const formatContentType = (contentType: any) => {
  const { uid, kind, modelName, plugin, collectionName, info } = contentType;

  return {
    uid,
    plugin,
    apiID: modelName,
    schema: {
      ...contentTypesUtils.getOptions(contentType),
      displayName: info.displayName,
      singularName: info.singularName,
      pluralName: info.pluralName,
      description: _.get(info, 'description', ''),
      pluginOptions: contentType.pluginOptions,
      kind: kind || 'collectionType',
      collectionName,
      attributes: formatAttributes(contentType),
      visible: isContentTypeVisible(contentType),
      restrictRelationsTo: getRestrictRelationsTo(contentType),
    },
  };
};

export const createContentTypes = async (contentTypes: any[]) => {
  const builder = createBuilder();
  const createdContentTypes: any[] = [];

  for (const contentType of contentTypes) {
    createdContentTypes.push(await createContentType(contentType, { defaultBuilder: builder }));
  }

  await builder.writeFiles();

  return createdContentTypes;
};

type CreateContentTypeOptions = {
  defaultBuilder?: any; // TODO
};

/**
 * Creates a content type and handle the nested components sent with it
 */
export const createContentType = async (
  { contentType, components }: any,
  options: CreateContentTypeOptions = {}
) => {
  const builder = options.defaultBuilder || createBuilder();
  const uidMap = builder.createNewComponentUIDMap(components || []);

  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);

  const newContentType = builder.createContentType(replaceTmpUIDs(contentType));

  // allow components to target the new contentType
  const targetContentType = (infos: any) => {
    Object.keys(infos.attributes).forEach((key) => {
      const { target } = infos.attributes[key];
      if (target === '__contentType__') {
        infos.attributes[key].target = newContentType.uid;
      }
    });

    return infos;
  };

  components?.forEach((component: any) => {
    const options = replaceTmpUIDs(targetContentType(component));

    if (!_.has(component, 'uid')) {
      return builder.createComponent(options);
    }

    return builder.editComponent(options);
  });

  // generate api skeleton
  await generateAPI({
    displayName: contentType!.displayName || contentType!.info.displayName,
    singularName: contentType!.singularName,
    pluralName: contentType!.pluralName,
    kind: contentType!.kind,
  });

  if (!options.defaultBuilder) {
    await builder.writeFiles();
  }

  strapi.eventHub.emit('content-type.create', { contentType: newContentType });

  return newContentType;
};

/**
 * Generate an API skeleton
 */
export const generateAPI = ({
  singularName,
  kind = 'collectionType',
  pluralName,
  displayName,
}: any) => {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const strapiGenerators = require('@strapi/generators');
  return strapiGenerators.generate(
    'content-type',
    {
      kind,
      singularName,
      id: singularName,
      pluralName,
      displayName,
      destination: 'new',
      bootstrapApi: true,
      attributes: [],
    },
    { dir: strapi.dirs.app.root }
  );
};

/**
 * Edits a contentType and handle the nested contentTypes sent with it
 */
export const editContentType = async (
  uid: UID.ContentType,
  { contentType, components = [] }: any
) => {
  const builder = createBuilder();

  const previousSchema = builder.contentTypes.get(uid).schema;
  const previousKind = previousSchema.kind;
  const newKind = contentType.kind || previousKind;

  // Restore non-visible attributes from previous schema
  const previousAttributes = previousSchema.attributes;
  const prevNonVisibleAttributes = contentTypesUtils
    .getNonVisibleAttributes(previousSchema)
    .reduce((acc, key) => {
      if (key in previousAttributes) {
        acc[key] = previousAttributes[key];
      }

      return acc;
    }, {} as any);
  contentType.attributes = _.merge(prevNonVisibleAttributes, contentType.attributes);

  if (newKind !== previousKind && newKind === 'singleType') {
    const entryCount = await strapi.db.query(uid).count();
    if (entryCount > 1) {
      throw new ApplicationError(
        'You cannot convert a collectionType to a singleType when having multiple entries in DB'
      );
    }
  }

  const uidMap = builder.createNewComponentUIDMap(components);
  const replaceTmpUIDs = replaceTemporaryUIDs(uidMap);

  const updatedContentType = builder.editContentType({
    uid,
    ...replaceTmpUIDs(contentType),
  });

  components.forEach((component: any) => {
    if (!_.has(component, 'uid')) {
      return builder.createComponent(replaceTmpUIDs(component));
    }

    return builder.editComponent(replaceTmpUIDs(component));
  });

  if (newKind !== previousKind) {
    const apiHandler = strapi.plugin('content-type-builder').service('api-handler');
    await apiHandler.backup(uid);

    try {
      await apiHandler.clear(uid);

      // generate new api skeleton
      await generateAPI({
        displayName: updatedContentType.schema.info.displayName,
        singularName: updatedContentType.schema.info.singularName,
        pluralName: updatedContentType.schema.info.pluralName,
        kind: updatedContentType.schema.kind,
      });

      await builder.writeFiles();
    } catch (error) {
      strapi.log.error(error);
      await apiHandler.rollback(uid);
    }

    return updatedContentType;
  }

  await builder.writeFiles();

  strapi.eventHub.emit('content-type.update', { contentType: updatedContentType });

  return updatedContentType;
};

export const deleteContentTypes = async (uids: UID.ContentType[]) => {
  const builder = createBuilder();
  const apiHandler = strapi.plugin('content-type-builder').service('api-handler');

  for (const uid of uids) {
    await deleteContentType(uid, builder);
  }

  await builder.writeFiles();
  for (const uid of uids) {
    try {
      await apiHandler.clear(uid);
    } catch (error) {
      strapi.log.error(error);
      await apiHandler.rollback(uid);
    }
  }
};

/**
 * Deletes a content type and the api files related to it
 */
export const deleteContentType = async (uid: UID.ContentType, defaultBuilder: any = undefined) => {
  const builder = defaultBuilder || createBuilder();
  // make a backup
  const apiHandler = strapi.plugin('content-type-builder').service('api-handler');
  await apiHandler.backup(uid);

  const contentType = builder.deleteContentType(uid);

  if (!defaultBuilder) {
    try {
      await builder.writeFiles();
      await apiHandler.clear(uid);
    } catch (error) {
      await apiHandler.rollback(uid);
    }
  }

  strapi.eventHub.emit('content-type.delete', { contentType });

  return contentType;
};
</file>

<file path="server/src/services/index.ts">
import * as contentTypes from './content-types';
import * as components from './components';
import * as componentCategories from './component-categories';
import * as builder from './builder';
import * as apiHandler from './api-handler';

export default {
  'content-types': contentTypes,
  components,
  'component-categories': componentCategories,
  builder,
  'api-handler': apiHandler,
};
</file>

<file path="server/src/utils/attributes.ts">
import _ from 'lodash';
import utils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';

const { ApplicationError } = errors;

export const isConfigurable = (attribute: Schema.Attribute.AnyAttribute) =>
  _.get(attribute, 'configurable', true);

export const isRelation = (attribute: Schema.Attribute.AnyAttribute) =>
  attribute.type === 'relation';

/**
 * Formats a component's attributes
 */
export const formatAttributes = (model: any) => {
  const { getVisibleAttributes } = utils.contentTypes;

  // only get attributes that can be seen in the CTB
  return getVisibleAttributes(model).reduce((acc: any, key) => {
    acc[key] = formatAttribute(model.attributes[key]);
    return acc;
  }, {});
};

/**
 * Formats a component attribute
 */
export const formatAttribute = (attribute: Schema.Attribute.AnyAttribute & Record<string, any>) => {
  const { configurable, required, autoPopulate, pluginOptions } = attribute;

  if (attribute.type === 'media') {
    return {
      type: 'media',
      multiple: !!attribute.multiple,
      required: !!required,
      configurable: configurable === false ? false : undefined,
      private: !!attribute.private,
      allowedTypes: attribute.allowedTypes,
      pluginOptions,
    };
  }

  if (attribute.type === 'relation') {
    return {
      ...attribute,
      type: 'relation',
      target: attribute.target,
      targetAttribute: attribute.inversedBy || attribute.mappedBy || null,
      configurable: configurable === false ? false : undefined,
      private: !!attribute.private,
      pluginOptions,
      // TODO: remove
      autoPopulate,
    };
  }

  return attribute;
};

// TODO: move to schema builder
export const replaceTemporaryUIDs = (uidMap: any) => (schema: any) => {
  return {
    ...schema,
    attributes: Object.keys(schema.attributes).reduce((acc: any, key) => {
      const attr = schema.attributes[key];
      if (attr.type === 'component') {
        if (_.has(uidMap, attr.component)) {
          acc[key] = {
            ...attr,
            component: uidMap[attr.component],
          };

          return acc;
        }

        if (!_.has(strapi.components, attr.component)) {
          throw new ApplicationError('component.notFound');
        }
      }

      if (
        attr.type === 'dynamiczone' &&
        _.intersection(attr.components, Object.keys(uidMap)).length > 0
      ) {
        acc[key] = {
          ...attr,
          components: attr.components.map((value: any) => {
            if (_.has(uidMap, value)) return uidMap[value];

            if (!_.has(strapi.components, value)) {
              throw new ApplicationError('component.notFound');
            }

            return value;
          }),
        };

        return acc;
      }

      acc[key] = attr;
      return acc;
    }, {}),
  };
};
</file>

<file path="server/src/utils/helpers.ts">
export const escapeNewlines = (content = '', placeholder = '\n') => {
  return content.replace(/[\r\n]+/g, placeholder);
};

export const deepTrimObject = (attribute: string | object): string | object => {
  if (Array.isArray(attribute)) {
    return attribute.map(deepTrimObject);
  }

  if (typeof attribute === 'object') {
    return Object.entries(attribute).reduce((acc, [key, value]) => {
      const trimmedObject = deepTrimObject(value);

      return { ...acc, [key]: trimmedObject };
    }, {});
  }

  return typeof attribute === 'string' ? attribute.trim() : attribute;
};
</file>

<file path="server/src/utils/index.ts">
import type * as components from '../services/components';
import type * as builder from '../services/builder';
import type * as contentTypes from '../services/content-types';
import type * as componentCategories from '../services/component-categories';
import type * as apiHandler from '../services/api-handler';

type S = {
  'content-types': typeof contentTypes;
  components: typeof components;
  'component-categories': typeof componentCategories;
  builder: typeof builder;
  'api-handler': typeof apiHandler;
};

export function getService<T extends keyof S>(
  name: T
): S[T] extends (...args: any[]) => any ? ReturnType<S[T]> : S[T] {
  return strapi.plugin('content-type-builder').service(name);
}
</file>

<file path="server/src/utils/typeguards.ts">
import type { Schema } from '@strapi/types';

export const hasDefaultAttribute = (
  attribute: Schema.Attribute.AnyAttribute
): attribute is Schema.Attribute.AnyAttribute & Schema.Attribute.DefaultOption<unknown> => {
  return 'default' in attribute;
};
</file>

<file path="server/src/bootstrap.ts">
import type { Core } from '@strapi/types';

export default async ({ strapi }: { strapi: Core.Strapi }) => {
  const actions = [
    {
      section: 'plugins',
      displayName: 'Read',
      uid: 'read',
      pluginName: 'content-type-builder',
    },
  ];

  await strapi.service('admin::permission').actionProvider.registerMany(actions);
};
</file>

<file path="server/src/config.ts">
export default {
  default: {},
  validator() {},
};
</file>

<file path="server/src/index.ts">
// eslint-disable-next-line import/no-extraneous-dependencies
import '@strapi/types';

import config from './config';
import bootstrap from './bootstrap';
import services from './services';
import controllers from './controllers';
import routes from './routes';

export default () => ({
  config,
  bootstrap,
  services,
  controllers,
  routes,
});
</file>

<file path="jest.config.front.js">
'use strict';

module.exports = {
  preset: '../../../jest-preset.front.js',
  displayName: 'Core content-type-builder',
  testEnvironment: 'jsdom',
};
</file>

<file path="jest.config.js">
'use strict';

module.exports = {
  preset: '../../../jest-preset.unit.js',
  transform: {
    '^.+\\.ts$': ['@swc/jest'],
  },
  testMatch: ['<rootDir>/**/__tests__/*.test.ts'],
  displayName: 'Core content-type-builder',
  testEnvironment: 'jsdom',
};
</file>

<file path="README.md">
# Strapi plugin
</file>

</files>
