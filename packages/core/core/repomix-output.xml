This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-07T09:01:27.688Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  configuration/
    config-loader.ts
    get-dirs.ts
    index.ts
    urls.ts
  core-api/
    __tests__/
      controller.test.ts
    controller/
      __tests__/
        transform.test.ts
      collection-type.ts
      index.ts
      single-type.ts
      transform.ts
    routes/
      index.ts
    service/
      __tests__/
        index.test.ts
        pagination.test.ts
      collection-type.ts
      core-service.ts
      index.ts
      pagination.ts
      single-type.ts
  domain/
    content-type/
      index.ts
      validator.ts
    module/
      index.ts
      validation.ts
  ee/
    index.ts
    license.ts
  loaders/
    plugins/
      get-enabled-plugins.ts
      get-user-plugins-config.ts
      index.ts
    admin.ts
    apis.ts
    components.ts
    index.ts
    middlewares.ts
    policies.ts
    sanitizers.ts
    src-index.ts
    validators.ts
  middlewares/
    __tests__/
      errors.test.ts
      security.test.ts
    body.ts
    compression.ts
    cors.ts
    errors.ts
    favicon.ts
    index.ts
    ip.ts
    logger.ts
    powered-by.ts
    public.ts
    query.ts
    response-time.ts
    responses.ts
    security.ts
    session.ts
  migrations/
    __tests__/
      i18n.test.ts
    database/
      5.0.0-discard-drafts.ts
    draft-publish.ts
    i18n.ts
    index.ts
  providers/
    admin.ts
    coreStore.ts
    cron.ts
    index.ts
    provider.ts
    registries.ts
    telemetry.ts
    webhooks.ts
  registries/
    __tests__/
      components.test.ts
      config.test.ts
      custom-fields.test.ts
      policies.test.ts
    apis.ts
    components.ts
    content-types.ts
    controllers.ts
    custom-fields.ts
    hooks.ts
    index.ts
    middlewares.ts
    models.ts
    modules.ts
    namespace.ts
    plugins.ts
    policies.ts
    sanitizers.ts
    services.ts
    validators.ts
  services/
    __tests__/
      content-api-permissions.test.ts
      core-store.test.ts
      event-hub.test.ts
      fs.test.ts
      worker-queue.test.ts
    auth/
      index.ts
    content-api/
      permissions/
        providers/
          action.ts
          condition.ts
          index.ts
        engine.ts
        index.ts
      index.ts
    document-service/
      __tests__/
        middlewares.test.ts
      attributes/
        index.ts
        transforms.ts
      middlewares/
        errors.ts
        index.ts
        middleware-manager.ts
      transform/
        __tests__/
          fields.test.ts
          id-map.test.ts
          id-transform-i18n.test.ts
          id-transform-no-dp.test.ts
          id-transform.test.ts
          map-relation.test.ts
          populate.test.ts
          utils.ts
        relations/
          extract/
            data-ids.ts
          transform/
            data-ids.ts
            default-locale.ts
          utils/
            data.ts
            dp.ts
            i18n.ts
            map-relation.ts
            types.ts
        data.ts
        fields.ts
        id-map.ts
        id-transform.ts
        populate.ts
        query.ts
        types.ts
      utils/
        populate.ts
        unidirectional-relations.ts
      common.ts
      components.ts
      draft-and-publish.ts
      entries.ts
      events.ts
      index.ts
      internationalization.ts
      params.ts
      repository.ts
    entity-service/
      __tests__/
        entity-service.test.ts
      index.ts
    entity-validator/
      __tests__/
        relations/
          utils/
            relations.testdata.ts
          attribute-level.test.ts
          component-level.test.ts
          dynamic-zone-level.test.ts
          media-level.test.ts
        utils/
          index.ts
        biginteger-validators.test.ts
        blocks-validators.test.ts
        date-validators.test.ts
        datetime-validators.test.ts
        email-validators.test.ts
        enumeration-validators.test.ts
        float-validators.test.ts
        index.test.ts
        integer-validators.test.ts
        string-validators.test.ts
        time-validators.test.ts
        timestamp-validators.test.ts
        uid-validators.test.ts
      blocks-validator.ts
      index.ts
      validators.ts
    metrics/
      __tests__/
        admin-user-hash.test.ts
        index.test.ts
        is-truthy.test.ts
        middleware.test.ts
        rate-limiter.test.ts
      admin-user-hash.ts
      index.ts
      is-truthy.ts
      middleware.ts
      rate-limiter.ts
      sender.ts
    server/
      admin-api.ts
      api.ts
      compose-endpoint.ts
      content-api.ts
      http-server.ts
      index.ts
      koa.ts
      middleware.ts
      policy.ts
      register-middlewares.ts
      register-routes.ts
      routing.ts
    utils/
      dynamic-zones.ts
    config.ts
    core-store.ts
    cron.ts
    custom-fields.ts
    errors.ts
    event-hub.ts
    features.ts
    fs.ts
    query-params.ts
    reloader.ts
    request-context.ts
    webhook-runner.ts
    webhook-store.ts
    worker-queue.ts
  utils/
    __tests__/
      convert-custom-field-type.test.ts
      filepath-to-prop-path.test.ts
      transform-content-types-to-models.test.ts
    update-notifier/
      index.ts
    convert-custom-field-type.ts
    cron.ts
    ee.ts
    fetch.ts
    filepath-to-prop-path.ts
    index.ts
    is-initialized.ts
    lifecycles.ts
    load-config-file.ts
    load-files.ts
    open-browser.ts
    resolve-working-dirs.ts
    signals.ts
    startup-logger.ts
    transform-content-types-to-models.ts
  compile.ts
  container.ts
  factories.ts
  index.ts
  modules.d.ts
  Strapi.ts
.eslintrc.js
jest.config.js
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/configuration/config-loader.ts">
import path from 'path';
import fs from 'fs';
import { loadConfigFile } from '../utils/load-config-file';

const VALID_EXTENSIONS = ['.js', '.json'];

// These filenames are restricted, but will also emit a warning that the filename is probably a mistake
const MISTAKEN_FILENAMES = {
  middleware: 'middlewares',
  plugin: 'plugins',
};

// the following are restricted to prevent conflicts with existing STRAPI_* env vars or root level config options
// must all be lowercase to match validator
const RESTRICTED_FILENAMES = [
  // existing env vars
  'uuid',
  'hosting',
  'license',
  'enforce',
  'disable',
  'enable',
  'telemetry',

  // reserved for future internal use
  'strapi',
  'internal',

  // root level config options
  // TODO: it would be better to move these out of the root config and allow them to be loaded
  'launchedAt',
  'serveAdminPanel',
  'autoReload',
  'environment',
  'packageJsonStrapi',
  'info',
  'autoReload',
  'dirs',

  // probably mistaken/typo filenames
  ...Object.keys(MISTAKEN_FILENAMES),
];

// Existing Strapi configuration files
const STRAPI_CONFIG_FILENAMES = [
  'admin',
  'server',
  'api',
  'database',
  'middlewares',
  'plugins',
  'features',
];

// Note: we don't have access to strapi logger at this point so we can't use it
const logWarning = (message: string) => {
  console.warn(message);
};

export default (dir: string) => {
  if (!fs.existsSync(dir)) return {};

  const allFiles = fs.readdirSync(dir, { withFileTypes: true });
  const seenFilenames = new Set<string>();
  const configFiles = allFiles.reduce((acc, file) => {
    const baseName = path.basename(file.name, path.extname(file.name));
    const baseNameLower = baseName.toLowerCase();
    const extension = path.extname(file.name);
    const extensionLower = extension.toLowerCase();

    if (!file.isFile()) {
      return acc;
    }

    if (!VALID_EXTENSIONS.includes(extensionLower)) {
      logWarning(
        `Config file not loaded, extension must be one of ${VALID_EXTENSIONS.join(',')}): ${
          file.name
        }`
      );
      return acc;
    }

    if (RESTRICTED_FILENAMES.includes(baseNameLower)) {
      logWarning(`Config file not loaded, restricted filename: ${file.name}`);

      // suggest the filename they probably meant
      if (baseNameLower in MISTAKEN_FILENAMES) {
        console.log(
          `Did you mean ${MISTAKEN_FILENAMES[baseNameLower as keyof typeof MISTAKEN_FILENAMES]}]} ?`
        );
      }

      return acc;
    }

    // restricted names and Strapi configs are also restricted from being prefixes
    const restrictedPrefix = [...RESTRICTED_FILENAMES, ...STRAPI_CONFIG_FILENAMES].find(
      (restrictedName) =>
        restrictedName.startsWith(baseNameLower) && restrictedName !== baseNameLower
    );
    if (restrictedPrefix) {
      logWarning(
        `Config file not loaded, filename cannot start with ${restrictedPrefix}: ${file.name}`
      );
    }

    /**
     *  Note: If user config files contain non-alpha-numeric characters, we won't be able to auto-load env
     * into them.
     *
     * For the initial feature, we will only load our internal configs, but later when we provide a method
     * to define the shape of custom configs, we will need to warn that those filenames can't be loaded
     * for technical limitations on env variable names
     *  */
    // if (!/^[A-Za-z0-9]+$/.test(baseName)) {
    //   logWarning("Using a non-alphanumeric config file name prevents Strapi from auto-loading it from environment variables.")
    // }

    // filter filenames without case-insensitive uniqueness
    if (seenFilenames.has(baseNameLower)) {
      logWarning(
        `Config file not loaded, case-insensitive name matches other config file: ${file.name}`
      );
      return acc;
    }
    seenFilenames.add(baseNameLower);

    // If file passes all filters, add it to the accumulator
    acc.push(file);
    return acc;
  }, [] as fs.Dirent[]);

  return configFiles.reduce(
    (acc, file) => {
      const key = path.basename(file.name, path.extname(file.name));

      acc[key] = loadConfigFile(path.resolve(dir, file.name));

      return acc;
    },
    {} as Record<string, unknown>
  );
};
</file>

<file path="src/configuration/get-dirs.ts">
import { join, resolve } from 'path';
import { get } from 'lodash/fp';

import type { Core } from '@strapi/types';
import type { StrapiOptions } from '../Strapi';

export type Options = {
  app: string;
  dist: string;
};

export const getDirs = (
  { appDir, distDir }: StrapiOptions,
  config: { server: Partial<Core.Config.Server> }
): Core.StrapiDirectories => ({
  dist: {
    root: distDir,
    src: join(distDir, 'src'),
    api: join(distDir, 'src', 'api'),
    components: join(distDir, 'src', 'components'),
    extensions: join(distDir, 'src', 'extensions'),
    policies: join(distDir, 'src', 'policies'),
    middlewares: join(distDir, 'src', 'middlewares'),
    config: join(distDir, 'config'),
  },
  app: {
    root: appDir,
    src: join(appDir, 'src'),
    api: join(appDir, 'src', 'api'),
    components: join(appDir, 'src', 'components'),
    extensions: join(appDir, 'src', 'extensions'),
    policies: join(appDir, 'src', 'policies'),
    middlewares: join(appDir, 'src', 'middlewares'),
    config: join(appDir, 'config'),
  },
  static: {
    public: resolve(appDir, get('server.dirs.public', config)),
  },
});
</file>

<file path="src/configuration/index.ts">
/* eslint-disable @typescript-eslint/no-var-requires */
import os from 'os';
import path from 'path';
import _ from 'lodash';
import { omit } from 'lodash/fp';
import dotenv from 'dotenv';
import type { Core } from '@strapi/types';
import { strings } from '@strapi/utils';

import { getConfigUrls, getAbsoluteAdminUrl, getAbsoluteServerUrl } from './urls';
import loadConfigDir from './config-loader';
import { getDirs } from './get-dirs';

import type { StrapiOptions } from '../Strapi';
import { version as strapiVersion } from '../../package.json';

dotenv.config({ path: process.env.ENV_PATH });

process.env.NODE_ENV = process.env.NODE_ENV || 'development';

const defaultConfig = {
  server: {
    host: process.env.HOST || os.hostname() || 'localhost',
    port: Number(process.env.PORT) || 1337,
    proxy: false,
    cron: { enabled: false },
    admin: { autoOpen: false },
    dirs: { public: './public' },
    transfer: {
      remote: {
        enabled: true,
      },
    },
    logger: {
      updates: {
        enabled: true,
      },
      startup: {
        enabled: true,
      },
    },
  } satisfies Partial<Core.Config.Server>,
  admin: {} satisfies Partial<Core.Config.Admin>,
  api: {
    rest: {
      prefix: '/api',
    },
  } satisfies Partial<Core.Config.Api>,
};

export const loadConfiguration = (opts: StrapiOptions) => {
  const { appDir, distDir, autoReload = false, serveAdminPanel = true } = opts;

  const pkgJSON = require(path.resolve(appDir, 'package.json'));

  const configDir = path.resolve(distDir || process.cwd(), 'config');

  const rootConfig = {
    launchedAt: Date.now(),
    autoReload,
    environment: process.env.NODE_ENV,
    uuid: _.get(pkgJSON, 'strapi.uuid'),
    packageJsonStrapi: _.omit(_.get(pkgJSON, 'strapi', {}), 'uuid'),
    info: {
      ...pkgJSON,
      strapi: strapiVersion,
    },
    admin: {
      serveAdminPanel,
    },
  };

  // See packages/core/core/src/domain/module/index.ts for plugin config loading
  const baseConfig = omit('plugins', loadConfigDir(configDir)); // plugin config will be loaded later

  const envDir = path.resolve(configDir, 'env', process.env.NODE_ENV as string);
  const envConfig = loadConfigDir(envDir);

  const config = _.merge(rootConfig, defaultConfig, baseConfig, envConfig);

  const { serverUrl, adminUrl } = getConfigUrls(config);

  const serverAbsoluteUrl = getAbsoluteServerUrl(config);
  const adminAbsoluteUrl = getAbsoluteAdminUrl(config);

  const sameOrigin = new URL(adminAbsoluteUrl).origin === new URL(serverAbsoluteUrl).origin;

  const adminPath = sameOrigin
    ? adminUrl.replace(strings.getCommonPath(serverUrl, adminUrl), '')
    : new URL(adminUrl).pathname;

  _.set(config, 'server.url', serverUrl);
  _.set(config, 'server.absoluteUrl', serverAbsoluteUrl);
  _.set(config, 'admin.url', adminUrl);
  _.set(config, 'admin.path', adminPath);
  _.set(config, 'admin.absoluteUrl', adminAbsoluteUrl);
  _.set(config, 'dirs', getDirs(opts, config));

  return config;
};
</file>

<file path="src/configuration/urls.ts">
import _ from 'lodash';
import { strings } from '@strapi/utils';

interface ServerConfig {
  url: string;
  host: string;
  port: number | string;
}

export const getConfigUrls = (config: Record<string, unknown>, forAdminBuild = false) => {
  const serverConfig = config.server as ServerConfig;
  const adminConfig = config.admin;

  // Defines serverUrl value
  let serverUrl = _.get(serverConfig, 'url', '');
  serverUrl = _.trim(serverUrl, '/ ');
  if (typeof serverUrl !== 'string') {
    throw new Error('Invalid server url config. Make sure the url is a string.');
  }

  if (serverUrl.startsWith('http')) {
    try {
      serverUrl = _.trim(new URL(serverConfig.url).toString(), '/');
    } catch (e) {
      throw new Error(
        'Invalid server url config. Make sure the url defined in server.js is valid.'
      );
    }
  } else if (serverUrl !== '') {
    serverUrl = `/${serverUrl}`;
  }

  // Defines adminUrl value
  let adminUrl = _.get(adminConfig, 'url', '/admin');
  adminUrl = _.trim(adminUrl, '/ ');
  if (typeof adminUrl !== 'string') {
    throw new Error('Invalid admin url config. Make sure the url is a non-empty string.');
  }
  if (adminUrl.startsWith('http')) {
    try {
      adminUrl = _.trim(new URL(adminUrl).toString(), '/');
    } catch (e) {
      throw new Error('Invalid admin url config. Make sure the url defined in server.js is valid.');
    }
  } else {
    adminUrl = `${serverUrl}/${adminUrl}`;
  }

  // Defines adminPath value
  let adminPath = adminUrl;
  if (
    serverUrl.startsWith('http') &&
    adminUrl.startsWith('http') &&
    new URL(adminUrl).origin === new URL(serverUrl).origin &&
    !forAdminBuild
  ) {
    adminPath = adminUrl.replace(strings.getCommonPath(serverUrl, adminUrl), '');
    adminPath = `/${_.trim(adminPath, '/')}`;
  } else if (adminUrl.startsWith('http')) {
    adminPath = new URL(adminUrl).pathname;
  }

  return {
    serverUrl,
    adminUrl,
    adminPath,
  };
};

const getAbsoluteUrl =
  (adminOrServer: 'admin' | 'server') =>
  (config: Record<string, unknown>, forAdminBuild = false) => {
    const { serverUrl, adminUrl } = getConfigUrls(config, forAdminBuild);
    const url = adminOrServer === 'server' ? serverUrl : adminUrl;

    if (url.startsWith('http')) {
      return url;
    }

    const serverConfig = config.server as ServerConfig;
    const hostname =
      config.environment === 'development' && ['127.0.0.1', '0.0.0.0'].includes(serverConfig.host)
        ? 'localhost'
        : serverConfig.host;

    return `http://${hostname}:${serverConfig.port}${url}`;
  };

export const getAbsoluteAdminUrl = getAbsoluteUrl('admin');
export const getAbsoluteServerUrl = getAbsoluteUrl('server');
</file>

<file path="src/core-api/__tests__/controller.test.ts">
import { createController } from '../controller';

describe('Default Controller', () => {
  test('Creates Collection Type default actions', () => {
    const service = {};
    const contentType = {
      modelName: 'testModel',
      kind: 'collectionType',
    };

    const controller = createController({ service, contentType });

    expect(controller).toEqual({
      find: expect.any(Function),
      findOne: expect.any(Function),
      create: expect.any(Function),
      update: expect.any(Function),
      delete: expect.any(Function),
    });
  });

  test('Creates Single Type default actions', () => {
    const service = {};
    const contentType = {
      modelName: 'testModel',
      kind: 'singleType',
    };

    const controller = createController({ service, contentType });

    expect(controller).toEqual({
      find: expect.any(Function),
      update: expect.any(Function),
      delete: expect.any(Function),
    });
  });
});
</file>

<file path="src/core-api/controller/__tests__/transform.test.ts">
import type { Schema } from '@strapi/types';
import * as transforms from '../transform';

describe('Transforms', () => {
  test('v4 - using json api format', () => {
    const contentType: Schema.ContentType = {
      globalId: 'test',
      kind: 'collectionType',
      modelName: 'test',
      modelType: 'contentType',
      uid: 'api::test.test',
      info: {
        displayName: 'test',
        pluralName: 'tests',
        singularName: 'test',
      },
      attributes: {
        title: {
          type: 'string',
        },
        relation: {
          type: 'relation',
          relation: 'oneToOne',
          target: 'api::relation.relation',
        },
        media: {
          type: 'media',
        },
        multiMedia: {
          type: 'media',
          multiple: true,
        },
        repeatableCompo: {
          type: 'component',
          repeatable: true,
          component: 'default.test',
        },
        compo: {
          type: 'component',
          component: 'default.test',
        },
        dz: {
          type: 'dynamiczone',
          components: ['default.test'],
        },
      },
    };

    global.strapi = {
      contentType() {
        return undefined;
      },
      components: {
        'default.test': {
          attributes: {
            name: {
              type: 'string',
            },
          },
        },
      },
    } as any;

    expect(
      transforms.transformResponse(
        {
          id: 1,
          documentId: 'abcd',
          title: 'Hello',
          relation: { id: 1, documentId: 'abcd', value: 'test' },
          media: { id: 1, documentId: 'abcd', value: 'test' },
          multiMedia: [{ id: 1, documentId: 'abcd', value: 'test' }],
          repeatableCompo: [{ id: 1, name: 'test' }],
          compo: { id: 1, name: 'test' },
          dz: [{ id: 2, name: 'test', __component: 'default.test' }],
        },
        undefined,
        { contentType, useJsonAPIFormat: true }
      )
    ).toStrictEqual({
      data: {
        id: 1,
        documentId: 'abcd',
        attributes: {
          title: 'Hello',
          relation: {
            data: {
              id: 1,
              documentId: 'abcd',
              attributes: { value: 'test' },
            },
          },
          media: {
            data: {
              id: 1,
              documentId: 'abcd',
              attributes: {
                value: 'test',
              },
            },
          },
          multiMedia: {
            data: [
              {
                id: 1,
                documentId: 'abcd',
                attributes: {
                  value: 'test',
                },
              },
            ],
          },
          repeatableCompo: [
            {
              id: 1,
              name: 'test',
            },
          ],
          compo: {
            id: 1,
            name: 'test',
          },
          dz: [
            {
              __component: 'default.test',
              id: 2,
              name: 'test',
            },
          ],
        },
      },
      meta: {},
    });
  });

  test('Leaves nil values untouched', () => {
    expect(transforms.transformResponse()).toBeUndefined();
    expect(transforms.transformResponse(null)).toBe(null);
  });

  test('Throws if entry is not and object or an array of object', () => {
    expect(() => transforms.transformResponse(0)).toThrow();
    expect(() => transforms.transformResponse(new Date())).toThrow();
    expect(() => transforms.transformResponse('azaz')).toThrow();
  });

  test('Handles arrays of entries', () => {
    expect(transforms.transformResponse([{ id: 1, title: 'Hello' }])).toStrictEqual({
      data: [{ id: 1, title: 'Hello' }],
      meta: {},
    });
  });

  test('Handles single entry', () => {
    expect(transforms.transformResponse({ id: 1, title: 'Hello' })).toStrictEqual({
      data: { id: 1, title: 'Hello' },
      meta: {},
    });
  });

  test('Accepts any meta', () => {
    const someMeta = { foo: 'bar' };
    expect(transforms.transformResponse({ id: 1, title: 'Hello' }, someMeta)).toStrictEqual({
      data: { id: 1, title: 'Hello' },
      meta: someMeta,
    });
  });

  test('Handles relations single value', () => {
    const contentType: Schema.ContentType = {
      globalId: 'test',
      kind: 'collectionType',
      modelName: 'test',
      modelType: 'contentType',
      uid: 'api::test.test',
      info: {
        displayName: 'test',
        pluralName: 'tests',
        singularName: 'test',
      },
      attributes: {
        relation: {
          type: 'relation',
          relation: 'oneToOne',
          target: 'api::relation.relation',
        },
      },
    };

    global.strapi = {
      contentType() {
        return undefined;
      },
    } as any;

    expect(
      transforms.transformResponse(
        { id: 1, title: 'Hello', relation: { id: 1, value: 'test' } },
        undefined,
        { contentType }
      )
    ).toStrictEqual({
      data: {
        id: 1,
        title: 'Hello',
        relation: {
          id: 1,
          value: 'test',
        },
      },
      meta: {},
    });
  });

  test('Handles relations array value', () => {
    const contentType: Schema.ContentType = {
      globalId: 'test',
      kind: 'collectionType',
      modelName: 'test',
      modelType: 'contentType',
      uid: 'api::test.test',
      info: {
        displayName: 'test',
        pluralName: 'tests',
        singularName: 'test',
      },
      attributes: {
        relation: {
          type: 'relation',
          relation: 'oneToOne',
          target: 'api::relation.relation',
        },
      },
    };

    global.strapi = {
      contentType() {
        return undefined;
      },
    } as any;

    expect(
      transforms.transformResponse(
        { id: 1, title: 'Hello', relation: [{ id: 1, value: 'test' }] },
        undefined,
        { contentType }
      )
    ).toStrictEqual({
      data: {
        id: 1,
        title: 'Hello',
        relation: [
          {
            id: 1,
            value: 'test',
          },
        ],
      },
      meta: {},
    });
  });

  test('Handles relations recursively', () => {
    const contentType: Schema.ContentType = {
      globalId: 'test',
      kind: 'collectionType',
      modelName: 'test',
      modelType: 'contentType',
      uid: 'api::test.test',
      info: {
        displayName: 'test',
        pluralName: 'tests',
        singularName: 'test',
      },
      attributes: {
        relation: {
          type: 'relation',
          relation: 'oneToOne',
          target: 'api::relation.relation',
        },
      },
    };

    global.strapi = {
      contentType() {
        return {
          attributes: {
            nestedRelation: {
              type: 'relation',
              target: 'xxxx',
            },
          },
        };
      },
    } as any;

    expect(
      transforms.transformResponse(
        {
          id: 1,
          title: 'Hello',
          relation: [{ id: 1, value: 'test', nestedRelation: { id: 2, foo: 'bar' } }],
        },
        undefined,
        { contentType }
      )
    ).toStrictEqual({
      data: {
        id: 1,
        title: 'Hello',
        relation: [
          {
            id: 1,
            value: 'test',
            nestedRelation: {
              id: 2,
              foo: 'bar',
            },
          },
        ],
      },
      meta: {},
    });
  });

  test('Handles media like relations', () => {
    const contentType: Schema.ContentType = {
      globalId: 'test',
      kind: 'collectionType',
      modelName: 'test',
      modelType: 'contentType',
      uid: 'api::test.test',
      info: {
        displayName: 'test',
        pluralName: 'tests',
        singularName: 'test',
      },
      attributes: {
        media: {
          type: 'media',
        },
      },
    };

    global.strapi = {
      contentType() {
        return undefined;
      },
    } as any;

    expect(
      transforms.transformResponse(
        { id: 1, title: 'Hello', media: [{ id: 1, value: 'test' }] },
        undefined,
        { contentType }
      )
    ).toStrictEqual({
      data: {
        id: 1,
        title: 'Hello',
        media: [
          {
            id: 1,
            value: 'test',
          },
        ],
      },
      meta: {},
    });
  });

  test('Handles components & dynamic zones', () => {
    const contentType: Schema.ContentType = {
      globalId: 'test',
      kind: 'collectionType',
      modelName: 'test',
      modelType: 'contentType',
      uid: 'api::test.test',
      info: {
        displayName: 'test',
        pluralName: 'tests',
        singularName: 'test',
      },
      attributes: {
        compo: {
          type: 'component',
          component: 'default.test',
        },
        dz: {
          type: 'dynamiczone',
          components: ['default.test'],
        },
      },
    };

    global.strapi = {
      contentType() {
        return undefined;
      },
      components: {
        'default.test': {
          attributes: {
            name: {
              type: 'string',
            },
          },
        },
      },
    } as any;

    expect(
      transforms.transformResponse(
        {
          id: 1,
          title: 'Hello',
          compo: { id: 1, name: 'test' },
          dz: [{ id: 2, name: 'test', __component: 'default.test' }],
        },
        undefined,
        { contentType }
      )
    ).toStrictEqual({
      data: {
        id: 1,
        title: 'Hello',
        compo: {
          id: 1,
          name: 'test',
        },
        dz: [
          {
            __component: 'default.test',
            id: 2,
            name: 'test',
          },
        ],
      },
      meta: {},
    });
  });
});
</file>

<file path="src/core-api/controller/collection-type.ts">
import { isObject } from 'lodash/fp';
import { errors } from '@strapi/utils';
import type { Core, Struct, Utils, UID } from '@strapi/types';
import type Koa from 'koa';

interface Options {
  contentType: Struct.CollectionTypeSchema;
}

/**
 *
 * Returns a collection type controller to handle default core-api actions
 */
const createCollectionTypeController = ({
  contentType,
}: Options): Utils.PartialWithThis<Core.CoreAPI.Controller.CollectionType> => {
  const uid = contentType.uid as UID.Service;

  // TODO: transform into a class
  return {
    /**
     * Retrieve records.
     */
    async find(ctx) {
      await this.validateQuery(ctx);
      const sanitizedQuery = await this.sanitizeQuery(ctx);

      const { results, pagination } = await strapi.service(uid).find(sanitizedQuery);
      const sanitizedResults = await this.sanitizeOutput(results, ctx);
      return this.transformResponse(sanitizedResults, { pagination });
    },

    /**
     * Retrieve a record
     */
    async findOne(ctx) {
      const { id } = ctx.params;
      await this.validateQuery(ctx);
      const sanitizedQuery = await this.sanitizeQuery(ctx);

      const entity = await strapi.service(uid).findOne(id, sanitizedQuery);
      const sanitizedEntity = await this.sanitizeOutput(entity, ctx);

      return this.transformResponse(sanitizedEntity);
    },

    /**
     * Create a record.
     */
    async create(ctx) {
      await this.validateQuery(ctx);
      const sanitizedQuery = await this.sanitizeQuery(ctx);

      const { body = {} as any } = ctx.request;

      if (!isObject(body.data)) {
        throw new errors.ValidationError('Missing "data" payload in the request body');
      }

      await this.validateInput(body.data, ctx);

      const sanitizedInputData = await this.sanitizeInput(body.data, ctx);

      const entity = await strapi.service(uid).create({
        ...sanitizedQuery,
        data: sanitizedInputData,
      });

      const sanitizedEntity = await this.sanitizeOutput(entity, ctx);

      ctx.status = 201;
      return this.transformResponse(sanitizedEntity);
    },

    /**
     * Update a record.
     */
    async update(ctx: Koa.Context) {
      const { id } = ctx.params;
      await this.validateQuery(ctx);
      const sanitizedQuery = await this.sanitizeQuery(ctx);

      const { body = {} as any } = ctx.request;

      if (!isObject(body.data)) {
        throw new errors.ValidationError('Missing "data" payload in the request body');
      }

      await this.validateInput(body.data, ctx);

      const sanitizedInputData = await this.sanitizeInput(body.data, ctx);

      const entity = await strapi.service(uid).update(id, {
        ...sanitizedQuery,
        data: sanitizedInputData,
      });

      const sanitizedEntity = await this.sanitizeOutput(entity, ctx);

      return this.transformResponse(sanitizedEntity);
    },

    /**
     * Destroy a record.
     */
    async delete(ctx) {
      const { id } = ctx.params;
      await this.validateQuery(ctx);
      const sanitizedQuery = await this.sanitizeQuery(ctx);

      await strapi.service(uid).delete(id, sanitizedQuery);

      ctx.status = 204;
    },
  };
};

export { createCollectionTypeController };
</file>

<file path="src/core-api/controller/index.ts">
import { prop } from 'lodash/fp';
import type Koa from 'koa';
import { contentTypes as contentTypeUtils } from '@strapi/utils';
import type { Core, Struct } from '@strapi/types';

import { transformResponse } from './transform';
import { createSingleTypeController } from './single-type';
import { createCollectionTypeController } from './collection-type';
import requestCtx from '../../services/request-context';

const isSingleType = (
  contentType: Struct.ContentTypeSchema
): contentType is Struct.SingleTypeSchema => contentTypeUtils.isSingleType(contentType);

const getAuthFromKoaContext = (ctx: Koa.Context) => prop('state.auth', ctx) ?? {};

function createController<T extends Struct.SingleTypeSchema | Struct.CollectionTypeSchema>(opts: {
  contentType: T;
}): T extends Struct.SingleTypeSchema
  ? Core.CoreAPI.Controller.SingleType
  : Core.CoreAPI.Controller.CollectionType;
function createController({
  contentType,
}: {
  contentType: Struct.SingleTypeSchema | Struct.CollectionTypeSchema;
}) {
  // TODO: replace with Base class + SingleType and CollectionType classes

  const proto: Core.CoreAPI.Controller.Base = {
    transformResponse(data, meta) {
      const ctx = requestCtx.get();
      return transformResponse(data, meta, {
        contentType,
        useJsonAPIFormat: ctx?.headers?.['strapi-response-format'] === 'v4',
      });
    },

    async sanitizeOutput(data, ctx) {
      const auth = getAuthFromKoaContext(ctx);

      return strapi.contentAPI.sanitize.output(data, contentType, { auth });
    },

    async sanitizeInput(data, ctx) {
      const auth = getAuthFromKoaContext(ctx);

      return strapi.contentAPI.sanitize.input(data, contentType, { auth });
    },

    async sanitizeQuery(ctx) {
      const auth = getAuthFromKoaContext(ctx);

      return strapi.contentAPI.sanitize.query(ctx.query, contentType, { auth });
    },

    async validateQuery(ctx) {
      const auth = getAuthFromKoaContext(ctx);

      return strapi.contentAPI.validate.query(ctx.query, contentType, { auth });
    },

    async validateInput(data, ctx) {
      const auth = getAuthFromKoaContext(ctx);

      return strapi.contentAPI.validate.input(data, contentType, { auth });
    },
  };

  let ctrl;

  if (isSingleType(contentType)) {
    ctrl = createSingleTypeController({ contentType });
  } else {
    ctrl = createCollectionTypeController({ contentType });
  }

  return Object.assign(Object.create(proto), ctrl);
}

export { createController };
</file>

<file path="src/core-api/controller/single-type.ts">
import { isObject } from 'lodash/fp';
import { errors } from '@strapi/utils';
import type { Struct, Core, Utils, UID } from '@strapi/types';

interface Options {
  contentType: Struct.SingleTypeSchema;
}

/**
 * Returns a single type controller to handle default core-api actions
 */
const createSingleTypeController = ({
  contentType,
}: Options): Utils.PartialWithThis<Core.CoreAPI.Controller.SingleType> => {
  const uid = contentType.uid as UID.Service;

  // TODO: transform into a class
  return {
    /**
     * Retrieve single type content
     *
     */
    async find(ctx) {
      await this.validateQuery(ctx);
      const sanitizedQuery = await this.sanitizeQuery(ctx);

      const entity = await strapi.service(uid).find(sanitizedQuery);

      const sanitizedEntity = await this.sanitizeOutput(entity, ctx);

      return this.transformResponse(sanitizedEntity);
    },

    /**
     * create or update single type content.
     */
    async update(ctx) {
      const { query, body = {} as any } = ctx.request;

      if (!isObject(body.data)) {
        throw new errors.ValidationError('Missing "data" payload in the request body');
      }

      await this.validateInput(body.data, ctx);

      const sanitizedInputData = await this.sanitizeInput(body.data, ctx);

      const entity = await strapi.service(uid).createOrUpdate({
        ...query,
        data: sanitizedInputData,
      });

      const sanitizedEntity = await this.sanitizeOutput(entity, ctx);

      return this.transformResponse(sanitizedEntity);
    },

    async delete(ctx) {
      const { query } = ctx;

      await strapi.service(uid).delete(query);

      ctx.status = 204;
    },
  };
};

export { createSingleTypeController };
</file>

<file path="src/core-api/controller/transform.ts">
import { isNil, isPlainObject } from 'lodash/fp';
import type { UID, Struct, Data } from '@strapi/types';

type TransformedEntry = {
  id: string;
  documentId?: Data.DocumentID | null;
  attributes: Record<string, unknown>;
};

type TransformedComponent = {
  id: string;
  [key: string]: unknown;
};

type Entry = {
  id: string;
  documentId: Data.DocumentID | null;
  [key: string]: Entry | Entry[] | string | number | null | boolean | Date;
};

function isEntry(property: unknown): property is Entry | Entry[] {
  return property === null || isPlainObject(property) || Array.isArray(property);
}

function isDZEntries(property: unknown): property is (Entry & { __component: UID.Component })[] {
  return Array.isArray(property);
}

interface TransformOptions {
  contentType?: Struct.ContentTypeSchema | Struct.ComponentSchema;
  /**
   * @deprecated this option is deprecated and will be removed in the next major version
   */
  useJsonAPIFormat?: boolean;
}

const transformResponse = (
  resource: any,
  meta: unknown = {},
  opts: TransformOptions = {
    useJsonAPIFormat: false,
  }
) => {
  if (isNil(resource)) {
    return resource;
  }

  if (!isPlainObject(resource) && !Array.isArray(resource)) {
    throw new Error('Entry must be an object or an array of objects');
  }

  return {
    data: opts.useJsonAPIFormat ? transformEntry(resource, opts?.contentType) : resource,
    meta,
  };
};

function transformComponent<T extends Entry | Entry[] | null>(
  data: T,
  component: Struct.ComponentSchema
): T extends Entry[] ? TransformedComponent[] : T extends Entry ? TransformedComponent : null;
function transformComponent(
  data: Entry | Entry[] | null,
  component: Struct.ComponentSchema
): TransformedComponent | TransformedComponent[] | null {
  if (Array.isArray(data)) {
    return data.map((datum) => transformComponent(datum, component));
  }

  const res = transformEntry(data, component);

  if (isNil(res)) {
    return res;
  }

  const { id, attributes } = res;
  return { id, ...attributes };
}

function transformEntry<T extends Entry | Entry[] | null>(
  entry: T,
  type?: Struct.Schema
): T extends Entry[] ? TransformedEntry[] : T extends Entry ? TransformedEntry : null;
function transformEntry(
  entry: Entry | Entry[] | null,
  type?: Struct.Schema
): TransformedEntry | TransformedEntry[] | null {
  if (isNil(entry)) {
    return entry;
  }

  if (Array.isArray(entry)) {
    return entry.map((singleEntry) => transformEntry(singleEntry, type));
  }

  if (!isPlainObject(entry)) {
    throw new Error('Entry must be an object');
  }

  const { id, documentId, ...properties } = entry;

  const attributeValues: Record<string, unknown> = {};

  for (const key of Object.keys(properties)) {
    const property = properties[key];
    const attribute = type && type.attributes[key];

    if (attribute && attribute.type === 'relation' && isEntry(property) && 'target' in attribute) {
      const data = transformEntry(property, strapi.contentType(attribute.target));

      attributeValues[key] = { data };
    } else if (attribute && attribute.type === 'component' && isEntry(property)) {
      attributeValues[key] = transformComponent(property, strapi.components[attribute.component]);
    } else if (attribute && attribute.type === 'dynamiczone' && isDZEntries(property)) {
      if (isNil(property)) {
        attributeValues[key] = property;
      }

      attributeValues[key] = property.map((subProperty) => {
        return transformComponent(subProperty, strapi.components[subProperty.__component]);
      });
    } else if (attribute && attribute.type === 'media' && isEntry(property)) {
      const data = transformEntry(property, strapi.contentType('plugin::upload.file'));

      attributeValues[key] = { data };
    } else {
      attributeValues[key] = property;
    }
  }

  return {
    id,
    documentId,
    attributes: attributeValues,
  };
}

export { transformResponse };
</file>

<file path="src/core-api/routes/index.ts">
import { contentTypes as contentTypeUtils } from '@strapi/utils';
import type { Schema } from '@strapi/types';

export const createRoutes = ({ contentType }: { contentType: Schema.ContentType }) => {
  if (contentTypeUtils.isSingleType(contentType)) {
    return getSingleTypeRoutes(contentType);
  }

  return getCollectionTypeRoutes(contentType);
};

const getSingleTypeRoutes = ({ uid, info }: Schema.ContentType) => {
  return {
    find: {
      method: 'GET',
      path: `/${info.singularName}`,
      handler: `${uid}.find`,
      config: {},
    },
    update: {
      method: 'PUT',
      path: `/${info.singularName}`,
      handler: `${uid}.update`,
      config: {},
    },
    delete: {
      method: 'DELETE',
      path: `/${info.singularName}`,
      handler: `${uid}.delete`,
      config: {},
    },
  };
};

const getCollectionTypeRoutes = ({ uid, info }: Schema.ContentType) => {
  return {
    find: {
      method: 'GET',
      path: `/${info.pluralName}`,
      handler: `${uid}.find`,
      config: {},
    },
    findOne: {
      method: 'GET',
      path: `/${info.pluralName}/:id`,
      handler: `${uid}.findOne`,
      config: {},
    },
    create: {
      method: 'POST',
      path: `/${info.pluralName}`,
      handler: `${uid}.create`,
      config: {},
    },
    update: {
      method: 'PUT',
      path: `/${info.pluralName}/:id`,
      handler: `${uid}.update`,
      config: {},
    },
    delete: {
      method: 'DELETE',
      path: `/${info.pluralName}/:id`,
      handler: `${uid}.delete`,
      config: {},
    },
  };
};
</file>

<file path="src/core-api/service/__tests__/index.test.ts">
import type { Struct } from '@strapi/types';
import { createService } from '../index';
import { CollectionTypeService } from '../collection-type';
import { SingleTypeService } from '../single-type';

const singleType: Struct.SingleTypeSchema = {
  kind: 'singleType',
  modelType: 'contentType',
  uid: 'api::testModel.testModel',
  globalId: 'testModel',
  modelName: 'testModel',
  attributes: {},
  info: {
    singularName: 'test-model',
    displayName: 'Test Model',
    pluralName: 'test-models',
  },
};

describe('Default Service', () => {
  describe('Collection Type', () => {
    test('Creates default actions', () => {
      const contentType: Struct.ContentTypeSchema = {
        kind: 'collectionType',
        modelType: 'contentType',
        uid: 'api::testModel.testModel',
        globalId: 'testModel',
        modelName: 'testModel',
        attributes: {},
        info: {
          singularName: 'test-model',
          displayName: 'Test Model',
          pluralName: 'test-models',
        },
      };

      const service = createService({ contentType });

      expect(service).toBeInstanceOf(CollectionTypeService);
    });
  });

  describe('Single Type', () => {
    test('Creates default actions', () => {
      const service = createService({ contentType: singleType });
      expect(service).toBeInstanceOf(SingleTypeService);
    });

    describe('Passes the logic down to the documentService', () => {
      test('Creates data when no entity is found', async () => {
        const documentService = {
          create: jest.fn(() => Promise.resolve({ documentId: 1 })),
        };

        const dbInstance = {
          findOne: jest.fn(() => Promise.resolve(null)),
        };

        const strapi = {
          db: {
            query() {
              return dbInstance;
            },
          },
          documents: jest.fn(() => documentService),
          query() {
            return { count() {} };
          },
        };

        global.strapi = strapi;

        const service = createService({ contentType: singleType });

        const input = {};
        await service.createOrUpdate({ data: input });

        expect(dbInstance.findOne).toHaveBeenCalledWith();
        expect(documentService.create).toHaveBeenCalledWith({ data: input, status: 'published' });
      });

      test('Updates data when entity is found', async () => {
        const documentService = {
          update: jest.fn(() => Promise.resolve({ documentId: 1 })),
        };

        const dbInstance = {
          findOne: jest.fn(() => Promise.resolve({ documentId: 1 })),
          count() {},
        };

        const strapi = {
          db: {
            query() {
              return dbInstance;
            },
          },
          documents: jest.fn(() => documentService),
        };

        global.strapi = strapi;

        const service = createService({ contentType: singleType });

        const input = {};
        await service.createOrUpdate({ data: input });

        expect(dbInstance.findOne).toHaveBeenCalledWith();

        expect(documentService.update).toHaveBeenCalledWith({
          documentId: 1,
          data: input,
          status: 'published',
        });
      });

      test('Delete data when entity is found', async () => {
        const documentService = {
          delete: jest.fn(() => Promise.resolve({ documentId: 1, entries: [{}] })),
        };

        const dbInstance = {
          findOne: jest.fn(() => Promise.resolve({ documentId: 1 })),
        };

        const strapi = {
          db: {
            query() {
              return dbInstance;
            },
          },
          documents: jest.fn(() => documentService),
        };

        global.strapi = strapi;

        const service = createService({ contentType: singleType });

        await service.delete({});

        expect(dbInstance.findOne).toHaveBeenCalledWith();

        expect(documentService.delete).toHaveBeenCalledWith({ documentId: 1, status: 'published' });
      });
    });
  });
});
</file>

<file path="src/core-api/service/__tests__/pagination.test.ts">
import _ from 'lodash';
import { getPaginationInfo } from '../pagination';

const maxLimit = 50;
const defaultLimit = 20;

describe('Pagination service', () => {
  describe('With maxLimit set globally', () => {
    beforeAll(() => {
      global.strapi = {
        config: {
          get(path, defaultValue) {
            return _.get(this, path, defaultValue);
          },
          api: {
            rest: {
              defaultLimit,
              maxLimit,
            },
          },
        },
      };
    });

    test('Uses default limit', () => {
      const pagination = undefined;
      const paginationInfo = getPaginationInfo({ pagination });

      expect(paginationInfo).toEqual({
        start: 0,
        limit: defaultLimit,
      });
    });

    describe('Paged pagination', () => {
      test('Uses specified pageSize', () => {
        const pagination = { pageSize: 5 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: pagination.pageSize,
        });
      });

      test('Uses maxLimit as pageSize', () => {
        const pagination = { pageSize: 999 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: maxLimit,
        });
      });

      test('Uses 1 as pageSize', () => {
        const pagination = { pageSize: 0 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: 1,
        });
      });

      test('Uses 1 as pageSize', () => {
        const pagination = { pageSize: -1 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: 1,
        });
      });

      test('Uses 1 as pageSize', () => {
        const pagination = { pageSize: -2 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: 1,
        });
      });
    });

    describe('Offset pagination', () => {
      test('Uses specified limit', () => {
        const pagination = { limit: 5 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: pagination.limit,
        });
      });

      test('Uses maxLimit as limit', () => {
        const pagination = { limit: 999 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: maxLimit,
        });
      });

      test('Uses 1 as limit', () => {
        const pagination = { limit: 0 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: 1,
        });
      });

      test('Uses maxLimit as limit', () => {
        const pagination = { limit: -1 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: maxLimit,
        });
      });

      test('Uses 1 as limit', () => {
        const pagination = { limit: -2 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: 1,
        });
      });
    });
  });

  // Setting global strapi api conf

  describe('With maxLimit undefined', () => {
    beforeAll(() => {
      global.strapi = {
        config: {
          get(path, defaultValue) {
            return _.get(this, path, defaultValue);
          },
          api: {
            rest: {
              defaultLimit,
              maxLimit: undefined,
            },
          },
        },
      };
    });

    test('Uses default limit', () => {
      const pagination = {};
      const paginationInfo = getPaginationInfo({ pagination });

      expect(paginationInfo).toEqual({
        start: 0,
        limit: defaultLimit,
      });
    });

    describe('Paged pagination', () => {
      test('Uses specified pageSize', () => {
        const pagination = { pageSize: 5 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: pagination.pageSize,
        });
      });

      test('Uses specified pageSize', () => {
        const pagination = { pageSize: 999 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: pagination.pageSize,
        });
      });

      test('Uses 1 as pageSize', () => {
        const pagination = { pageSize: 0 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: 1,
        });
      });

      test('Uses 1 as pageSize', () => {
        const pagination = { pageSize: -1 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: 1,
        });
      });

      test('Uses 1 as pageSize', () => {
        const pagination = { pageSize: -2 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: 1,
        });
      });
    });

    describe('Offset pagination', () => {
      test('Uses specified limit', () => {
        const pagination = { limit: 5 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: pagination.limit,
        });
      });

      test('Uses specified limit', () => {
        const pagination = { limit: 999 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: pagination.limit,
        });
      });

      test('Uses 1 as limit', () => {
        const pagination = { limit: 0 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: 1,
        });
      });

      test('Uses -1 as limit', () => {
        const pagination = { limit: -1 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: -1,
        });
      });

      test('Uses 1 as limit', () => {
        const pagination = { limit: -2 };
        const paginationInfo = getPaginationInfo({ pagination });

        expect(paginationInfo).toEqual({
          start: 0,
          limit: 1,
        });
      });
    });
  });
});
</file>

<file path="src/core-api/service/collection-type.ts">
import type { Core, Struct, Modules } from '@strapi/types';

import {
  getPaginationInfo,
  shouldCount,
  isPagedPagination,
  transformPaginationResponse,
} from './pagination';

import { CoreService } from './core-service';

export class CollectionTypeService
  extends CoreService
  implements Core.CoreAPI.Service.CollectionType
{
  private contentType: Struct.CollectionTypeSchema;

  constructor(contentType: Struct.CollectionTypeSchema) {
    super();

    this.contentType = contentType;
  }

  async find(params = {}) {
    const { uid } = this.contentType;

    const fetchParams = this.getFetchParams(params);

    const paginationInfo = getPaginationInfo(fetchParams);
    const isPaged = isPagedPagination(fetchParams.pagination);

    const results = await strapi.documents(uid).findMany({
      ...fetchParams,
      ...paginationInfo,
    });

    if (shouldCount(fetchParams)) {
      const count = await strapi.documents(uid).count({ ...fetchParams, ...paginationInfo });

      if (typeof count !== 'number') {
        throw new Error('Count should be a number');
      }

      return {
        results,
        pagination: transformPaginationResponse(paginationInfo, count, isPaged),
      };
    }

    return {
      results,
      pagination: transformPaginationResponse(paginationInfo, undefined, isPaged),
    };
  }

  findOne(documentId: Modules.Documents.ID, params = {}) {
    const { uid } = this.contentType;

    return strapi.documents(uid).findOne({
      ...this.getFetchParams(params),
      documentId,
    });
  }

  async create(params = { data: {} }) {
    const { uid } = this.contentType;

    return strapi.documents(uid).create(this.getFetchParams(params));
  }

  update(documentId: Modules.Documents.ID, params = { data: {} }) {
    const { uid } = this.contentType;

    return strapi.documents(uid).update({
      ...this.getFetchParams(params),
      documentId,
    });
  }

  async delete(documentId: Modules.Documents.ID, params = {}) {
    const { uid } = this.contentType;

    const { entries } = await strapi.documents(uid).delete({
      ...this.getFetchParams(params),
      documentId,
    });

    return { deletedEntries: entries.length };
  }
}

/**
 *
 * Returns a collection type service to handle default core-api actions
 */

const createCollectionTypeService = (
  contentType: Struct.CollectionTypeSchema
): Core.CoreAPI.Service.CollectionType => {
  return new CollectionTypeService(contentType);
};

export { createCollectionTypeService };
</file>

<file path="src/core-api/service/core-service.ts">
export abstract class CoreService {
  getFetchParams(params = {}): any {
    return {
      status: 'published',
      ...params,
    };
  }
}
</file>

<file path="src/core-api/service/index.ts">
import { contentTypes as contentTypeUtils } from '@strapi/utils';
import type { Core, Struct } from '@strapi/types';

import { createSingleTypeService } from './single-type';
import { createCollectionTypeService } from './collection-type';

const isSingleType = (
  contentType: Struct.ContentTypeSchema
): contentType is Struct.SingleTypeSchema => contentTypeUtils.isSingleType(contentType);

/**
 * Returns a core api for the provided model
 */
function createService<T extends Struct.SingleTypeSchema | Struct.CollectionTypeSchema>(opts: {
  contentType: T;
}): T extends Struct.SingleTypeSchema
  ? Core.CoreAPI.Service.SingleType
  : Core.CoreAPI.Service.CollectionType;
function createService({
  contentType,
}: {
  contentType: Struct.CollectionTypeSchema | Struct.SingleTypeSchema;
}): Core.CoreAPI.Service.SingleType | Core.CoreAPI.Service.CollectionType {
  if (isSingleType(contentType)) {
    return createSingleTypeService(contentType);
  }

  return createCollectionTypeService(contentType);
}

export { createService };
</file>

<file path="src/core-api/service/pagination.ts">
import { omit, has, toNumber, isNil } from 'lodash/fp';

import { errors, pagination } from '@strapi/utils';

interface BasePaginationParams {
  withCount?: boolean | 't' | '1' | 'true' | 'f' | '0' | 'false' | 0 | 1;
}

type PagedPagination = BasePaginationParams & {
  page?: number;
  pageSize?: number;
};

type OffsetPagination = BasePaginationParams & {
  start?: number;
  limit?: number;
};

export type PaginationParams = PagedPagination | OffsetPagination;

type PaginationInfo =
  | {
      page: number;
      pageSize: number;
    }
  | {
      start: number;
      limit: number;
    };

/**
 * Default limit values from config
 */
const getLimitConfigDefaults = () => ({
  defaultLimit: toNumber(strapi.config.get('api.rest.defaultLimit', 25)),
  maxLimit: toNumber(strapi.config.get('api.rest.maxLimit')) || null,
});

const isOffsetPagination = (pagination?: PaginationParams): pagination is OffsetPagination =>
  has('start', pagination) || has('limit', pagination);

const isPagedPagination = (pagination?: PaginationParams): pagination is PagedPagination =>
  has('page', pagination) || has('pageSize', pagination) || !isOffsetPagination(pagination);

const shouldCount = (params: { pagination?: PaginationParams }) => {
  if (has('pagination.withCount', params)) {
    const withCount = params.pagination?.withCount;

    if (typeof withCount === 'boolean') {
      return withCount;
    }

    if (typeof withCount === 'undefined') {
      return false;
    }

    if (['true', 't', '1', 1].includes(withCount)) {
      return true;
    }

    if (['false', 'f', '0', 0].includes(withCount)) {
      return false;
    }

    throw new errors.ValidationError(
      'Invalid withCount parameter. Expected "t","1","true","false","0","f"'
    );
  }

  return Boolean(strapi.config.get('api.rest.withCount', true));
};

const getPaginationInfo = (params: { pagination?: PaginationParams }): PaginationInfo => {
  const { defaultLimit, maxLimit } = getLimitConfigDefaults();

  const { start, limit } = pagination.withDefaultPagination(params.pagination || {}, {
    defaults: { offset: { limit: defaultLimit }, page: { pageSize: defaultLimit } },
    maxLimit: maxLimit || -1,
  });

  return { start, limit };
};

const transformPaginationResponse = (
  paginationInfo: PaginationInfo,
  total: number | undefined,
  isPaged: boolean
) => {
  const transform = isPaged
    ? pagination.transformPagedPaginationInfo
    : pagination.transformOffsetPaginationInfo;

  const paginationResponse = transform(paginationInfo, total!);

  if (isNil(total)) {
    // Ignore total and pageCount if `total` value is not available.
    return omit(['total', 'pageCount'], paginationResponse) as ReturnType<typeof transform>;
  }

  return paginationResponse;
};

export { isPagedPagination, shouldCount, getPaginationInfo, transformPaginationResponse };
</file>

<file path="src/core-api/service/single-type.ts">
import type { Struct, Core } from '@strapi/types';
import { CoreService } from './core-service';

export class SingleTypeService extends CoreService implements Core.CoreAPI.Service.SingleType {
  private contentType: Struct.SingleTypeSchema;

  constructor(contentType: Struct.SingleTypeSchema) {
    super();

    this.contentType = contentType;
  }

  async getDocumentId() {
    const { uid } = this.contentType;

    return strapi.db
      .query(uid)
      .findOne()
      .then((document) => document?.documentId as string);
  }

  async find(params = {}) {
    const { uid } = this.contentType;

    return strapi.documents(uid).findFirst(this.getFetchParams(params));
  }

  async createOrUpdate(params = {}) {
    const { uid } = this.contentType;

    const documentId = await this.getDocumentId();

    if (documentId) {
      return strapi.documents(uid).update({
        ...this.getFetchParams(params),
        documentId,
      });
    }

    return strapi.documents(uid).create(this.getFetchParams(params));
  }

  async delete(params = {}) {
    const { uid } = this.contentType;

    const documentId = await this.getDocumentId();
    if (!documentId) return { deletedEntries: 0 };

    const { entries } = await strapi.documents(uid).delete({
      ...this.getFetchParams(params),
      documentId,
    });

    return { deletedEntries: entries.length };
  }
}

const createSingleTypeService = (
  contentType: Struct.SingleTypeSchema
): Core.CoreAPI.Service.SingleType => {
  return new SingleTypeService(contentType);
};

export { createSingleTypeService };
</file>

<file path="src/domain/content-type/index.ts">
import { cloneDeep } from 'lodash/fp';
import _ from 'lodash';
import { yup, contentTypes as contentTypesUtils } from '@strapi/utils';
import type { Schema } from '@strapi/types';
import { validateContentTypeDefinition } from './validator';

export type ContentTypeDefinition = {
  schema: Schema.ContentType;
  actions: Record<string, unknown>;
  lifecycles: Record<string, unknown>;
};

const {
  CREATED_AT_ATTRIBUTE,
  UPDATED_AT_ATTRIBUTE,
  PUBLISHED_AT_ATTRIBUTE,
  CREATED_BY_ATTRIBUTE,
  UPDATED_BY_ATTRIBUTE,
} = contentTypesUtils.constants;

const createContentType = (uid: string, definition: ContentTypeDefinition) => {
  try {
    validateContentTypeDefinition(definition);
  } catch (e) {
    if (e instanceof yup.ValidationError) {
      throw new Error(`Content Type Definition is invalid for ${uid}'.\n${e.errors}`);
    }

    throw e;
  }

  const { schema, actions, lifecycles } = cloneDeep(definition);

  // general info
  Object.assign(schema, {
    uid,
    modelType: 'contentType',
    kind: schema.kind || 'collectionType',
    __schema__: pickSchema(definition.schema),
    modelName: definition.schema.info.singularName,
    actions,
    lifecycles,
  });

  addTimestamps(schema);

  // Published at is added regardless of draft and publish being enabled
  // In case it is not enabled, value will be always published, and it will not contain a draft
  addDraftAndPublish(schema);

  addCreatorFields(schema);

  return schema;
};

const addTimestamps = (schema: Schema.ContentType) => {
  // attributes
  Object.assign(schema.attributes, {
    [CREATED_AT_ATTRIBUTE]: {
      type: 'datetime',
    },
    // TODO: handle on edit set to new date
    [UPDATED_AT_ATTRIBUTE]: {
      type: 'datetime',
    },
  });
};

const addDraftAndPublish = (schema: Schema.ContentType) => {
  if (!_.has(schema, 'options.draftAndPublish')) {
    _.set(schema, 'options.draftAndPublish', false); // Disabled by default
  }

  schema.attributes[PUBLISHED_AT_ATTRIBUTE] = {
    type: 'datetime',
    configurable: false,
    writable: true,
    visible: false,
    default() {
      return new Date();
    },
  };
};

const addCreatorFields = (schema: Schema.ContentType) => {
  const isPrivate = !_.get(schema, 'options.populateCreatorFields', false);

  schema.attributes[CREATED_BY_ATTRIBUTE] = {
    type: 'relation',
    relation: 'oneToOne',
    target: 'admin::user',
    configurable: false,
    writable: false,
    visible: false,
    useJoinTable: false,
    private: isPrivate,
  };

  schema.attributes[UPDATED_BY_ATTRIBUTE] = {
    type: 'relation',
    relation: 'oneToOne',
    target: 'admin::user',
    configurable: false,
    writable: false,
    visible: false,
    useJoinTable: false,
    private: isPrivate,
  };
};

const getGlobalId = (schema: Schema.ContentType, prefix?: string) => {
  const modelName = schema.info.singularName;
  const globalId = prefix ? `${prefix}-${modelName}` : modelName;

  return schema.globalId || _.upperFirst(_.camelCase(globalId));
};

const pickSchema = (model: Schema.ContentType) => {
  const schema = _.cloneDeep(
    _.pick(model, [
      'connection',
      'collectionName',
      'info',
      'options',
      'pluginOptions',
      'attributes',
      'kind',
    ])
  );

  schema.kind = model.kind || 'collectionType';
  return schema;
};

export { createContentType, getGlobalId };
</file>

<file path="src/domain/content-type/validator.ts">
import _ from 'lodash';
import { yup, strings } from '@strapi/utils';
import type { Schema } from '@strapi/types';

const LIFECYCLES = [
  'beforeCreate',
  'afterCreate',
  'beforeFindOne',
  'afterFindOne',
  'beforeFindMany',
  'afterFindMany',
  'beforeCount',
  'afterCount',
  'beforeCreateMany',
  'afterCreateMany',
  'beforeUpdate',
  'afterUpdate',
  'beforeUpdateMany',
  'afterUpdateMany',
  'beforeDelete',
  'afterDelete',
  'beforeDeleteMany',
  'afterDeleteMany',
] as const;

/**
 * For enumerations the least common denomiator is GraphQL, where
 * values needs to match the secure name regex:
 * GraphQL Spec https://spec.graphql.org/June2018/#sec-Names
 *
 * Therefore we need to make sure our users only use values, which
 * can be returned by GraphQL, by checking the regressed values
 * agains the GraphQL regex.
 *
 * TODO V5: check if we can avoid this coupling by moving this logic
 * into the GraphQL plugin.
 */
const GRAPHQL_ENUM_REGEX = /^[_A-Za-z][_0-9A-Za-z]*$/;

const lifecyclesShape = _.mapValues(_.keyBy(LIFECYCLES), () => yup.mixed().nullable().isFunction());

const contentTypeSchemaValidator = yup.object().shape({
  schema: yup.object().shape({
    info: yup
      .object()
      .shape({
        displayName: yup.string().required(),
        singularName: yup.string().isKebabCase().required(),
        pluralName: yup.string().isKebabCase().required(),
      })
      .required(),
    attributes: yup.object().test({
      name: 'valuesCollide',
      message: 'Some values collide when normalized',
      test(attributes: Schema.ContentType['attributes']) {
        for (const attrName of Object.keys(attributes)) {
          const attr = attributes[attrName];
          if (attr.type === 'enumeration') {
            const regressedValues = attr.enum.map(strings.toRegressedEnumValue);

            // should match the GraphQL regex
            if (!regressedValues.every((value: string) => GRAPHQL_ENUM_REGEX.test(value))) {
              const message = `Invalid enumeration value. Values should have at least one alphabetical character preceding the first occurence of a number. Update your enumeration '${attrName}'.`;

              return this.createError({ message });
            }

            // should not contain empty values
            if (regressedValues.some((value: string) => value === '')) {
              return this.createError({
                message: `At least one value of the enumeration '${attrName}' appears to be empty. Only alphanumerical characters are taken into account.`,
              });
            }

            // should not collide
            const duplicates = _.uniq(
              regressedValues.filter(
                (value: string, index: number, values: string[]) => values.indexOf(value) !== index
              )
            );

            if (duplicates.length) {
              const message = `Some enumeration values of the field '${attrName}' collide when normalized: ${duplicates.join(
                ', '
              )}. Please modify your enumeration.`;

              return this.createError({ message });
            }
          }
        }

        return true;
      },
    }),
  }),
  actions: yup.object().onlyContainsFunctions(),
  lifecycles: yup.object().shape(lifecyclesShape).noUnknown(),
});

const validateContentTypeDefinition = (data: unknown) => {
  return contentTypeSchemaValidator.validateSync(data, { strict: true, abortEarly: false });
};

export { validateContentTypeDefinition };
</file>

<file path="src/domain/module/index.ts">
import _, { type PropertyPath, flatten } from 'lodash';
import { yup } from '@strapi/utils';
import type { Core, UID, Struct } from '@strapi/types';

import { removeNamespace } from '../../registries/namespace';
import { validateModule } from './validation';

interface LifecyclesState {
  bootstrap?: boolean;
  register?: boolean;
  destroy?: boolean;
}

export interface RawModule {
  config?: Record<string, unknown>;
  routes?: Core.Module['routes'];
  controllers?: Core.Module['controllers'];
  services?: Core.Module['services'];
  contentTypes?: Core.Module['contentTypes'];
  policies?: Core.Module['policies'];
  middlewares?: Core.Module['middlewares'];
  bootstrap?: (params: { strapi: Core.Strapi }) => Promise<void>;
  register?: (params: { strapi: Core.Strapi }) => Promise<void>;
  destroy?: (params: { strapi: Core.Strapi }) => Promise<void>;
}

export interface Module {
  bootstrap: () => Promise<void>;
  register: () => Promise<void>;
  destroy: () => Promise<void>;
  load: () => void;
  routes: Core.Module['routes'];
  config<T = unknown>(key: PropertyPath, defaultVal?: T): T; // TODO: this mirrors ConfigProvider.get, we should use it directly
  contentType: (ctName: UID.ContentType) => Struct.ContentTypeSchema;
  contentTypes: Record<string, Struct.ContentTypeSchema>;
  service: (serviceName: UID.Service) => Core.Service;
  services: Record<string, Core.Service>;
  policy: (policyName: UID.Policy) => Core.Policy;
  policies: Record<string, Core.Policy>;
  middleware: (middlewareName: UID.Middleware) => Core.Middleware;
  middlewares: Record<string, Core.Middleware>;
  controller: (controllerName: UID.Controller) => Core.Controller;
  controllers: Record<string, Core.Controller>;
}

// Removes the namespace from a map with keys prefixed with a namespace
const removeNamespacedKeys = <T extends Record<string, unknown>>(map: T, namespace: string) => {
  return _.mapKeys(map, (value, key) => removeNamespace(key, namespace));
};

const defaultModule = {
  config: {},
  routes: [],
  controllers: {},
  services: {},
  contentTypes: {},
  policies: {},
  middlewares: {},
};

export const createModule = (
  namespace: string,
  rawModule: RawModule,
  strapi: Core.Strapi
): Module => {
  _.defaults(rawModule, defaultModule);

  try {
    validateModule(rawModule);
  } catch (e) {
    if (e instanceof yup.ValidationError) {
      throw new Error(`strapi-server.js is invalid for '${namespace}'.\n${e.errors.join('\n')}`);
    }
  }

  const called: LifecyclesState = {};
  return {
    async bootstrap() {
      if (called.bootstrap) {
        throw new Error(`Bootstrap for ${namespace} has already been called`);
      }
      called.bootstrap = true;
      await (rawModule.bootstrap && rawModule.bootstrap({ strapi }));
    },
    async register() {
      if (called.register) {
        throw new Error(`Register for ${namespace} has already been called`);
      }
      called.register = true;
      await (rawModule.register && rawModule.register({ strapi }));
    },
    async destroy() {
      if (called.destroy) {
        throw new Error(`Destroy for ${namespace} has already been called`);
      }
      called.destroy = true;
      await (rawModule.destroy && rawModule.destroy({ strapi }));
    },
    load() {
      strapi.get('content-types').add(namespace, rawModule.contentTypes);
      strapi.get('services').add(namespace, rawModule.services);
      strapi.get('policies').add(namespace, rawModule.policies);
      strapi.get('middlewares').add(namespace, rawModule.middlewares);
      strapi.get('controllers').add(namespace, rawModule.controllers);
      strapi.get('config').set(namespace, rawModule.config);
    },
    get routes() {
      return rawModule.routes ?? {};
    },
    config(path: PropertyPath, defaultValue: unknown) {
      const pathArray = flatten([namespace, path]);
      return strapi.get('config').get(pathArray, defaultValue);
    },
    contentType(ctName: UID.ContentType) {
      return strapi.get('content-types').get(`${namespace}.${ctName}`);
    },
    get contentTypes() {
      const contentTypes = strapi.get('content-types').getAll(namespace);
      return removeNamespacedKeys(contentTypes, namespace);
    },
    service(serviceName: UID.Service) {
      return strapi.get('services').get(`${namespace}.${serviceName}`);
    },
    get services() {
      const services = strapi.get('services').getAll(namespace);
      return removeNamespacedKeys(services, namespace);
    },
    policy(policyName: UID.Policy) {
      return strapi.get('policies').get(`${namespace}.${policyName}`);
    },
    get policies() {
      const policies = strapi.get('policies').getAll(namespace);
      return removeNamespacedKeys(policies, namespace);
    },
    middleware(middlewareName: UID.Middleware) {
      return strapi.get('middlewares').get(`${namespace}.${middlewareName}`);
    },
    get middlewares() {
      const middlewares = strapi.get('middlewares').getAll(namespace);
      return removeNamespacedKeys(middlewares, namespace);
    },
    controller(controllerName: UID.Controller) {
      return strapi.get('controllers').get(`${namespace}.${controllerName}`);
    },
    get controllers() {
      const controllers = strapi.get('controllers').getAll(namespace);
      return removeNamespacedKeys(controllers, namespace);
    },
  };
};
</file>

<file path="src/domain/module/validation.ts">
import { yup } from '@strapi/utils';

const strapiServerSchema = yup
  .object()
  .shape({
    bootstrap: yup.mixed().isFunction(),
    destroy: yup.mixed().isFunction(),
    register: yup.mixed().isFunction(),
    config: yup.object(),
    routes: yup.lazy((value) => {
      if (Array.isArray(value)) {
        return yup.array();
      }
      return yup.object();
    }),
    controllers: yup.object(),
    services: yup.object(),
    policies: yup.object(),
    middlewares: yup.object(),
    contentTypes: yup.object(),
  })
  .noUnknown();

const validateModule = (data: unknown) => {
  return strapiServerSchema.validateSync(data, { strict: true, abortEarly: false });
};

export { validateModule };
</file>

<file path="src/ee/index.ts">
import { pick, isEqual } from 'lodash/fp';
import type { Logger } from '@strapi/logger';
import type { Core } from '@strapi/types';

import { readLicense, verifyLicense, fetchLicense, LicenseCheckError } from './license';
import { shiftCronExpression } from '../utils/cron';

const ONE_MINUTE = 1000 * 60;

interface EE {
  enabled: boolean;
  licenseInfo: {
    licenseKey?: string;
    features?: Array<{ name: string; [key: string]: any } | string>;
    expireAt?: string;
    seats?: number;
    type?: string;
  };
  logger?: Logger;
}

const ee: EE = {
  enabled: false,
  licenseInfo: {},
};

const disable = (message: string) => {
  // Prevent emitting ee.disable if it was already disabled
  const shouldEmitEvent = ee.enabled !== false;

  ee.logger?.warn(`${message} Switching to CE.`);
  // Only keep the license key for potential re-enabling during a later check
  ee.licenseInfo = pick('licenseKey', ee.licenseInfo);

  ee.enabled = false;

  if (shouldEmitEvent) {
    // Notify EE features that they should be disabled
    strapi.eventHub.emit('ee.disable');
  }
};

const enable = () => {
  // Prevent emitting ee.enable if it was already enabled
  const shouldEmitEvent = ee.enabled !== true;

  ee.enabled = true;

  if (shouldEmitEvent) {
    // Notify EE features that they should be disabled
    strapi.eventHub.emit('ee.enable');
  }
};

let initialized = false;

/**
 * Optimistically enable EE if the format of the license is valid, only run once.
 */
const init = (licenseDir: string, logger?: Logger) => {
  if (initialized) {
    return;
  }

  initialized = true;
  ee.logger = logger;

  if (process.env.STRAPI_DISABLE_EE?.toLowerCase() === 'true') {
    return;
  }

  try {
    const license = process.env.STRAPI_LICENSE || readLicense(licenseDir);

    if (license) {
      ee.licenseInfo = verifyLicense(license);
      enable();
    }
  } catch (error) {
    if (error instanceof Error) {
      disable(error.message);
    } else {
      disable('Invalid license.');
    }
  }
};

/**
 * Contact the license registry to update the license to its latest state.
 *
 * Store the result in database to avoid unecessary requests, and will fallback to that in case of a network failure.
 */
const onlineUpdate = async ({ strapi }: { strapi: Core.Strapi }) => {
  const { get, commit, rollback } = (await strapi.db?.transaction()) as any;
  const transaction = get();

  try {
    const storedInfo = await strapi.db
      ?.queryBuilder('strapi::core-store')
      .where({ key: 'ee_information' })
      .select('value')
      .first()
      .transacting(transaction)
      .forUpdate()
      .execute()
      .then((result: any) => (result ? JSON.parse(result.value) : result));

    const shouldContactRegistry = (storedInfo?.lastCheckAt ?? 0) < Date.now() - ONE_MINUTE;
    const result: {
      license?: string | null;
      error?: string;
      lastCheckAt?: number;
    } = { lastCheckAt: Date.now() };

    const fallback = (error: Error) => {
      if (error instanceof LicenseCheckError && error.shouldFallback && storedInfo?.license) {
        ee.logger?.warn(
          `${error.message} The last stored one will be used as a potential fallback.`
        );
        return storedInfo.license;
      }

      result.error = error.message;
      disable(error.message);
    };

    if (!ee?.licenseInfo?.licenseKey) {
      throw new Error('Missing license key.');
    }

    const license = shouldContactRegistry
      ? await fetchLicense({ strapi }, ee.licenseInfo.licenseKey, strapi.config.get('uuid')).catch(
          fallback
        )
      : storedInfo.license;

    if (license) {
      try {
        // Verify license and check if its info changed
        const newLicenseInfo = verifyLicense(license);
        const licenseInfoChanged =
          !isEqual(newLicenseInfo.features, ee.licenseInfo.features) ||
          newLicenseInfo.seats !== ee.licenseInfo.seats ||
          newLicenseInfo.type !== ee.licenseInfo.type;

        // Store the new license info
        ee.licenseInfo = newLicenseInfo;
        const wasEnabled = ee.enabled;
        validateInfo();

        // Notify EE features
        if (licenseInfoChanged && wasEnabled) {
          strapi.eventHub.emit('ee.update');
        }
      } catch (error) {
        if (error instanceof Error) {
          disable(error.message);
        } else {
          disable('Invalid license.');
        }
      }
    } else if (!shouldContactRegistry) {
      disable(storedInfo.error);
    }

    if (shouldContactRegistry) {
      result.license = license ?? null;
      const query = strapi.db.queryBuilder('strapi::core-store').transacting(transaction);

      if (!storedInfo) {
        query.insert({ key: 'ee_information', value: JSON.stringify(result) });
      } else {
        query.update({ value: JSON.stringify(result) }).where({ key: 'ee_information' });
      }

      await query.execute();
    }

    await commit();
  } catch (error) {
    // Example of errors: SQLite does not support FOR UPDATE
    await rollback();
  }
};

const validateInfo = () => {
  if (typeof ee.licenseInfo.expireAt === 'undefined') {
    throw new Error('Missing license key.');
  }

  const expirationTime = new Date(ee.licenseInfo.expireAt).getTime();

  if (expirationTime < new Date().getTime()) {
    return disable('License expired.');
  }

  enable();
};

const checkLicense = async ({ strapi }: { strapi: Core.Strapi }) => {
  const shouldStayOffline =
    ee.licenseInfo.type === 'gold' &&
    // This env variable support is temporarily used to ease the migration between online vs offline
    process.env.STRAPI_DISABLE_LICENSE_PING?.toLowerCase() === 'true';

  if (!shouldStayOffline) {
    await onlineUpdate({ strapi });

    strapi.cron.add({
      onlineUpdate: {
        task: () => onlineUpdate({ strapi }),
        options: shiftCronExpression('0 0 */12 * * *'),
      },
    });
  } else {
    if (!ee.licenseInfo.expireAt) {
      return disable('Your license does not have offline support.');
    }

    validateInfo();
  }
};

const list = () => {
  return (
    ee.licenseInfo.features?.map((feature) =>
      typeof feature === 'object' ? feature : { name: feature }
    ) || []
  );
};

const get = (featureName: string) => list().find((feature) => feature.name === featureName);

export default Object.freeze({
  init,
  checkLicense,

  get isEE() {
    return ee.enabled;
  },

  get seats() {
    return ee.licenseInfo.seats;
  },

  features: Object.freeze({
    list,
    get,
    isEnabled: (featureName: string) => get(featureName) !== undefined,
  }),
});
</file>

<file path="src/ee/license.ts">
import fs from 'fs';
import { join, resolve } from 'path';
import crypto from 'crypto';
import type { Core } from '@strapi/types';

import { machineID } from '@strapi/utils';

interface LicenseInfo {
  type: 'bronze' | 'silver' | 'gold';
  expireAt?: string;
  seats?: number;
  features?: Array<{ name: string; options?: Record<string, unknown> }>;
}

const DEFAULT_FEATURES = {
  bronze: [],
  silver: [],
  gold: [
    { name: 'sso' },
    // Set a null retention duration to allow the user to override it
    // The default of 90 days is set in the audit logs service
    { name: 'audit-logs', options: { retentionDays: null } },
    { name: 'review-workflows' },
    { name: 'cms-content-releases' },
    { name: 'cms-content-history', options: { retentionDays: 99999 } },
  ],
};

const publicKey = fs.readFileSync(resolve(__dirname, '../resources/key.pub'));

class LicenseCheckError extends Error {
  shouldFallback = false;

  constructor(message: string, shouldFallback = false) {
    super(message);

    this.shouldFallback = shouldFallback;
  }
}

const readLicense = (directory: string) => {
  try {
    const path = join(directory, 'license.txt');
    return fs.readFileSync(path).toString();
  } catch (error) {
    if (typeof error === 'object' && error !== null && 'code' in error && error.code !== 'ENOENT') {
      throw Error('License file not readable, review its format and access rules.');
    }
  }
};

const verifyLicense = (license: string) => {
  const [signature, base64Content] = Buffer.from(license, 'base64').toString().split('\n');

  if (!signature || !base64Content) {
    throw new Error('Invalid license.');
  }

  const stringifiedContent = Buffer.from(base64Content, 'base64').toString();

  const verify = crypto.createVerify('RSA-SHA256');
  verify.update(stringifiedContent);
  verify.end();

  const verified = verify.verify(publicKey, signature, 'base64');

  if (!verified) {
    throw new Error('Invalid license.');
  }

  const licenseInfo: LicenseInfo = JSON.parse(stringifiedContent);

  if (!licenseInfo.features) {
    licenseInfo.features = DEFAULT_FEATURES[licenseInfo.type];
  }

  Object.freeze(licenseInfo.features);
  return licenseInfo;
};

const throwError = () => {
  throw new LicenseCheckError('Could not proceed to the online validation of your license.', true);
};

const fetchLicense = async (
  { strapi }: { strapi: Core.Strapi },
  key: string,
  projectId: string
) => {
  const response = await strapi
    .fetch(`https://license.strapi.io/api/licenses/validate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ key, projectId, deviceId: machineID() }),
    })
    .catch(throwError);

  const contentType = response.headers.get('Content-Type');

  if (contentType?.includes('application/json')) {
    const { data, error } = await response.json();

    switch (response.status) {
      case 200:
        return data.license;
      case 400:
        throw new LicenseCheckError(error.message);
      case 404:
        throw new LicenseCheckError('The license used does not exists.');
      default:
        throwError();
    }
  } else {
    throwError();
  }
};

export { readLicense, verifyLicense, fetchLicense, LicenseCheckError };
</file>

<file path="src/loaders/plugins/get-enabled-plugins.ts">
/* eslint-disable @typescript-eslint/no-var-requires */
import { dirname, join, resolve } from 'path';
import { statSync, existsSync } from 'fs';
import _ from 'lodash';
import { get, pickBy, defaultsDeep, map, prop, pipe } from 'lodash/fp';
import { strings } from '@strapi/utils';
import type { Core } from '@strapi/types';
import { getUserPluginsConfig } from './get-user-plugins-config';

interface PluginMeta {
  enabled: boolean;
  pathToPlugin?: string;
  info: Record<string, unknown>;
  packageInfo?: Record<string, unknown>;
}

type PluginMetas = Record<string, PluginMeta>;

interface PluginInfo {
  name: string;
  kind: string;
}

interface PluginDeclaration {
  enabled: boolean;
  resolve: string;
  isModule: boolean;
}

/**
 * otherwise known as "core features"
 *
 * NOTE: These are excluded from the content manager plugin list, as they are always enabled.
 *       See admin.ts server controller on the content-manager plugin for more details.
 */
const INTERNAL_PLUGINS = [
  '@strapi/content-manager',
  '@strapi/content-type-builder',
  '@strapi/email',
  '@strapi/upload',
  '@strapi/i18n',
  '@strapi/content-releases',
  '@strapi/review-workflows',
];

const isStrapiPlugin = (info: PluginInfo) => get('strapi.kind', info) === 'plugin';

const validatePluginName = (pluginName: string) => {
  if (!strings.isKebabCase(pluginName)) {
    throw new Error(`Plugin name "${pluginName}" is not in kebab (an-example-of-kebab-case)`);
  }
};

const toDetailedDeclaration = (declaration: boolean | PluginDeclaration) => {
  if (typeof declaration === 'boolean') {
    return { enabled: declaration };
  }

  const detailedDeclaration: { enabled: boolean; pathToPlugin?: string } = {
    enabled: declaration.enabled,
  };

  if (declaration?.resolve) {
    let pathToPlugin = '';

    if (declaration.isModule) {
      /**
       * we only want the node_module here, not the package.json
       */
      pathToPlugin = join(declaration.resolve, '..');
    } else {
      try {
        pathToPlugin = dirname(require.resolve(declaration.resolve));
      } catch (e) {
        pathToPlugin = resolve(strapi.dirs.app.root, declaration.resolve);

        if (!existsSync(pathToPlugin) || !statSync(pathToPlugin).isDirectory()) {
          throw new Error(`${declaration.resolve} couldn't be resolved`);
        }
      }
    }

    detailedDeclaration.pathToPlugin = pathToPlugin;
  }

  return detailedDeclaration;
};

export const getEnabledPlugins = async (strapi: Core.Strapi, { client } = { client: false }) => {
  const internalPlugins: PluginMetas = {};

  for (const dep of INTERNAL_PLUGINS) {
    const packagePath = join(dep, 'package.json');

    // NOTE: internal plugins should be resolved from the strapi package
    const packageModulePath = require.resolve(packagePath, {
      paths: [require.resolve('@strapi/strapi/package.json'), process.cwd()],
    });

    const packageInfo = require(packageModulePath);

    validatePluginName(packageInfo.strapi.name);
    internalPlugins[packageInfo.strapi.name] = {
      ...toDetailedDeclaration({ enabled: true, resolve: packageModulePath, isModule: client }),
      info: packageInfo.strapi,
      packageInfo,
    };
  }

  const installedPlugins: PluginMetas = {};
  const dependencies = strapi.config.get('info.dependencies', {});

  for (const dep of Object.keys(dependencies)) {
    const packagePath = join(dep, 'package.json');
    let packageInfo;
    try {
      packageInfo = require(packagePath);
    } catch {
      continue;
    }

    if (isStrapiPlugin(packageInfo)) {
      validatePluginName(packageInfo.strapi.name);
      installedPlugins[packageInfo.strapi.name] = {
        ...toDetailedDeclaration({ enabled: true, resolve: packagePath, isModule: client }),
        info: {
          ...packageInfo.strapi,
          packageName: packageInfo.name,
        },
        packageInfo,
      };
    }
  }

  const declaredPlugins: PluginMetas = {};
  const userPluginsConfig = await getUserPluginsConfig();

  _.forEach(userPluginsConfig, (declaration, pluginName) => {
    validatePluginName(pluginName);

    declaredPlugins[pluginName] = {
      ...toDetailedDeclaration(declaration),
      info: {},
    };

    const { pathToPlugin } = declaredPlugins[pluginName];

    // for manually resolved plugins
    if (pathToPlugin) {
      const packagePath = join(pathToPlugin, 'package.json');
      const packageInfo = require(packagePath);

      if (isStrapiPlugin(packageInfo)) {
        declaredPlugins[pluginName].info = packageInfo.strapi || {};
        declaredPlugins[pluginName].packageInfo = packageInfo;
      }
    }
  });

  const declaredPluginsResolves = map(prop('pathToPlugin'), declaredPlugins);
  const installedPluginsNotAlreadyUsed = pickBy(
    (p) => !declaredPluginsResolves.includes(p.pathToPlugin),
    installedPlugins
  );

  const enabledPlugins = pipe(
    defaultsDeep(declaredPlugins),
    defaultsDeep(installedPluginsNotAlreadyUsed),
    pickBy((p: PluginMeta) => p.enabled)
  )(internalPlugins);

  return enabledPlugins;
};
</file>

<file path="src/loaders/plugins/get-user-plugins-config.ts">
import { join } from 'path';
import fse from 'fs-extra';
import { merge } from 'lodash/fp';
import { loadConfigFile } from '../../utils/load-config-file';

/**
 * Return user defined plugins' config
 * first load config from `config/plugins.js`
 * and then merge config from `config/env/{env}/plugins.js`
 */
export const getUserPluginsConfig = async () => {
  const globalUserConfigPath = join(strapi.dirs.dist.config, 'plugins.js');
  const currentEnvUserConfigPath = join(
    strapi.dirs.dist.config,
    'env',
    process.env.NODE_ENV as string,
    'plugins.js'
  );
  let config = {};

  // assign global user config if exists
  if (await fse.pathExists(globalUserConfigPath)) {
    config = loadConfigFile(globalUserConfigPath);
  }

  // and merge user config by environment if exists
  if (await fse.pathExists(currentEnvUserConfigPath)) {
    config = merge(config, loadConfigFile(currentEnvUserConfigPath));
  }

  return config;
};
</file>

<file path="src/loaders/plugins/index.ts">
import { join } from 'path';
import fse from 'fs-extra';
import { defaultsDeep, defaults, getOr, get } from 'lodash/fp';
import * as resolve from 'resolve.exports';

import { env } from '@strapi/utils';
import type { Core, Plugin, Struct } from '@strapi/types';
import { loadConfigFile } from '../../utils/load-config-file';
import { loadFiles } from '../../utils/load-files';
import { getEnabledPlugins } from './get-enabled-plugins';
import { getUserPluginsConfig } from './get-user-plugins-config';
import { getGlobalId } from '../../domain/content-type';

interface Plugins {
  [key: string]: Plugin.LoadedPlugin;
}

const defaultPlugin = {
  bootstrap() {},
  destroy() {},
  register() {},
  config: {
    default: {},
    validator() {},
  },
  routes: [],
  controllers: {},
  services: {},
  policies: {},
  middlewares: {},
  contentTypes: {},
};

const applyUserExtension = async (plugins: Plugins) => {
  const extensionsDir = strapi.dirs.dist.extensions;
  if (!(await fse.pathExists(extensionsDir))) {
    return;
  }

  const extendedSchemas = await loadFiles(extensionsDir, '**/content-types/**/schema.json');
  const strapiServers = await loadFiles(extensionsDir, '**/strapi-server.js');

  for (const pluginName of Object.keys(plugins)) {
    const plugin = plugins[pluginName];
    // first: load json schema
    for (const ctName of Object.keys(plugin.contentTypes)) {
      const extendedSchema = get([pluginName, 'content-types', ctName, 'schema'], extendedSchemas);
      if (extendedSchema) {
        plugin.contentTypes[ctName].schema = {
          ...plugin.contentTypes[ctName].schema,
          ...extendedSchema,
        };
      }
    }
    // second: execute strapi-server extension
    const strapiServer = get([pluginName, 'strapi-server'], strapiServers);
    if (strapiServer) {
      plugins[pluginName] = await strapiServer(plugin);
    }
  }
};

const applyUserConfig = async (plugins: Plugins) => {
  const userPluginsConfig = await getUserPluginsConfig();

  for (const pluginName of Object.keys(plugins)) {
    const plugin = plugins[pluginName];
    const userPluginConfig = getOr({}, `${pluginName}.config`, userPluginsConfig);
    const defaultConfig =
      typeof plugin.config.default === 'function'
        ? plugin.config.default({ env })
        : plugin.config.default;

    const config = defaultsDeep(defaultConfig, userPluginConfig);
    try {
      plugin.config.validator(config);
    } catch (e) {
      if (e instanceof Error) {
        throw new Error(`Error regarding ${pluginName} config: ${e.message}`);
      }

      throw e;
    }
    plugin.config = config;
  }
};

export default async function loadPlugins(strapi: Core.Strapi) {
  const plugins: Plugins = {};

  const enabledPlugins = await getEnabledPlugins(strapi);

  strapi.config.set('enabledPlugins', enabledPlugins);

  for (const pluginName of Object.keys(enabledPlugins)) {
    const enabledPlugin = enabledPlugins[pluginName];

    let serverEntrypointPath;
    let resolvedExport = './strapi-server.js';

    try {
      resolvedExport = (
        resolve.exports(enabledPlugin.packageInfo, 'strapi-server', {
          require: true,
        }) ?? './strapi-server.js'
      ).toString();
    } catch (e) {
      // no export map or missing strapi-server export => fallback to default
    }

    try {
      serverEntrypointPath = join(enabledPlugin.pathToPlugin, resolvedExport);
    } catch (e) {
      throw new Error(
        `Error loading the plugin ${pluginName} because ${pluginName} is not installed. Please either install the plugin or remove it's configuration.`
      );
    }

    // only load plugins with a server entrypoint
    if (!(await fse.pathExists(serverEntrypointPath))) {
      continue;
    }

    const pluginServer = loadConfigFile(serverEntrypointPath);
    plugins[pluginName] = {
      ...defaultPlugin,
      ...pluginServer,
      contentTypes: formatContentTypes(pluginName, pluginServer.contentTypes ?? {}),
      config: defaults(defaultPlugin.config, pluginServer.config),
      routes: pluginServer.routes ?? defaultPlugin.routes,
    };
  }

  // TODO: validate plugin format
  await applyUserConfig(plugins);
  await applyUserExtension(plugins);

  for (const pluginName of Object.keys(plugins)) {
    strapi.get('plugins').add(pluginName, plugins[pluginName]);
  }
}

const formatContentTypes = (
  pluginName: string,
  contentTypes: Record<string, { schema: Struct.ContentTypeSchema }>
) => {
  Object.values(contentTypes).forEach((definition) => {
    const { schema } = definition;

    Object.assign(schema, {
      plugin: pluginName,
      collectionName:
        schema.collectionName || `${pluginName}_${schema.info.singularName}`.toLowerCase(),
      globalId: getGlobalId(schema, pluginName),
    });
  });

  return contentTypes;
};
</file>

<file path="src/loaders/admin.ts">
import _ from 'lodash';
import type { Core, Struct } from '@strapi/types';
import { getGlobalId } from '../domain/content-type';

export default async function loadAdmin(strapi: Core.Strapi) {
  // strapi.admin = require('@strapi/admin/strapi-server');

  strapi.get('services').add(`admin::`, strapi.admin?.services);
  strapi.get('controllers').add(`admin::`, strapi.admin?.controllers);
  strapi.get('content-types').add(`admin::`, formatContentTypes(strapi.admin?.contentTypes ?? {}));
  strapi.get('policies').add(`admin::`, strapi.admin?.policies);
  strapi.get('middlewares').add(`admin::`, strapi.admin?.middlewares);

  const userAdminConfig = strapi.config.get('admin');
  strapi.get('config').set('admin', _.merge(strapi.admin?.config, userAdminConfig));
}

const formatContentTypes = (contentTypes: Record<string, { schema: Struct.ContentTypeSchema }>) => {
  Object.values(contentTypes).forEach((definition) => {
    const { schema } = definition;

    Object.assign(schema, {
      plugin: 'admin',
      globalId: getGlobalId(schema, 'admin'),
    });
  });

  return contentTypes;
};
</file>

<file path="src/loaders/apis.ts">
import { join, extname, basename } from 'path';
import fse, { existsSync } from 'fs-extra';
import _ from 'lodash';
import { strings, importDefault } from '@strapi/utils';
import { isEmpty } from 'lodash/fp';
import type { Core, Struct } from '@strapi/types';
import { getGlobalId, type ContentTypeDefinition } from '../domain/content-type';

interface API {
  bootstrap: () => void | Promise<void>;
  destroy: () => void | Promise<void>;
  register: () => void | Promise<void>;
  config: Record<string, unknown>;
  routes: Record<string, Core.Router>;
  controllers: Record<string, Core.Controller>;
  services: Record<string, Core.Service>;
  policies: Record<string, Core.Policy>;
  middlewares: Record<string, Core.Middleware>;
  contentTypes: Record<string, { schema: Struct.ContentTypeSchema }>;
}

interface APIs {
  [key: string]: API;
}

const DEFAULT_CONTENT_TYPE = {
  schema: {},
  actions: {},
  lifecycles: {},
};

// to handle names with numbers in it we first check if it is already in kebabCase
const normalizeName = (name: string) => (strings.isKebabCase(name) ? name : _.kebabCase(name));

const isDirectory = (fd: fse.Dirent) => fd.isDirectory();
const isDotFile = (fd: fse.Dirent) => fd.name.startsWith('.');

export default async function loadAPIs(strapi: Core.Strapi) {
  if (!existsSync(strapi.dirs.dist.api)) {
    return;
  }

  const apisFDs = await (await fse.readdir(strapi.dirs.dist.api, { withFileTypes: true }))
    .filter(isDirectory)
    .filter(_.negate(isDotFile));

  const apis: APIs = {};

  // only load folders
  for (const apiFD of apisFDs) {
    const apiName = normalizeName(apiFD.name);
    const api = await loadAPI(apiName, join(strapi.dirs.dist.api, apiFD.name));

    // @ts-expect-error TODO verify that it's a valid api, not missing bootstrap, register, and destroy
    apis[apiName] = api;
  }

  validateContentTypesUnicity(apis);

  for (const apiName of Object.keys(apis)) {
    strapi.get('apis').add(apiName, apis[apiName]);
  }
}

const validateContentTypesUnicity = (apis: APIs) => {
  const allApisSchemas = Object.values(apis).flatMap((api) => Object.values(api.contentTypes));

  const names: string[] = [];
  allApisSchemas.forEach(({ schema }) => {
    if (schema.info.singularName) {
      const singularName = _.kebabCase(schema.info.singularName);
      if (names.includes(singularName)) {
        throw new Error(`The singular name "${schema.info.singularName}" should be unique`);
      }
      names.push(singularName);
    }

    if (schema.info.pluralName) {
      const pluralName = _.kebabCase(schema.info.pluralName);
      if (names.includes(pluralName)) {
        throw new Error(`The plural name "${schema.info.pluralName}" should be unique`);
      }
      names.push(pluralName);
    }
  });
};

const loadAPI = async (apiName: string, dir: string) => {
  const [index, config, routes, controllers, services, policies, middlewares, contentTypes] = (
    await Promise.all([
      loadIndex(dir),
      loadDir(join(dir, 'config')),
      loadDir(join(dir, 'routes')),
      loadDir(join(dir, 'controllers')),
      loadDir(join(dir, 'services')),
      loadDir(join(dir, 'policies')),
      loadDir(join(dir, 'middlewares')),
      loadContentTypes(apiName, join(dir, 'content-types')),
    ])
  ).map((result) => result?.result);

  return {
    ...(index || {}),
    config: config || {},
    routes: routes || [],
    controllers: controllers || {},
    services: services || {},
    policies: policies || {},
    middlewares: middlewares || {},
    contentTypes: contentTypes || {},
  };
};

const loadIndex = async (dir: string) => {
  if (await fse.pathExists(join(dir, 'index.js'))) {
    return loadFile(join(dir, 'index.js'));
  }
};

// because this is async and its contents are dynamic, we must return it within an object to avoid a property called `then` being interpreted as a Promise
const loadContentTypes = async (apiName: string, dir: string) => {
  if (!(await fse.pathExists(dir))) {
    return;
  }

  const fds = await fse.readdir(dir, { withFileTypes: true });
  const contentTypes: API['contentTypes'] = {};

  // only load folders
  for (const fd of fds) {
    if (fd.isFile()) {
      continue;
    }

    const contentTypeName = normalizeName(fd.name);
    const loadedContentType = (await loadDir(join(dir, fd.name)))?.result;

    if (isEmpty(loadedContentType) || isEmpty(loadedContentType.schema)) {
      throw new Error(`Could not load content type found at ${dir}`);
    }

    const contentType = {
      ...DEFAULT_CONTENT_TYPE,
      ...loadedContentType,
    } as ContentTypeDefinition;

    Object.assign(contentType.schema, {
      apiName,
      collectionName: contentType.schema.collectionName || contentType.schema.info.singularName,
      globalId: getGlobalId(contentType.schema),
    });

    contentTypes[normalizeName(contentTypeName)] = contentType;
  }

  return { result: contentTypes };
};

// because this is async and its contents are dynamic, we must return it within an object to avoid a property called `then` being interpreted as a Promise
const loadDir = async (dir: string) => {
  if (!(await fse.pathExists(dir))) {
    return;
  }

  const fds = await fse.readdir(dir, { withFileTypes: true });

  const root: Record<string, unknown> = {};
  for (const fd of fds) {
    if (!fd.isFile() || extname(fd.name) === '.map') {
      continue;
    }

    const key = basename(fd.name, extname(fd.name));

    root[normalizeName(key)] = (await loadFile(join(dir, fd.name))).result;
  }

  return { result: root };
};

// because this is async and its contents are dynamic, we must return it as an array to avoid a property called `then` being interpreted as a Promise
const loadFile = async (file: string): Promise<{ result: unknown }> => {
  const ext = extname(file);

  switch (ext) {
    case '.js':
      return { result: importDefault(file) };
    case '.json':
      return { result: await fse.readJSON(file) };
    default:
      return { result: {} };
  }
};
</file>

<file path="src/loaders/components.ts">
import { join } from 'path';
import _ from 'lodash';
import { pathExists } from 'fs-extra';
import type { Core, Struct, UID } from '@strapi/types';
import { loadFiles } from '../utils/load-files';

type LoadedComponent = {
  collectionName: string;
  __filename__: string;
  __schema__: LoadedComponent;
  uid: string;
  category: string;
  modelName: string;
  globalId: string;
  info: any;
  attributes: any;
};

type LoadedComponents = {
  [category: string]: {
    [key: string]: LoadedComponent;
  };
};

type ComponentMap = {
  [uid in UID.Component]: Struct.ComponentSchema;
};

export default async function loadComponents(strapi: Core.Strapi) {
  if (!(await pathExists(strapi.dirs.dist.components))) {
    return {};
  }

  const map = await loadFiles<LoadedComponents>(strapi.dirs.dist.components, '*/*.*(js|json)');

  const components = Object.keys(map).reduce((acc, category) => {
    Object.keys(map[category]).forEach((key) => {
      const schema = map[category][key];

      if (!schema.collectionName) {
        // NOTE: We're using the filepath from the app directory instead of the dist for information purpose
        const filePath = join(strapi.dirs.app.components, category, schema.__filename__);

        return strapi.stopWithError(
          `Component ${key} is missing a "collectionName" property.\nVerify file ${filePath}.`
        );
      }

      const uid: UID.Component = `${category}.${key}`;

      acc[uid] = Object.assign(schema, {
        __schema__: _.cloneDeep(schema),
        uid,
        category,
        modelType: 'component' as const,
        modelName: key,
        globalId: schema.globalId || _.upperFirst(_.camelCase(`component_${uid}`)),
      });
    });

    return acc;
  }, {} as ComponentMap);

  strapi.get('components').add(components);
}
</file>

<file path="src/loaders/index.ts">
import type { Core } from '@strapi/types';

import loadSrcIndex from './src-index';
import loadAPIs from './apis';
import loadMiddlewares from './middlewares';
import loadComponents from './components';
import loadPolicies from './policies';
import loadPlugins from './plugins';
import loadSanitizers from './sanitizers';
import loadValidators from './validators';

export async function loadApplicationContext(strapi: Core.Strapi) {
  await Promise.all([
    loadSrcIndex(strapi),
    loadSanitizers(strapi),
    loadValidators(strapi),
    loadPlugins(strapi),
    loadAPIs(strapi),
    loadComponents(strapi),
    loadMiddlewares(strapi),
    loadPolicies(strapi),
  ]);
}
</file>

<file path="src/loaders/middlewares.ts">
import { join, extname, basename } from 'path';
import fse from 'fs-extra';
import { importDefault } from '@strapi/utils';
import type { Core } from '@strapi/types';
import { middlewares as internalMiddlewares } from '../middlewares';

// TODO:: allow folders with index.js inside for bigger policies
export default async function loadMiddlewares(strapi: Core.Strapi) {
  const localMiddlewares = await loadLocalMiddlewares(strapi);

  strapi.get('middlewares').add(`global::`, localMiddlewares);
  strapi.get('middlewares').add(`strapi::`, internalMiddlewares);
}

const loadLocalMiddlewares = async (strapi: Core.Strapi) => {
  const dir = strapi.dirs.dist.middlewares;

  if (!(await fse.pathExists(dir))) {
    return {};
  }

  const middlewares: Record<string, Core.MiddlewareFactory> = {};
  const paths = await fse.readdir(dir, { withFileTypes: true });

  for (const fd of paths) {
    const { name } = fd;
    const fullPath = join(dir, name);

    if (fd.isFile() && extname(name) === '.js') {
      const key = basename(name, '.js');
      middlewares[key] = importDefault(fullPath);
    }
  }

  return middlewares;
};
</file>

<file path="src/loaders/policies.ts">
import { join, extname, basename } from 'path';
import fse from 'fs-extra';
import { importDefault } from '@strapi/utils';

import type { Core } from '@strapi/types';

// TODO:: allow folders with index.js inside for bigger policies
export default async function loadPolicies(strapi: Core.Strapi) {
  const dir = strapi.dirs.dist.policies;

  if (!(await fse.pathExists(dir))) {
    return;
  }

  const policies: Record<string, Core.Policy> = {};
  const paths = await fse.readdir(dir, { withFileTypes: true });

  for (const fd of paths) {
    const { name } = fd;
    const fullPath = join(dir, name);

    if (fd.isFile() && extname(name) === '.js') {
      const key = basename(name, '.js');
      policies[key] = importDefault(fullPath);
    }
  }

  strapi.get('policies').add(`global::`, policies);
}
</file>

<file path="src/loaders/sanitizers.ts">
import type { Core } from '@strapi/types';

export default (strapi: Core.Strapi) => {
  strapi.get('sanitizers').set('content-api', { input: [], output: [], query: [] });
};
</file>

<file path="src/loaders/src-index.ts">
import { resolve } from 'path';
import { statSync, existsSync } from 'fs';
import { yup, importDefault } from '@strapi/utils';

import type { Core } from '@strapi/types';

const srcSchema = yup
  .object()
  .shape({
    bootstrap: yup.mixed().isFunction(),
    register: yup.mixed().isFunction(),
    destroy: yup.mixed().isFunction(),
  })
  .noUnknown();

const validateSrcIndex = (srcIndex: unknown) => {
  return srcSchema.validateSync(srcIndex, { strict: true, abortEarly: false });
};

export default (strapi: Core.Strapi) => {
  if (!existsSync(strapi.dirs.dist.src)) {
    return;
  }

  const pathToSrcIndex = resolve(strapi.dirs.dist.src, 'index.js');
  if (!existsSync(pathToSrcIndex) || statSync(pathToSrcIndex).isDirectory()) {
    return {};
  }

  const srcIndex = importDefault(pathToSrcIndex);

  try {
    validateSrcIndex(srcIndex);
  } catch (e) {
    if (e instanceof yup.ValidationError) {
      strapi.stopWithError({ message: `Invalid file \`./src/index.js\`: ${e.message}` });
    }

    throw e;
  }

  strapi.app = srcIndex;
};
</file>

<file path="src/loaders/validators.ts">
import type { Core } from '@strapi/types';

export default (strapi: Core.Strapi) => {
  strapi.get('validators').set('content-api', { input: [], query: [] });
};
</file>

<file path="src/middlewares/__tests__/errors.test.ts">
import Koa from 'koa';
import request from 'supertest';

describe('Errors middleware', () => {
  test('_explicitStatus still exists', async () => {
    // Since we are using an internal variable of koa in our code,
    // we check that it doesn't change in newer updates
    const app = new Koa();

    app.use(async (ctx) => {
      ctx.body = 'hello';
      expect(ctx.response._explicitStatus).toBe(true);
    });

    expect.assertions(1);

    await request(app.callback()).get('/');
  });
});
</file>

<file path="src/middlewares/__tests__/security.test.ts">
import Koa from 'koa';
import request from 'supertest';
import { security } from '../security';

const parseCspHeader = (csp: string) =>
  Object.fromEntries(
    csp
      .split(';')
      .map((directive) => directive.split(' '))
      .map(([k, ...v]) => [k, v])
  );

describe('Security middleware', () => {
  describe('Content security policy', () => {
    // GIVEN
    const app = new Koa();
    const securityMiddleware = security(
      {
        contentSecurityPolicy: {
          useDefaults: true,
          directives: {
            'script-src': ["'self'", 'https://cdn.custom.com'],
            upgradeInsecureRequests: null,
          },
        },
      },
      {
        strapi: {
          plugin: () => null,
          config: {
            get(key: string) {
              if (key === 'admin.path') {
                return '/admin';
              }
            },
          },
        } as any,
      }
    )!;

    // WHEN
    app.use(securityMiddleware);
    const agent = request.agent(app.callback());

    // THEN
    it.each(['/', '/admin', '/api'])(
      'includes user custom CSP directives in GET %s response',
      async (path) => {
        await agent.get(path).expect((req) => {
          const csp = parseCspHeader(req.header['content-security-policy']);
          expect(csp['script-src']).toContain('https://cdn.custom.com');
        });
      }
    );

    it('includes required default CSP directives in GET /admin response', async () => {
      await agent.get('/admin').expect((req) => {
        const csp = parseCspHeader(req.header['content-security-policy']);
        expect(csp['script-src']).toContain("'unsafe-inline'");
        expect(csp['connect-src']).toContain('ws:');
      });
    });

    it('includes required default CSP directives in GET /documentation response', async () => {
      await agent.get('/documentation').expect((req) => {
        const csp = parseCspHeader(req.header['content-security-policy']);
        expect(csp['script-src']).toContain("'unsafe-inline'");
        expect(csp['script-src']).toContain('cdn.jsdelivr.net');
        expect(csp['img-src']).toContain('strapi.io');
        expect(csp['img-src']).toContain('cdn.jsdelivr.net');
      });
    });
  });
});
</file>

<file path="src/middlewares/body.ts">
import fse from 'fs-extra';
import { defaultsDeep } from 'lodash/fp';
import { koaBody, KoaBodyMiddlewareOptions } from 'koa-body';
import mime from 'mime-types';
import type Koa from 'koa';
import type { Core } from '@strapi/types';

export type Config = KoaBodyMiddlewareOptions;

const defaults = {
  multipart: true,
  patchKoa: true,
};

function ensureFileMimeType(file: any): void {
  if (!file.type) {
    file.type = mime.lookup(file.name) || 'application/octet-stream';
  }
}

function getFiles(ctx: Koa.Context) {
  return ctx?.request?.files?.files;
}

const bodyMiddleware: Core.MiddlewareFactory<Config> = (config, { strapi }) => {
  const bodyConfig: Config = defaultsDeep(defaults, config);

  let gqlEndpoint: string | undefined;
  if (strapi.plugin('graphql')) {
    const { config: gqlConfig } = strapi.plugin('graphql');
    gqlEndpoint = gqlConfig('endpoint');
  }

  return async (ctx, next) => {
    // TODO: find a better way later
    if (gqlEndpoint && ctx.url === gqlEndpoint) {
      await next();
    } else {
      try {
        await koaBody(bodyConfig)(ctx, async () => {});

        const files = getFiles(ctx);

        /**
         * in case the mime-type wasn't sent, Strapi tries to guess it
         * from the file extension, to avoid a corrupt database state
         */
        if (files) {
          if (Array.isArray(files)) {
            files.forEach(ensureFileMimeType);
          } else {
            ensureFileMimeType(files);
          }
        }

        await next();
      } catch (error) {
        if (
          error instanceof Error &&
          error.message &&
          error.message.includes('maxFileSize exceeded')
        ) {
          return ctx.payloadTooLarge('FileTooBig');
        }

        throw error;
      }
    }

    const files = getFiles(ctx);

    // clean any file that was uploaded
    if (files) {
      if (Array.isArray(files)) {
        // not awaiting to not slow the request
        Promise.all(files.map((file) => fse.remove(file.filepath)));
      } else if (files && files.filepath) {
        // not awaiting to not slow the request
        fse.remove(files.filepath);
      }
      delete ctx.request.files;
    }
  };
};

export { bodyMiddleware as body };
</file>

<file path="src/middlewares/compression.ts">
import compress from 'koa-compress';
import type { Core } from '@strapi/types';

export type Config = compress.CompressOptions;

export const compression: Core.MiddlewareFactory<Config> = (config) => compress(config);
</file>

<file path="src/middlewares/cors.ts">
import koaCors from '@koa/cors';

import type { Core } from '@strapi/types';

export type Config = {
  enabled?: boolean;
  origin: string | string[] | ((ctx: any) => string | string[]);
  expose?: string | string[];
  maxAge?: number;
  credentials?: boolean;
  methods?: string | string[];
  headers?: string | string[];
  keepHeadersOnError?: boolean;
};

const defaults: Config = {
  origin: '*',
  maxAge: 31536000,
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD', 'OPTIONS'],
  headers: ['Content-Type', 'Authorization', 'Origin', 'Accept'],
  keepHeadersOnError: false,
};

export const cors: Core.MiddlewareFactory<Config> = (config) => {
  const { origin, expose, maxAge, credentials, methods, headers, keepHeadersOnError } = {
    ...defaults,
    ...config,
  };

  if (config.enabled !== undefined) {
    strapi.log.warn(
      'The strapi::cors middleware no longer supports the `enabled` option. Using it' +
        ' to conditionally enable CORS might cause an insecure default. To disable strapi::cors, remove it from' +
        ' the exported array in config/middleware.js'
    );
  }

  return koaCors({
    async origin(ctx) {
      if (!ctx.get('Origin')) {
        return '*';
      }

      let originList: string | string[];

      if (typeof origin === 'function') {
        originList = await origin(ctx);
      } else {
        originList = origin;
      }

      if (Array.isArray(originList)) {
        return originList.includes(ctx.get('Origin')) ? ctx.get('Origin') : '';
      }

      const parsedOrigin = originList.split(',').map((origin) => origin.trim());
      if (parsedOrigin.length > 1) {
        return parsedOrigin.includes(ctx.get('Origin')) ? ctx.get('Origin') : '';
      }

      return originList;
    },
    exposeHeaders: expose,
    maxAge,
    credentials,
    allowMethods: methods,
    allowHeaders: headers,
    keepHeadersOnError,
  });
};
</file>

<file path="src/middlewares/errors.ts">
import { errors } from '@strapi/utils';
import type { Core } from '@strapi/types';

import { formatApplicationError, formatHttpError, formatInternalError } from '../services/errors';

const errorMiddleware: Core.MiddlewareFactory = (/* _, { strapi } */) => {
  return async (ctx, next) => {
    try {
      await next();

      if (!ctx.response._explicitStatus) {
        return ctx.notFound();
      }
    } catch (error) {
      if (error instanceof errors.ApplicationError) {
        const { status, body } = formatApplicationError(error);
        ctx.status = status;
        ctx.body = body;
        return;
      }

      if (error instanceof errors.HttpError) {
        const { status, body } = formatHttpError(error);
        ctx.status = status;
        ctx.body = body;
        return;
      }

      strapi.log.error(error);

      const { status, body } = formatInternalError(error);
      ctx.status = status;
      ctx.body = body;
    }
  };
};

export { errorMiddleware as errors };
</file>

<file path="src/middlewares/favicon.ts">
import { existsSync } from 'fs';
import { resolve } from 'path';
import koaFavicon from 'koa-favicon';
import type { Core } from '@strapi/types';

export type Config = NonNullable<Parameters<typeof koaFavicon>[1]>;

const defaults = {
  path: 'favicon.png',
  maxAge: 86400000,
};

export const favicon: Core.MiddlewareFactory<Config> = (config, { strapi }) => {
  const { maxAge, path: faviconDefaultPath } = { ...defaults, ...config };
  const { root: appRoot } = strapi.dirs.app;
  let faviconPath = faviconDefaultPath;

  /** TODO (v5): Updating the favicon to use a png caused
   *  https://github.com/strapi/strapi/issues/14693
   *
   *  This check ensures backwards compatibility until
   *  the next major version
   */
  if (!existsSync(resolve(appRoot, faviconPath))) {
    faviconPath = 'favicon.ico';
  }

  return koaFavicon(resolve(appRoot, faviconPath), { maxAge });
};
</file>

<file path="src/middlewares/index.ts">
import type { Core } from '@strapi/types';
import { compression } from './compression';
import { cors } from './cors';
import { errors } from './errors';
import { favicon } from './favicon';
import { ip } from './ip';
import { logger } from './logger';
import { poweredBy } from './powered-by';
import { body } from './body';
import { query } from './query';
import { responseTime } from './response-time';
import { responses } from './responses';
import { security } from './security';
import { session } from './session';
import { publicStatic } from './public';

export const middlewares: Record<string, Core.MiddlewareFactory> = {
  compression,
  cors,
  errors,
  favicon,
  ip,
  logger,
  poweredBy,
  body,
  query,
  responseTime,
  responses,
  security,
  session,
  public: publicStatic,
};
</file>

<file path="src/middlewares/ip.ts">
import koaIp from 'koa-ip';
import type { Core } from '@strapi/types';

export type Config = koaIp.KoaIPOptions;

export const ip: Core.MiddlewareFactory<Config> = (config) => koaIp(config);
</file>

<file path="src/middlewares/logger.ts">
import type { Core } from '@strapi/types';

export const logger: Core.MiddlewareFactory = (_, { strapi }) => {
  return async (ctx, next) => {
    const start = Date.now();
    await next();
    const delta = Math.ceil(Date.now() - start);

    strapi.log.http(`${ctx.method} ${ctx.url} (${delta} ms) ${ctx.status}`);
  };
};
</file>

<file path="src/middlewares/powered-by.ts">
import type { Core } from '@strapi/types';

export interface Config {
  poweredBy: string;
}

const defaults: Config = {
  poweredBy: 'Strapi <strapi.io>',
};

export const poweredBy: Core.MiddlewareFactory<Partial<Config>> = (config) => {
  const { poweredBy } = { ...defaults, ...config };

  return async (ctx, next) => {
    await next();

    ctx.set('X-Powered-By', poweredBy);
  };
};
</file>

<file path="src/middlewares/public.ts">
import { defaultsDeep } from 'lodash/fp';
import koaStatic from 'koa-static';
import type { Core } from '@strapi/types';

type Config = koaStatic.Options;

const defaults = {
  maxAge: 60000,
};

export const publicStatic: Core.MiddlewareFactory = (
  config: Config,
  { strapi }: { strapi: Core.Strapi }
) => {
  const { maxAge } = defaultsDeep(defaults, config);

  strapi.server.routes([
    {
      method: 'GET',
      path: '/',
      handler(ctx) {
        ctx.redirect(strapi.config.get('admin.url', '/admin'));
      },
      config: { auth: false },
    },
    // All other public GET-routes except /uploads/(.*) which is handled in upload middleware
    {
      method: 'GET',
      path: '/((?!uploads/).+)',
      handler: koaStatic(strapi.dirs.static.public, {
        maxage: maxAge,
        defer: true,
      }),
      config: { auth: false },
    },
  ]);
};
</file>

<file path="src/middlewares/query.ts">
import qs from 'qs';
import type Koa from 'koa';
import type { Core } from '@strapi/types';

type Config = Parameters<typeof qs.parse>[1];

const defaults: Config = {
  strictNullHandling: true,
  arrayLimit: 100,
  depth: 20,
};

/**
 * Body parser hook
 */
const addQsParser = (app: Koa, settings: Config) => {
  Object.defineProperty(app.request, 'query', {
    configurable: false,
    enumerable: true,
    /*
     * Get parsed query-string.
     */
    get() {
      const qstr = this.querystring;

      this._querycache = this._querycache || {};
      const cache = this._querycache;

      if (!cache[qstr]) {
        cache[qstr] = qs.parse(qstr, settings);
      }

      return cache[qstr];
    },

    /*
     * Set query-string as an object.
     */
    set(obj) {
      this.querystring = qs.stringify(obj);
    },
  } satisfies PropertyDescriptor & ThisType<Koa.BaseRequest>);

  return app;
};

export const query: Core.MiddlewareFactory = (
  config: Partial<Config>,
  { strapi }: { strapi: Core.Strapi }
) => {
  addQsParser(strapi.server.app, { ...defaults, ...config } as Config);
};
</file>

<file path="src/middlewares/response-time.ts">
import type { Core } from '@strapi/types';

export const responseTime: Core.MiddlewareFactory = () => {
  return async (ctx, next) => {
    const start = Date.now();

    await next();

    const delta = Math.ceil(Date.now() - start);
    ctx.set('X-Response-Time', `${delta}ms`);
  };
};
</file>

<file path="src/middlewares/responses.ts">
import { isFunction } from 'lodash/fp';
import type { Core } from '@strapi/types';

export interface Config {
  handlers?: Record<number, Core.MiddlewareHandler>;
}

export const responses: Core.MiddlewareFactory<Config> = (config = {}) => {
  return async (ctx, next) => {
    await next();

    const { status } = ctx;
    const handler = config?.handlers?.[status];

    if (isFunction(handler)) {
      await handler(ctx, next);
    }
  };
};
</file>

<file path="src/middlewares/security.ts">
import { defaultsDeep, mergeWith } from 'lodash/fp';
import helmet, { KoaHelmet } from 'koa-helmet';

import type { Core } from '@strapi/types';

export type Config = NonNullable<Parameters<KoaHelmet>[0]>;

const defaults: Config = {
  crossOriginEmbedderPolicy: false,
  crossOriginOpenerPolicy: false,
  crossOriginResourcePolicy: false,
  originAgentCluster: false,
  contentSecurityPolicy: {
    useDefaults: true,
    directives: {
      'connect-src': ["'self'", 'https:'],
      'img-src': ["'self'", 'data:', 'blob:', 'https://market-assets.strapi.io'],
      'media-src': ["'self'", 'data:', 'blob:'],
      upgradeInsecureRequests: null,
    },
  },
  xssFilter: false,
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
  },
  frameguard: {
    action: 'sameorigin',
  },
};

const mergeConfig = (existingConfig: Config, newConfig: Config) => {
  return mergeWith(
    (obj, src) => (Array.isArray(obj) && Array.isArray(src) ? obj.concat(src) : undefined),
    existingConfig,
    newConfig
  );
};

export const security: Core.MiddlewareFactory<Config> =
  (config, { strapi }) =>
  (ctx, next) => {
    let helmetConfig: Config = defaultsDeep(defaults, config);

    const specialPaths = ['/documentation'];

    const directives: {
      'script-src': string[];
      'img-src': string[];
      'manifest-src': string[];
      'frame-src': string[];
    } = {
      'script-src': ["'self'", "'unsafe-inline'", 'cdn.jsdelivr.net'],
      'img-src': ["'self'", 'data:', 'cdn.jsdelivr.net', 'strapi.io'],
      'manifest-src': [],
      'frame-src': [],
    };

    // if apollo graphql playground is enabled, add exceptions for it
    if (strapi.plugin('graphql')?.service('utils').playground.isEnabled()) {
      const { config: gqlConfig } = strapi.plugin('graphql');
      specialPaths.push(gqlConfig('endpoint'));

      directives['script-src'].push(`https: 'unsafe-inline'`);
      directives['img-src'].push(`'apollo-server-landing-page.cdn.apollographql.com'`);
      directives['manifest-src'].push(`'self'`);
      directives['manifest-src'].push('apollo-server-landing-page.cdn.apollographql.com');
      directives['frame-src'].push(`'self'`);
      directives['frame-src'].push('sandbox.embed.apollographql.com');
    }

    // TODO: we shouldn't combine playground exceptions with documentation for all routes, we should first check the path and then return exceptions specific to that
    if (ctx.method === 'GET' && specialPaths.some((str) => ctx.path.startsWith(str))) {
      helmetConfig = mergeConfig(helmetConfig, {
        crossOriginEmbedderPolicy: false, // TODO: only use this for graphql playground
        contentSecurityPolicy: {
          directives,
        },
      });
    }

    /**
     * These are for vite's watch mode so it can accurately
     * connect to the HMR websocket & reconnect on failure
     * or when the server restarts.
     *
     * It only applies in development, and only on GET requests
     * that are part of the admin route.
     */

    if (
      ['development', 'test'].includes(process.env.NODE_ENV ?? '') &&
      ctx.method === 'GET' &&
      ctx.path.startsWith(strapi.config.get('admin.path'))
    ) {
      helmetConfig = mergeConfig(helmetConfig, {
        contentSecurityPolicy: {
          directives: {
            'script-src': ["'self'", "'unsafe-inline'"],
            'connect-src': ["'self'", 'http:', 'https:', 'ws:'],
          },
        },
      });
    }

    return helmet(helmetConfig)(ctx, next);
  };
</file>

<file path="src/middlewares/session.ts">
import { isEmpty, isArray } from 'lodash/fp';
import koaSession from 'koa-session';
import type { Core } from '@strapi/types';

const defaultConfig = {
  key: 'koa.sess',
  maxAge: 86400000,
  autoCommit: true,
  overwrite: true,
  httpOnly: true,
  signed: true,
  rolling: false,
  renew: false,
  secure: process.env.NODE_ENV === 'production',
  sameSite: undefined,
};

export const session: Core.MiddlewareFactory<Partial<koaSession.opts>> = (
  userConfig,
  { strapi }
) => {
  const { keys } = strapi.server.app;
  if (!isArray(keys) || isEmpty(keys) || keys.some(isEmpty)) {
    throw new Error(
      `App keys are required. Please set app.keys in config/server.js (ex: keys: ['myKeyA', 'myKeyB'])`
    );
  }

  const config: Partial<koaSession.opts> = { ...defaultConfig, ...userConfig };

  strapi.server.use(koaSession(config, strapi.server.app));
};
</file>

<file path="src/migrations/__tests__/i18n.test.ts">
import { enable, disable } from '../i18n';

const createDBQueryMock = () => {
  const obj = {
    deleteMany: jest.fn(() => obj),
    updateMany: jest.fn(() => obj),
  } as any;

  return jest.fn(() => obj);
};

describe('i18n - Migration - enable/disable localization on a CT', () => {
  beforeAll(() => {
    global.strapi = {
      db: {},
      plugins: {
        i18n: {
          services: {
            locales: {
              getDefaultLocale: jest.fn(() => 'default-locale'),
            },
            'content-types': {
              isLocalizedContentType: jest.fn(
                (contentType) => contentType?.pluginOptions?.i18n?.localized === true
              ),
            },
          },
        },
      },
      plugin: jest.fn((name) => global.strapi.plugins[name]),
    } as any;
  });

  describe('enable localization on a CT', () => {
    describe('Should not migrate', () => {
      test('non i18n => non i18n', async () => {
        strapi.db.query = createDBQueryMock();

        const previousDefinition = {};
        const definition = {};

        await enable({
          oldContentTypes: { test: previousDefinition as any },
          contentTypes: { test: definition as any },
        });

        expect(strapi.db.query).not.toHaveBeenCalled();
      });

      test('i18n => non i18n', async () => {
        strapi.db.query = createDBQueryMock();

        const previousDefinition = { pluginOptions: { i18n: { localized: true } } };
        const definition = {};

        await enable({
          oldContentTypes: { test: previousDefinition as any },
          contentTypes: { test: definition as any },
        });

        expect(strapi.db.query).not.toHaveBeenCalled();
      });

      test('i18n => i18n', async () => {
        strapi.db.query = createDBQueryMock();

        const previousDefinition = { pluginOptions: { i18n: { localized: true } } };
        const definition = { pluginOptions: { i18n: { localized: true } } };

        await enable({
          oldContentTypes: { test: previousDefinition as any },
          contentTypes: { test: definition as any },
        });

        expect(strapi.db.query).not.toHaveBeenCalled();
      });
    });

    describe('Should migrate', () => {
      test('non i18n => i18n ', async () => {
        strapi.db.query = createDBQueryMock();

        const previousDefinition = {};
        const definition = { pluginOptions: { i18n: { localized: true } } };

        await enable({
          oldContentTypes: { test: previousDefinition as any },
          contentTypes: { test: definition as any },
        });

        expect(strapi.plugins.i18n.services.locales.getDefaultLocale).toHaveBeenCalled();
        expect(strapi.db.query).toHaveBeenCalled();
      });
    });
  });

  describe('disable localization on a CT', () => {
    describe('Should not migrate', () => {
      test('non i18n => non i18n', async () => {
        strapi.db.query = createDBQueryMock();

        const previousDefinition = {};
        const definition = {};

        await disable({
          oldContentTypes: { test: previousDefinition as any },
          contentTypes: { test: definition as any },
        });
        expect(strapi.db.query).not.toHaveBeenCalled();
      });

      test('non i18n => i18n', async () => {
        strapi.db.query = createDBQueryMock();

        const previousDefinition = {};
        const definition = { pluginOptions: { i18n: { localized: true } } };

        await disable({
          oldContentTypes: { test: previousDefinition as any },
          contentTypes: { test: definition as any },
        });
        expect(strapi.db.query).not.toHaveBeenCalled();
      });

      test('i18n => i18n', async () => {
        strapi.db.query = createDBQueryMock();

        const previousDefinition = { pluginOptions: { i18n: { localized: true } } };
        const definition = { pluginOptions: { i18n: { localized: true } } };

        await disable({
          oldContentTypes: { test: previousDefinition as any },
          contentTypes: { test: definition as any },
        });
        expect(strapi.db.query).not.toHaveBeenCalled();
      });
    });

    describe('Should migrate', () => {
      test('i18n => non i18n - pg', async () => {
        const previousDefinition = {
          pluginOptions: { i18n: { localized: true } },
        };
        const definition = {};

        await disable({
          oldContentTypes: { test: previousDefinition as any },
          contentTypes: { test: definition as any },
        });

        expect(strapi.plugins.i18n.services.locales.getDefaultLocale).toHaveBeenCalled();
        expect(strapi.db.query).toHaveBeenCalled();
      });
    });
  });
});
</file>

<file path="src/migrations/database/5.0.0-discard-drafts.ts">
/**
 * This migration is responsible for creating the draft counterpart for all the entries that were in a published state.
 *
 * In v4, entries could either be in a draft or published state, but not both at the same time.
 * In v5, we introduced the concept of document, and an entry can be in a draft or published state.
 *
 * This means the migration needs to create the draft counterpart if an entry was published.
 *
 * This migration performs the following steps:
 * 1. Creates draft entries for all published entries, without it's components, dynamic zones or relations.
 * 2. Using the document service, discard those same drafts to copy its relations.
 */

/* eslint-disable no-continue */
import type { UID } from '@strapi/types';
import type { Database, Migration } from '@strapi/database';
import { async, contentTypes } from '@strapi/utils';
import { createDocumentService } from '../../services/document-service';

type DocumentVersion = { documentId: string; locale: string };
type Knex = Parameters<Migration['up']>[0];

/**
 * Check if the model has draft and publish enabled.
 */
const hasDraftAndPublish = async (trx: Knex, meta: any) => {
  const hasTable = await trx.schema.hasTable(meta.tableName);

  if (!hasTable) {
    return false;
  }

  const uid = meta.uid as UID.ContentType;
  const model = strapi.getModel(uid);
  const hasDP = contentTypes.hasDraftAndPublish(model);
  if (!hasDP) {
    return false;
  }

  return true;
};

/**
 * Copy all the published entries to draft entries, without it's components, dynamic zones or relations.
 * This ensures all necessary draft's exist before copying it's relations.
 */
async function copyPublishedEntriesToDraft({
  db,
  trx,
  uid,
}: {
  db: Database;
  trx: Knex;
  uid: string;
}) {
  // Extract all scalar attributes to use in the insert query
  const meta = db.metadata.get(uid);

  // Get scalar attributes that will be copied over the new draft
  const scalarAttributes = Object.values(meta.attributes).reduce((acc, attribute: any) => {
    if (['id'].includes(attribute.columnName)) {
      return acc;
    }

    if (contentTypes.isScalarAttribute(attribute)) {
      acc.push(attribute.columnName);
    }

    return acc;
  }, [] as string[]);

  /**
   * Query to copy the published entries into draft entries.
   *
   * INSERT INTO tableName (columnName1, columnName2, columnName3, ...)
   * SELECT columnName1, columnName2, columnName3, ...
   * FROM tableName
   */
  await trx
    // INSERT INTO tableName (columnName1, columnName2, columnName3, ...)
    .into(
      trx.raw(`?? (${scalarAttributes.map(() => `??`).join(', ')})`, [
        meta.tableName,
        ...scalarAttributes,
      ])
    )
    .insert((subQb: typeof trx) => {
      // SELECT columnName1, columnName2, columnName3, ...
      subQb
        .select(
          ...scalarAttributes.map((att: string) => {
            // Override 'publishedAt' and 'updatedAt' attributes
            if (att === 'published_at') {
              return trx.raw('NULL as ??', 'published_at');
            }

            return att;
          })
        )
        .from(meta.tableName)
        // Only select entries that were published
        .whereNotNull('published_at');
    });
}

/**
 * Load a batch of versions to discard.
 *
 * Versions with only a draft version will be ignored.
 * Only versions with a published version (which always have a draft version) will be discarded.
 */
export async function* getBatchToDiscard({
  db,
  trx,
  uid,
  defaultBatchSize = 1000,
}: {
  db: Database;
  trx: Knex;
  uid: string;
  defaultBatchSize?: number;
}) {
  const client = db.config.connection.client;
  const isSQLite =
    typeof client === 'string' && ['sqlite', 'sqlite3', 'better-sqlite3'].includes(client);

  // The SQLite documentation states that the maximum number of terms in a
  // compound SELECT statement is 500 by default.
  // See: https://www.sqlite.org/limits.html
  // To ensure a successful migration, we limit the batch size to 500 for SQLite.
  const batchSize = isSQLite ? Math.min(defaultBatchSize, 500) : defaultBatchSize;
  let offset = 0;
  let hasMore = true;

  while (hasMore) {
    // Look for the published entries to discard
    const batch: DocumentVersion[] = await db
      .queryBuilder(uid)
      .select(['id', 'documentId', 'locale'])
      .where({ publishedAt: { $ne: null } })
      .limit(batchSize)
      .offset(offset)
      .orderBy('id')
      .transacting(trx)
      .execute();

    if (batch.length < batchSize) {
      hasMore = false;
    }

    offset += batchSize;
    yield batch;
  }
}

/**
 * 2 pass migration to create the draft entries for all the published entries.
 * And then discard the drafts to copy the relations.
 */
const migrateUp = async (trx: Knex, db: Database) => {
  const dpModels = [];
  for (const meta of db.metadata.values()) {
    const hasDP = await hasDraftAndPublish(trx, meta);
    if (hasDP) {
      dpModels.push(meta);
    }
  }

  /**
   * Create plain draft entries for all the entries that were published.
   */
  for (const model of dpModels) {
    await copyPublishedEntriesToDraft({ db, trx, uid: model.uid });
  }

  /**
   * Discard the drafts will copy the relations from the published entries to the newly created drafts.
   *
   * Load a batch of entries (batched to prevent loading millions of rows at once ),
   * and discard them using the document service.
   *
   * NOTE: This is using a custom document service without any validations,
   *       to prevent the migration from failing if users already had invalid data in V4.
   *       E.g. @see https://github.com/strapi/strapi/issues/21583
   */
  const documentService = createDocumentService(strapi, {
    async validateEntityCreation(_, data) {
      return data;
    },
    async validateEntityUpdate(_, data) {
      // Data can be partially empty on partial updates
      // This migration doesn't trigger any update (or partial update),
      // so it's safe to return the data as is.
      return data as any;
    },
  });

  for (const model of dpModels) {
    const discardDraft = async (entry: DocumentVersion) =>
      documentService(model.uid as UID.ContentType).discardDraft({
        documentId: entry.documentId,
        locale: entry.locale,
      });

    for await (const batch of getBatchToDiscard({ db, trx, uid: model.uid })) {
      // NOTE: concurrency had to be disabled to prevent a race condition with self-references
      // TODO: improve performance in a safe way
      await async.map(batch, discardDraft, { concurrency: 1 });
    }
  }
};

export const discardDocumentDrafts: Migration = {
  name: 'core::5.0.0-discard-drafts',
  async up(trx, db) {
    await migrateUp(trx, db);
  },
  async down() {
    throw new Error('not implemented');
  },
};
</file>

<file path="src/migrations/draft-publish.ts">
import { contentTypes as contentTypesUtils, async } from '@strapi/utils';
import type { Schema } from '@strapi/types';

import { getBatchToDiscard } from './database/5.0.0-discard-drafts';

export interface Input {
  oldContentTypes: Record<string, Schema.ContentType>;
  contentTypes: Record<string, Schema.ContentType>;
}

/**
 * Enable draft and publish for content types.
 *
 * Draft and publish disabled content types will have their entries published,
 * this migration clones those entries as drafts.
 *
 * TODO: Clone components, dynamic zones and relations
 */
const enableDraftAndPublish = async ({ oldContentTypes, contentTypes }: Input) => {
  if (!oldContentTypes) {
    return;
  }

  // run the after content types migrations
  return strapi.db.transaction(async (trx) => {
    for (const uid in contentTypes) {
      if (!oldContentTypes[uid]) {
        continue;
      }

      const oldContentType = oldContentTypes[uid];
      const contentType = contentTypes[uid];

      // if d&p was enabled set publishedAt to eq createdAt
      if (
        !contentTypesUtils.hasDraftAndPublish(oldContentType) &&
        contentTypesUtils.hasDraftAndPublish(contentType)
      ) {
        const discardDraft = async (entry: { documentId: string; locale: string }) =>
          strapi
            .documents(uid as any)
            // Discard draft by referencing the documentId and locale
            .discardDraft({ documentId: entry.documentId, locale: entry.locale });

        /**
         * Load a batch of entries (batched to prevent loading millions of rows at once ),
         * and discard them using the document service.
         */
        for await (const batch of getBatchToDiscard({ db: strapi.db, trx, uid })) {
          await async.map(batch, discardDraft, { concurrency: 10 });
        }
      }
    }
  });
};

const disableDraftAndPublish = async ({ oldContentTypes, contentTypes }: Input) => {
  if (!oldContentTypes) {
    return;
  }

  for (const uid in contentTypes) {
    if (!oldContentTypes[uid]) {
      continue;
    }

    const oldContentType = oldContentTypes[uid];
    const contentType = contentTypes[uid];

    // if d&p was disabled remove unpublish content before sync
    if (
      contentTypesUtils.hasDraftAndPublish(oldContentType) &&
      !contentTypesUtils.hasDraftAndPublish(contentType)
    ) {
      await strapi.db?.queryBuilder(uid).delete().where({ published_at: null }).execute();
    }
  }
};

export { enableDraftAndPublish as enable, disableDraftAndPublish as disable };
</file>

<file path="src/migrations/i18n.ts">
import { Input } from './draft-publish';

// if i18N enabled set default locale
const enableI18n = async ({ oldContentTypes, contentTypes }: Input) => {
  const { isLocalizedContentType } = strapi.plugin('i18n')?.service('content-types') ?? {};
  const { getDefaultLocale } = strapi.plugin('i18n')?.service('locales') ?? {};

  if (!oldContentTypes) {
    return;
  }

  for (const uid in contentTypes) {
    if (!oldContentTypes[uid]) {
      continue;
    }

    const oldContentType = oldContentTypes[uid];
    const contentType = contentTypes[uid];

    if (!isLocalizedContentType(oldContentType) && isLocalizedContentType(contentType)) {
      const defaultLocale = await getDefaultLocale();

      await strapi.db.query(uid).updateMany({
        where: { locale: null },
        data: { locale: defaultLocale },
      });
    }
  }
};

const disableI18n = async ({ oldContentTypes, contentTypes }: Input) => {
  const { isLocalizedContentType } = strapi.plugin('i18n')?.service('content-types') ?? {};
  const { getDefaultLocale } = strapi.plugin('i18n')?.service('locales') ?? {};

  if (!oldContentTypes) {
    return;
  }

  for (const uid in contentTypes) {
    if (!oldContentTypes[uid]) {
      continue;
    }

    const oldContentType = oldContentTypes[uid];
    const contentType = contentTypes[uid];

    // if i18N is disabled remove non default locales before sync
    if (isLocalizedContentType(oldContentType) && !isLocalizedContentType(contentType)) {
      const defaultLocale = await getDefaultLocale();

      await Promise.all([
        // Delete all entities that are not in the default locale
        strapi.db.query(uid).deleteMany({
          where: { locale: { $ne: defaultLocale } },
        }),
        // Set locale to null for the rest
        strapi.db.query(uid).updateMany({
          where: { locale: { $eq: defaultLocale } },
          data: { locale: null },
        }),
      ]);
    }
  }
};

export { enableI18n as enable, disableI18n as disable };
</file>

<file path="src/migrations/index.ts">
import * as draftPublishMigrations from './draft-publish';
import * as i18nMigrations from './i18n';
import type { Input } from './draft-publish';

const enable = async ({ oldContentTypes, contentTypes }: Input) => {
  await i18nMigrations.enable({ oldContentTypes, contentTypes });
  await draftPublishMigrations.enable({ oldContentTypes, contentTypes });
};

const disable = async ({ oldContentTypes, contentTypes }: Input) => {
  await i18nMigrations.disable({ oldContentTypes, contentTypes });
  await draftPublishMigrations.disable({ oldContentTypes, contentTypes });
};

export { enable, disable };
</file>

<file path="src/providers/admin.ts">
import { defineProvider } from './provider';
import loadAdmin from '../loaders/admin';

export default defineProvider({
  init(strapi) {
    // eslint-disable-next-line node/no-missing-require
    strapi.add('admin', () => require('@strapi/admin/strapi-server'));
  },

  async register(strapi) {
    await loadAdmin(strapi);

    await strapi.get('admin')?.register({ strapi });
  },

  async bootstrap(strapi) {
    await strapi.get('admin')?.bootstrap({ strapi });
  },

  async destroy(strapi) {
    await strapi.get('admin')?.destroy({ strapi });
  },
});
</file>

<file path="src/providers/coreStore.ts">
import { defineProvider } from './provider';
import { createCoreStore, coreStoreModel } from '../services/core-store';

export default defineProvider({
  init(strapi) {
    strapi.get('models').add(coreStoreModel);
    strapi.add('coreStore', () => createCoreStore({ db: strapi.db }));
  },
});
</file>

<file path="src/providers/cron.ts">
import { defineProvider } from './provider';
import createCronService from '../services/cron';

export default defineProvider({
  init(strapi) {
    strapi.add('cron', () => createCronService());
  },
  async bootstrap(strapi) {
    if (strapi.config.get('server.cron.enabled', true)) {
      const cronTasks = strapi.config.get('server.cron.tasks', {});
      strapi.get('cron').add(cronTasks);
    }

    strapi.get('cron').start();
  },
  async destroy(strapi) {
    strapi.get('cron').destroy();
  },
});
</file>

<file path="src/providers/index.ts">
import admin from './admin';
import coreStore from './coreStore';
import cron from './cron';
import registries from './registries';
import telemetry from './telemetry';
import webhooks from './webhooks';

import type { Provider } from './provider';

export const providers: Provider[] = [registries, admin, coreStore, webhooks, telemetry, cron];
</file>

<file path="src/providers/provider.ts">
import type { Core } from '@strapi/types';

export type Provider = {
  init?: (strapi: Core.Strapi) => void;
  register?: (strapi: Core.Strapi) => Promise<void>;
  bootstrap?: (strapi: Core.Strapi) => Promise<void>;
  destroy?: (strapi: Core.Strapi) => Promise<void>;
};

export const defineProvider = (provider: Provider) => provider;
</file>

<file path="src/providers/registries.ts">
import { hooks } from '@strapi/utils';

import { defineProvider } from './provider';
import * as registries from '../registries';
import { loadApplicationContext } from '../loaders';
import * as syncMigrations from '../migrations';
import { discardDocumentDrafts } from '../migrations/database/5.0.0-discard-drafts';

export default defineProvider({
  init(strapi) {
    strapi
      .add('content-types', () => registries.contentTypes())
      .add('components', () => registries.components())
      .add('services', () => registries.services(strapi))
      .add('policies', () => registries.policies())
      .add('middlewares', () => registries.middlewares())
      .add('hooks', () => registries.hooks())
      .add('controllers', () => registries.controllers(strapi))
      .add('modules', () => registries.modules(strapi))
      .add('plugins', () => registries.plugins(strapi))
      .add('custom-fields', () => registries.customFields(strapi))
      .add('apis', () => registries.apis(strapi))
      .add('models', () => registries.models())
      .add('sanitizers', registries.sanitizers())
      .add('validators', registries.validators());
  },
  async register(strapi) {
    await loadApplicationContext(strapi);

    strapi.get('hooks').set('strapi::content-types.beforeSync', hooks.createAsyncParallelHook());
    strapi.get('hooks').set('strapi::content-types.afterSync', hooks.createAsyncParallelHook());

    // Content migration to enable draft and publish
    strapi.hook('strapi::content-types.beforeSync').register(syncMigrations.disable);
    strapi.hook('strapi::content-types.afterSync').register(syncMigrations.enable);

    // Database migrations
    strapi.db.migrations.providers.internal.register(discardDocumentDrafts);
  },
});
</file>

<file path="src/providers/telemetry.ts">
import { defineProvider } from './provider';
import createTelemetry from '../services/metrics';

export default defineProvider({
  init(strapi) {
    strapi.add('telemetry', () => createTelemetry(strapi));
  },
  async register(strapi) {
    strapi.get('telemetry').register();
  },
  async bootstrap(strapi) {
    strapi.get('telemetry').bootstrap();
  },
  async destroy(strapi) {
    strapi.get('telemetry').destroy();
  },
});
</file>

<file path="src/providers/webhooks.ts">
import { defineProvider } from './provider';
import { createWebhookStore, webhookModel } from '../services/webhook-store';
import createWebhookRunner from '../services/webhook-runner';

export default defineProvider({
  init(strapi) {
    strapi.get('models').add(webhookModel);

    strapi.add('webhookStore', () => createWebhookStore({ db: strapi.db }));
    strapi.add('webhookRunner', () =>
      createWebhookRunner({
        eventHub: strapi.eventHub,
        logger: strapi.log,
        configuration: strapi.config.get('server.webhooks', {}),
        fetch: strapi.fetch,
      })
    );
  },
  async bootstrap(strapi) {
    const webhooks = await strapi.get('webhookStore').findWebhooks();
    if (!webhooks) {
      return;
    }

    for (const webhook of webhooks) {
      strapi.get('webhookRunner').add(webhook);
    }
  },
});
</file>

<file path="src/registries/__tests__/components.test.ts">
import type { Schema } from '@strapi/types';

import componentsRegistry from '../components';

describe('componentsRegistry', () => {
  it('should register a component', () => {
    const registry = componentsRegistry();
    const component: Schema.Component = {
      uid: 'default.compo',
      modelType: 'component',
      modelName: 'compo',
      globalId: 'myComponent',
      category: 'default',
      attributes: {},
    };

    registry.set('default.compo', component);

    expect(registry.get('default.compo')).toEqual(component);
  });

  it('should throw an error when registering a component with an existing uid', () => {
    const registry = componentsRegistry();
    const component: Schema.Component = {
      uid: 'default.compo',
      modelType: 'component',
      modelName: 'compo',
      globalId: 'myComponent',
      category: 'default',
      attributes: {},
    };

    registry.set('default.compo', component);

    expect(() => registry.set('default.compo', component)).toThrowError(
      'Component default.compo has already been registered.'
    );
  });

  it('should add multiple components', () => {
    const registry = componentsRegistry();
    const newComponents: Record<string, Schema.Component> = {
      'default.compo': {
        uid: 'default.compo',
        modelType: 'component',
        modelName: 'compo',
        globalId: 'myComponent',
        category: 'default',
        attributes: {},
      },
      'default.compo2': {
        uid: 'default.compo',
        modelType: 'component',
        modelName: 'compo',
        globalId: 'myComponent',
        category: 'default',
        attributes: {},
      },
    };

    registry.add(newComponents);
    expect(registry.getAll()).toEqual(newComponents);
  });
});
</file>

<file path="src/registries/__tests__/config.test.ts">
import { createConfigProvider } from '../../services/config';

const logLevel = 'warn';

describe('config', () => {
  test('returns objects for partial paths', () => {
    const config = createConfigProvider({ default: { child: 'val' } });
    expect(config.get('default')).toEqual({ child: 'val' });
  });

  test('supports full string paths', () => {
    const config = createConfigProvider({ default: { child: 'val' } });
    expect(config.get('default.child')).toEqual('val');
  });

  test('supports array paths', () => {
    const config = createConfigProvider({ default: { child: 'val' } });
    expect(config.get(['default', 'child'])).toEqual('val');
  });

  test('accepts initial values', () => {
    const config = createConfigProvider({ default: 'val', foo: 'bar' });
    expect(config.get('default')).toEqual('val');
    expect(config.get('foo')).toEqual('bar');
  });

  test('accepts uid in paths', () => {
    const config = createConfigProvider({
      'api::myapi': { foo: 'val' },
      'plugin::myplugin': { foo: 'bar' },
    });

    expect(config.get('api::myapi.foo')).toEqual('val');
    expect(config.get('api::myapi')).toEqual({ foo: 'val' });
    expect(config.get('plugin::myplugin.foo')).toEqual('bar');
    expect(config.get('plugin::myplugin')).toEqual({ foo: 'bar' });
  });

  test('`get` supports `plugin::` prefix', () => {
    const consoleSpy = jest.spyOn(console, logLevel).mockImplementation(() => {});

    const config = createConfigProvider({
      'plugin::myplugin': { foo: 'bar' },
    });

    expect(config.get('plugin.myplugin.foo')).toEqual('bar');
    expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('deprecated'));
    consoleSpy.mockRestore();
  });

  test('`get` supports `plugin::model` in array path', () => {
    const consoleSpy = jest.spyOn(console, logLevel).mockImplementation(() => {});

    const config = createConfigProvider({
      'plugin::myplugin': { foo: 'bar' },
    });

    expect(config.get(['plugin::myplugin', 'foo'])).toEqual('bar');
    expect(consoleSpy).not.toHaveBeenCalledWith(expect.stringContaining('deprecated'));
    consoleSpy.mockRestore();
  });

  describe('dot notation deprecations', () => {
    test('`get` supports `plugin.` prefix in string path', () => {
      const consoleSpy = jest.spyOn(console, logLevel).mockImplementation(() => {});

      const config = createConfigProvider({
        'plugin::myplugin': { foo: 'bar' },
      });

      expect(config.get('plugin.myplugin.foo')).toEqual('bar');
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('deprecated'));
      consoleSpy.mockRestore();
    });

    test('`get` supports `plugin.model` prefix in array path', () => {
      const consoleSpy = jest.spyOn(console, logLevel).mockImplementation(() => {});

      const config = createConfigProvider({
        'plugin::myplugin': { foo: 'bar' },
      });

      expect(config.get(['plugin.myplugin', 'foo'])).toEqual('bar');
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('deprecated'));
      consoleSpy.mockRestore();
    });

    test('`get` supports `plugin` + `model` in array path', () => {
      const consoleSpy = jest.spyOn(console, logLevel).mockImplementation(() => {});

      const config = createConfigProvider({
        'plugin::myplugin': { foo: 'bar' },
      });

      expect(config.get(['plugin', 'myplugin', 'foo'])).toEqual('bar');
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('deprecated'));
      consoleSpy.mockRestore();
    });
    test('`set` supports `plugin.` prefix in string path', () => {
      const consoleSpy = jest.spyOn(console, logLevel).mockImplementation(() => {});

      const config = createConfigProvider({
        'plugin::myplugin': { foo: 'bar' },
      });
      config.set('plugin.myplugin.thing', 'val');
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('deprecated'));

      expect(config.get('plugin::myplugin.thing')).toEqual('val');
      consoleSpy.mockRestore();
    });

    test('`set` supports `plugin.` prefix in array path', () => {
      const consoleSpy = jest.spyOn(console, logLevel).mockImplementation(() => {});

      const config = createConfigProvider({
        'plugin::myplugin': { foo: 'bar' },
      });
      config.set(['plugin.myplugin', 'thing'], 'val');
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('deprecated'));

      expect(config.get('plugin::myplugin.thing')).toEqual('val');
      consoleSpy.mockRestore();
    });

    test('`has` supports `plugin.` prefix in string path', () => {
      const consoleSpy = jest.spyOn(console, logLevel).mockImplementation(() => {});

      const config = createConfigProvider({
        'plugin::myplugin': { foo: 'bar' },
      });

      expect(config.has('plugin.myplugin.foo')).toEqual(true);
      expect(config.has('plugin.myplugin.foose')).toEqual(false);
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('deprecated'));
      consoleSpy.mockRestore();
    });

    test('`has` supports `plugin.` prefix in array path', () => {
      const consoleSpy = jest.spyOn(console, logLevel).mockImplementation(() => {});

      const config = createConfigProvider({
        'plugin::myplugin': { foo: 'bar' },
      });

      expect(config.has(['plugin.myplugin', 'foo'])).toEqual(true);
      expect(config.has(['plugin.myplugin', 'foose'])).toEqual(false);
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('deprecated'));
      consoleSpy.mockRestore();
    });

    test('logs deprecation warning with Strapi logger if available', () => {
      const consoleSpy = jest.spyOn(console, logLevel).mockImplementation(() => {});

      const logSpy = jest.fn();
      const config = createConfigProvider(
        {
          'plugin::myplugin': { foo: 'bar' },
        },
        { log: { [logLevel]: logSpy } } as any
      );

      expect(config.get('plugin.myplugin.foo')).toEqual('bar');
      expect(logSpy).toHaveBeenCalledWith(expect.stringContaining('deprecated'));
      expect(consoleSpy).not.toHaveBeenCalled();
      consoleSpy.mockRestore();
    });

    test('get does NOT support deprecation for other prefixes', () => {
      const config = createConfigProvider({
        'api::myapi': { foo: 'bar' },
      });

      expect(config.get('api.myapi')).toEqual(undefined);
    });

    test('set does NOT support deprecation for other prefixes', () => {
      const config = createConfigProvider({
        'api::myapi': { foo: 'bar' },
      });

      config.set('api.myapi.foo', 'nope');
      expect(config.get('api.myapi.foo')).toEqual('nope');
      expect(config.get('api::myapi.foo')).toEqual('bar');
    });
  });
});
</file>

<file path="src/registries/__tests__/custom-fields.test.ts">
import customFieldsRegistry from '../custom-fields';

const strapi = {
  plugins: { plugintest: 'foo' },
  plugin: jest.fn((plugin) => strapi.plugins[plugin]),
};

describe('Custom fields registry', () => {
  describe('add', () => {
    it('adds a custom field registered in a plugin', () => {
      const mockCF = {
        name: 'test',
        plugin: 'plugintest',
        type: 'text',
      };

      const customFields = customFieldsRegistry(strapi);
      customFields.add(mockCF);

      const expected = {
        'plugin::plugintest.test': mockCF,
      };
      expect(customFields.getAll()).toEqual(expected);
    });

    it('adds a custom field not registered in a plugin', () => {
      const mockCF = {
        name: 'test',
        type: 'text',
      };

      const customFields = customFieldsRegistry(strapi);
      customFields.add(mockCF);

      const expected = {
        'global::test': mockCF,
      };
      expect(customFields.getAll()).toEqual(expected);
    });

    it('requires a name key on the custom field', () => {
      const mockCF = {
        type: 'test',
      };

      const customFields = customFieldsRegistry(strapi);

      expect(() => customFields.add(mockCF)).toThrowError(
        `Custom fields require a 'name' and 'type' key`
      );
    });

    it('requires a type key on the custom field', () => {
      const mockCF = {
        name: 'test',
      };

      const customFields = customFieldsRegistry(strapi);

      expect(() => customFields.add(mockCF)).toThrowError(
        `Custom fields require a 'name' and 'type' key`
      );
    });

    it('validates the name can be used as an object key', () => {
      const mockCF = {
        name: 'test.boom',
        type: 'text',
      };

      const customFields = customFieldsRegistry(strapi);

      expect(() => customFields.add(mockCF)).toThrowError(
        `Custom field name: 'test.boom' is not a valid object key`
      );
    });

    it('validates the type is a Strapi type', () => {
      const mockCF = {
        name: 'test',
        type: 'geojson',
      };

      const customFields = customFieldsRegistry(strapi);

      expect(() => customFields.add(mockCF)).toThrowError(
        `Custom field type: 'geojson' is not a valid Strapi type`
      );
    });

    it('validates inputSize', () => {
      const mockCF = {
        name: 'test',
        type: 'text',
      };

      const customFields = customFieldsRegistry(strapi);

      expect(() => customFields.add({ ...mockCF, inputSize: 'small' })).toThrowError(
        `inputSize should be an object with 'default' and 'isResizable' keys`
      );
      expect(() => customFields.add({ ...mockCF, inputSize: ['array'] })).toThrowError(
        `inputSize should be an object with 'default' and 'isResizable' keys`
      );
      expect(() =>
        customFields.add({ ...mockCF, inputSize: { default: 99, isResizable: true } })
      ).toThrowError('Custom fields require a valid default input size');
      expect(() =>
        customFields.add({ ...mockCF, inputSize: { default: 12, isResizable: 'true' } })
      ).toThrowError('Custom fields should specify if their input is resizable');
    });

    it('confirms the custom field does not already exist', () => {
      const mockCF = {
        name: 'test',
        plugin: 'plugintest',
        type: 'text',
      };

      const customFields = customFieldsRegistry(strapi);

      customFields.add(mockCF);
      expect(() => customFields.add(mockCF)).toThrowError(
        `Custom field: 'plugin::plugintest.test' has already been registered`
      );
    });
  });
  describe('get', () => {
    it('gets a registered custom field', () => {
      const mockCF = {
        name: 'test',
        plugin: 'plugintest',
        type: 'text',
      };

      const customFields = customFieldsRegistry(strapi);
      customFields.add(mockCF);

      expect(customFields.get('plugin::plugintest.test')).toEqual(mockCF);
    });

    it('throws when a custom field is not registered', () => {
      const customFields = customFieldsRegistry(strapi);

      expect(() => customFields.get('plugin::plugintest.test')).toThrowError(
        `Could not find Custom Field: plugin::plugintest.test`
      );
    });
  });
});
</file>

<file path="src/registries/__tests__/policies.test.ts">
import createPoliciesRegistry from '../policies';

describe('Policy util', () => {
  const registry = createPoliciesRegistry();

  describe('Get policy', () => {
    test('Throws on policy not found', () => {
      expect(registry.get('undefined')).toBeUndefined();
    });

    test('Retrieves policy by fullName', () => {
      const policyFn = () => {};

      registry.set('global::test-policy', policyFn as any);

      expect(registry.get('global::test-policy')).toBe(policyFn);
    });

    test('Retrieves a global plugin policy', () => {
      const policyFn = () => {};

      registry.set('plugin::test-plugin.test-policy', policyFn as any);

      expect(registry.get('test-plugin.test-policy')).toBeUndefined();
      expect(registry.get('plugin::test-plugin.test-policy')).toBe(policyFn);
    });

    test('Retrieves a plugin policy locally', () => {
      const policyFn = () => {};

      registry.set('plugin::test-plugin.test-policy', policyFn as any);

      expect(registry.get('test-policy', { pluginName: 'test-plugin' })).toBe(policyFn);
    });

    test('Retrieves an api policy locally', () => {
      const policyFn = () => {};

      registry.set('api::test-api.test-policy', policyFn as any);

      expect(registry.get('test-policy', { apiName: 'test-api' })).toBe(policyFn);
    });
  });

  describe('keys', () => {
    test('Returns an array of strings', () => {
      const keysRegistry = createPoliciesRegistry();
      const policyFn = () => {};

      keysRegistry.set('plugin::test-plugin.test-policy', policyFn as any);

      expect(keysRegistry.keys()).toStrictEqual(['plugin::test-plugin.test-policy']);
    });
  });
});
</file>

<file path="src/registries/apis.ts">
import { has } from 'lodash/fp';
import type { Core } from '@strapi/types';

const apisRegistry = (strapi: Core.Strapi) => {
  const apis: Record<string, unknown> = {};

  return {
    get(name: string) {
      return apis[name];
    },
    getAll() {
      return apis;
    },
    add(apiName: string, apiConfig: unknown) {
      if (has(apiName, apis)) {
        throw new Error(`API ${apiName} has already been registered.`);
      }

      const api = strapi.get('modules').add(`api::${apiName}`, apiConfig);

      apis[apiName] = api;

      return apis[apiName];
    },
  };
};

export default apisRegistry;
</file>

<file path="src/registries/components.ts">
import { has } from 'lodash/fp';
import type { Struct, UID } from '@strapi/types';

const componentsRegistry = () => {
  const components: Record<UID.Component, Struct.ComponentSchema> = {};

  return {
    /**
     * Returns this list of registered components uids
     */
    keys(): UID.Component[] {
      return Object.keys(components) as UID.Component[];
    },

    /**
     * Returns the instance of a component. Instantiate the component if not already done
     */
    get(uid: UID.Component) {
      return components[uid];
    },

    /**
     * Returns a map with all the components in a namespace
     */
    getAll() {
      return components;
    },

    /**
     * Registers a component
     */
    set(uid: UID.Component, component: Struct.ComponentSchema) {
      if (has(uid, components)) {
        throw new Error(`Component ${uid} has already been registered.`);
      }

      components[uid] = component;

      return this;
    },

    /**
     * Registers a map of components for a specific namespace
     */
    add(newComponents: Record<UID.Component, Struct.ComponentSchema>) {
      for (const uid of Object.keys(newComponents) as UID.Component[]) {
        this.set(uid, newComponents[uid]);
      }
    },
  };
};

export default componentsRegistry;
</file>

<file path="src/registries/content-types.ts">
import { pickBy, has } from 'lodash/fp';
import type { UID, Struct } from '@strapi/types';
import { createContentType, ContentTypeDefinition } from '../domain/content-type';
import { addNamespace, hasNamespace } from './namespace';

type ContentTypesInput = Record<string, ContentTypeDefinition>;
type ContentTypeExtendFn = (contentType: Struct.ContentTypeSchema) => Struct.ContentTypeSchema;

const validateKeySameToSingularName = (contentTypes: ContentTypesInput) => {
  for (const ctName of Object.keys(contentTypes)) {
    const contentType = contentTypes[ctName];

    if (ctName !== contentType.schema.info.singularName) {
      throw new Error(
        `The key of the content-type should be the same as its singularName. Found ${ctName} and ${contentType.schema.info.singularName}.`
      );
    }
  }
};

const contentTypesRegistry = () => {
  const contentTypes: Record<string, Struct.ContentTypeSchema> = {};

  return {
    /**
     * Returns this list of registered contentTypes uids
     */
    keys() {
      return Object.keys(contentTypes);
    },

    /**
     * Returns the instance of a contentType. Instantiate the contentType if not already done
     */
    get(uid: UID.ContentType) {
      return contentTypes[uid];
    },

    /**
     * Returns a map with all the contentTypes in a namespace
     */
    getAll(namespace: string) {
      return pickBy((_, uid) => hasNamespace(uid, namespace))(contentTypes);
    },

    /**
     * Registers a contentType
     */
    set(uid: UID.ContentType, contentType: Struct.ContentTypeSchema) {
      contentTypes[uid] = contentType;
      return this;
    },

    /**
     * Registers a map of contentTypes for a specific namespace
     */
    add(namespace: string, newContentTypes: ContentTypesInput) {
      validateKeySameToSingularName(newContentTypes);

      for (const rawCtName of Object.keys(newContentTypes)) {
        const uid = addNamespace(rawCtName, namespace);

        if (has(uid, contentTypes)) {
          throw new Error(`Content-type ${uid} has already been registered.`);
        }

        contentTypes[uid] = createContentType(uid, newContentTypes[rawCtName]);
      }
    },

    /**
     * Wraps a contentType to extend it
     */
    extend(ctUID: UID.ContentType, extendFn: ContentTypeExtendFn) {
      const currentContentType = this.get(ctUID);

      if (!currentContentType) {
        throw new Error(`Content-Type ${ctUID} doesn't exist`);
      }

      extendFn(currentContentType);

      return this;
    },
  };
};

export default contentTypesRegistry;
</file>

<file path="src/registries/controllers.ts">
import { pickBy, has } from 'lodash/fp';
import type { Core, UID } from '@strapi/types';
import { addNamespace, hasNamespace } from './namespace';

export type ControllerFactory =
  | ((params: { strapi: Core.Strapi }) => Core.Controller)
  | Core.Controller;
export type ControllerFactoryMap = Record<UID.Controller, ControllerFactory>;
export type ControllerMap = Record<UID.Controller, Core.Controller>;
export type ControllerExtendFn = (service: Core.Controller) => Core.Controller;

const controllersRegistry = (strapi: Core.Strapi) => {
  const controllers: ControllerFactoryMap = {};
  const instances: ControllerMap = {};

  return {
    /**
     * Returns this list of registered controllers uids
     */
    keys() {
      return Object.keys(controllers);
    },

    /**
     * Returns the instance of a controller. Instantiate the controller if not already done
     */
    get(uid: UID.Controller) {
      if (instances[uid]) {
        return instances[uid];
      }

      const controller = controllers[uid];

      if (controller) {
        instances[uid] = typeof controller === 'function' ? controller({ strapi }) : controller;
        return instances[uid];
      }
    },

    /**
     * Returns a map with all the controller in a namespace
     */
    getAll(namespace: string) {
      const filteredControllers = pickBy((_, uid) => hasNamespace(uid, namespace))(controllers);

      const map = {};
      for (const uid of Object.keys(filteredControllers) as UID.Controller[]) {
        Object.defineProperty(map, uid, {
          enumerable: true,
          get: () => {
            return this.get(uid);
          },
        });
      }

      return map;
    },

    /**
     * Registers a controller
     */
    set(uid: UID.Controller, value: ControllerFactory) {
      controllers[uid] = value;
      delete instances[uid];
      return this;
    },

    /**
     * Registers a map of controllers for a specific namespace
     */
    add(namespace: string, newControllers: ControllerFactoryMap) {
      for (const controllerName of Object.keys(newControllers) as UID.Controller[]) {
        const controller = newControllers[controllerName];
        const uid = addNamespace(controllerName, namespace) as UID.Controller;

        if (has(uid, controllers)) {
          throw new Error(`Controller ${uid} has already been registered.`);
        }

        controllers[uid] = controller;
      }

      return this;
    },

    /**
     * Wraps a controller to extend it
     */
    extend(controllerUID: UID.Controller, extendFn: ControllerExtendFn) {
      const currentController = this.get(controllerUID);

      if (!currentController) {
        throw new Error(`Controller ${controllerUID} doesn't exist`);
      }

      const newController = extendFn(currentController);
      instances[controllerUID] = newController;

      return this;
    },
  };
};

export default controllersRegistry;
</file>

<file path="src/registries/custom-fields.ts">
import { has, isPlainObject } from 'lodash/fp';

import type { Core, Modules } from '@strapi/types';

const ALLOWED_TYPES = [
  'biginteger',
  'boolean',
  'date',
  'datetime',
  'decimal',
  'email',
  'enumeration',
  'float',
  'integer',
  'json',
  'password',
  'richtext',
  'string',
  'text',
  'time',
  'uid',
] as const;

const customFieldsRegistry = (strapi: Core.Strapi) => {
  const customFields: Record<string, unknown> = {};

  return {
    getAll() {
      return customFields;
    },
    get(customField: string) {
      const registeredCustomField = customFields[customField];
      if (!registeredCustomField) {
        throw new Error(`Could not find Custom Field: ${customField}`);
      }

      return registeredCustomField;
    },
    add(
      customField:
        | Modules.CustomFields.CustomFieldServerOptions
        | Modules.CustomFields.CustomFieldServerOptions[]
    ) {
      const customFieldList = Array.isArray(customField) ? customField : [customField];

      for (const cf of customFieldList) {
        if (!has('name', cf) || !has('type', cf)) {
          throw new Error(`Custom fields require a 'name' and 'type' key`);
        }

        const { name, plugin, type, inputSize } = cf;
        if (!ALLOWED_TYPES.includes(type)) {
          throw new Error(
            `Custom field type: '${type}' is not a valid Strapi type or it can't be used with a Custom Field`
          );
        }

        const isValidObjectKey = /^(?![0-9])[a-zA-Z0-9$_-]+$/g;
        if (!isValidObjectKey.test(name)) {
          throw new Error(`Custom field name: '${name}' is not a valid object key`);
        }

        // Validate inputSize when provided
        if (inputSize) {
          if (
            !isPlainObject(inputSize) ||
            !has('default', inputSize) ||
            !has('isResizable', inputSize)
          ) {
            throw new Error(`inputSize should be an object with 'default' and 'isResizable' keys`);
          }
          if (![4, 6, 8, 12].includes(inputSize.default)) {
            throw new Error('Custom fields require a valid default input size');
          }
          if (typeof inputSize.isResizable !== 'boolean') {
            throw new Error('Custom fields should specify if their input is resizable');
          }
        }

        // When no plugin is specified, or it isn't found in Strapi, default to global
        const uid =
          plugin && strapi.plugin(plugin) ? `plugin::${plugin}.${name}` : `global::${name}`;

        if (has(uid, customFields)) {
          throw new Error(`Custom field: '${uid}' has already been registered`);
        }

        customFields[uid] = cf;
      }
    },
  };
};

export default customFieldsRegistry;
</file>

<file path="src/registries/hooks.ts">
import { pickBy } from 'lodash/fp';
import { addNamespace, hasNamespace } from './namespace';

type Handler = (context: any) => any;

type AsyncHook = {
  handlers: Handler[];
  register(handler: Handler): AsyncHook;
  delete(handler: Handler): AsyncHook;
  call(): Promise<void>;
};

type SyncHook = {
  get handlers(): Handler[];
  register(handler: Handler): SyncHook;
  delete(handler: Handler): SyncHook;
  call(): void;
};

export type Hook = AsyncHook | SyncHook;

type HookExtendFn = (hook: Hook) => Hook;

const hooksRegistry = () => {
  const hooks: Record<string, Hook> = {};

  return {
    /**
     * Returns this list of registered hooks uids
     */
    keys() {
      return Object.keys(hooks);
    },

    /**
     * Returns the instance of a hook.
     */
    get(uid: string) {
      return hooks[uid];
    },

    /**
     * Returns a map with all the hooks in a namespace
     */
    getAll(namespace: string) {
      return pickBy((_, uid) => hasNamespace(uid, namespace))(hooks);
    },

    /**
     * Registers a hook
     */
    set(uid: string, hook: Hook) {
      hooks[uid] = hook;
      return this;
    },

    /**
     * Registers a map of hooks for a specific namespace
     */
    add(namespace: string, hooks: Record<string, Hook>) {
      for (const hookName of Object.keys(hooks)) {
        const hook = hooks[hookName];
        const uid = addNamespace(hookName, namespace);

        this.set(uid, hook);
      }

      return this;
    },

    /**
     * Wraps a hook to extend it
     */
    extend(uid: string, extendFn: HookExtendFn) {
      const currentHook = this.get(uid);

      if (!currentHook) {
        throw new Error(`Hook ${uid} doesn't exist`);
      }

      const newHook = extendFn(currentHook);
      hooks[uid] = newHook;

      return this;
    },
  };
};

export default hooksRegistry;
</file>

<file path="src/registries/index.ts">
export { default as contentTypes } from './content-types';
export { default as components } from './components';
export { default as services } from './services';
export { default as policies } from './policies';
export { default as middlewares } from './middlewares';
export { default as hooks } from './hooks';
export { default as controllers } from './controllers';
export { default as modules } from './modules';
export { default as plugins } from './plugins';
export { default as customFields } from './custom-fields';
export { default as apis } from './apis';
export { default as sanitizers } from './sanitizers';
export { default as validators } from './validators';
export { registry as models } from './models';
</file>

<file path="src/registries/middlewares.ts">
import { pickBy, has } from 'lodash/fp';
import type { Core, UID } from '@strapi/types';
import { addNamespace, hasNamespace } from './namespace';

type MiddlewareExtendFn = (middleware: Core.Middleware) => Core.Middleware;

// TODO: move instantiation part here instead of in the server service
const middlewaresRegistry = () => {
  const middlewares: Record<UID.Middleware, Core.Middleware> = {};

  return {
    /**
     * Returns this list of registered middlewares uids
     */
    keys() {
      return Object.keys(middlewares);
    },

    /**
     * Returns the instance of a middleware. Instantiate the middleware if not already done
     */
    get(uid: UID.Middleware) {
      return middlewares[uid];
    },

    /**
     * Returns a map with all the middlewares in a namespace
     */
    getAll(namespace: string) {
      return pickBy((_, uid) => hasNamespace(uid, namespace))(middlewares);
    },

    /**
     * Registers a middleware
     */
    set(uid: UID.Middleware, middleware: Core.Middleware) {
      middlewares[uid] = middleware;
      return this;
    },

    /**
     * Registers a map of middlewares for a specific namespace
     */
    add(namespace: string, rawMiddlewares: Record<string, Core.Middleware> = {}) {
      for (const middlewareName of Object.keys(rawMiddlewares)) {
        const middleware = rawMiddlewares[middlewareName];
        const uid = addNamespace(middlewareName, namespace) as UID.Middleware;

        if (has(uid, middlewares)) {
          throw new Error(`Middleware ${uid} has already been registered.`);
        }
        middlewares[uid] = middleware;
      }
    },

    /**
     * Wraps a middleware to extend it
     */
    extend(uid: UID.Middleware, extendFn: MiddlewareExtendFn) {
      const currentMiddleware = this.get(uid);

      if (!currentMiddleware) {
        throw new Error(`Middleware ${uid} doesn't exist`);
      }

      const newMiddleware = extendFn(currentMiddleware);
      middlewares[uid] = newMiddleware;

      return this;
    },
  };
};

export default middlewaresRegistry;
</file>

<file path="src/registries/models.ts">
import { Model } from '@strapi/database';

export const registry = () => {
  const models: Model[] = [];

  return {
    add(model: Model) {
      models.push(model);
      return this;
    },

    get() {
      return models;
    },
  };
};
</file>

<file path="src/registries/modules.ts">
import { pickBy, has } from 'lodash/fp';
import type { Core } from '@strapi/types';
import { createModule, RawModule, Module } from '../domain/module';

type ModuleMap = { [namespace: string]: Module };

const modulesRegistry = (strapi: Core.Strapi) => {
  const modules: ModuleMap = {};

  return {
    get(namespace: string) {
      return modules[namespace];
    },
    getAll(prefix = '') {
      return pickBy<ModuleMap>((mod, namespace) => namespace.startsWith(prefix))(modules);
    },
    add(namespace: string, rawModule: RawModule) {
      if (has(namespace, modules)) {
        throw new Error(`Module ${namespace} has already been registered.`);
      }

      modules[namespace] = createModule(namespace, rawModule, strapi);
      modules[namespace].load();

      return modules[namespace];
    },
    async bootstrap() {
      for (const mod of Object.values(modules)) {
        await mod.bootstrap();
      }
    },
    async register() {
      for (const mod of Object.values(modules)) {
        await mod.register();
      }
    },
    async destroy() {
      for (const mod of Object.values(modules)) {
        await mod.destroy();
      }
    },
  };
};

export default modulesRegistry;
</file>

<file path="src/registries/namespace.ts">
const hasNamespace = (name: string, namespace: string) => {
  if (!namespace) {
    return true;
  }

  if (namespace.endsWith('::')) {
    return name.startsWith(namespace);
  }
  return name.startsWith(`${namespace}.`);
};

const addNamespace = (name: string, namespace: string) => {
  if (namespace.endsWith('::')) {
    return `${namespace}${name}`;
  }
  return `${namespace}.${name}`;
};

const removeNamespace = (name: string, namespace: string) => {
  if (namespace.endsWith('::')) {
    return name.replace(namespace, '');
  }
  return name.replace(`${namespace}.`, '');
};

export { addNamespace, removeNamespace, hasNamespace };
</file>

<file path="src/registries/plugins.ts">
import { has } from 'lodash/fp';

import type { Core } from '@strapi/types';

type PluginMap = Record<string, Core.Plugin>;

const pluginsRegistry = (strapi: Core.Strapi) => {
  const plugins: PluginMap = {};

  return {
    get(name: string) {
      return plugins[name];
    },
    getAll() {
      return plugins;
    },
    add(name: string, pluginConfig: Core.Plugin) {
      if (has(name, plugins)) {
        throw new Error(`Plugin ${name} has already been registered.`);
      }

      const pluginModule = strapi.get('modules').add(`plugin::${name}`, pluginConfig);
      plugins[name] = pluginModule;

      return plugins[name];
    },
  };
};

export default pluginsRegistry;
</file>

<file path="src/registries/policies.ts">
import { pickBy, has, castArray } from 'lodash/fp';
import type { Core } from '@strapi/types';
import { addNamespace, hasNamespace } from './namespace';

const PLUGIN_PREFIX = 'plugin::';
const API_PREFIX = 'api::';

interface PolicyInfo {
  name: string;
  config: unknown;
}

type PolicyConfig = string | PolicyInfo;

interface NamespaceInfo {
  pluginName?: string;
  apiName?: string;
}

const parsePolicy = (policy: string | PolicyInfo) => {
  if (typeof policy === 'string') {
    return { policyName: policy, config: {} };
  }

  const { name, config } = policy;
  return { policyName: name, config };
};

const policiesRegistry = () => {
  const policies = new Map<string, Core.Policy>();

  const find = (name: string, namespaceInfo?: NamespaceInfo) => {
    const { pluginName, apiName } = namespaceInfo ?? {};

    // try to resolve a full name to avoid extra prefixing
    const policy = policies.get(name);

    if (policy) {
      return policy;
    }

    if (pluginName) {
      return policies.get(`${PLUGIN_PREFIX}${pluginName}.${name}`);
    }

    if (apiName) {
      return policies.get(`${API_PREFIX}${apiName}.${name}`);
    }
  };

  function resolveHandler(policyConfig: PolicyConfig, namespaceInfo?: NamespaceInfo): Core.Policy;
  function resolveHandler(
    policyConfig: PolicyConfig[],
    namespaceInfo?: NamespaceInfo
  ): Core.Policy[];
  function resolveHandler(
    policyConfig: PolicyConfig | PolicyConfig[],
    namespaceInfo?: NamespaceInfo
  ): Core.Policy | Core.Policy[] {
    if (Array.isArray(policyConfig)) {
      return policyConfig.map((config) => {
        return resolveHandler(config, namespaceInfo);
      });
    }

    const { policyName, config } = parsePolicy(policyConfig);

    const policy = find(policyName, namespaceInfo);

    if (!policy) {
      throw new Error(`Policy ${policyName} not found.`);
    }

    if (typeof policy === 'function') {
      return policy;
    }

    if (policy.validator) {
      policy.validator(config);
    }

    return policy.handler;
  }

  return {
    /**
     * Returns this list of registered policies uids
     */
    keys() {
      // Return an array so format stays the same as controllers, services, etc
      return Array.from(policies.keys());
    },

    /**
     * Returns the instance of a policy. Instantiate the policy if not already done
     */
    get(name: string, namespaceInfo?: NamespaceInfo) {
      return find(name, namespaceInfo);
    },
    /**
     * Checks if a policy is registered
     */
    has(name: string, namespaceInfo?: NamespaceInfo) {
      const res = find(name, namespaceInfo);
      return !!res;
    },

    /**
     * Returns a map with all the policies in a namespace
     */
    getAll(namespace: string) {
      return pickBy((_, uid) => hasNamespace(uid, namespace))(Object.fromEntries(policies));
    },

    /**
     * Registers a policy
     */
    set(uid: string, policy: Core.Policy) {
      policies.set(uid, policy);
      return this;
    },

    /**
     * Registers a map of policies for a specific namespace
     */
    add(namespace: string, newPolicies: Record<string, Core.Policy>) {
      for (const policyName of Object.keys(newPolicies)) {
        const policy = newPolicies[policyName];
        const uid = addNamespace(policyName, namespace);

        if (has(uid, policies)) {
          throw new Error(`Policy ${uid} has already been registered.`);
        }

        policies.set(uid, policy);
      }
    },

    /**
     * Resolves a list of policies
     */
    resolve(config: PolicyConfig | PolicyConfig[], namespaceInfo?: NamespaceInfo) {
      const { pluginName, apiName } = namespaceInfo ?? {};

      return castArray(config).map((policyConfig) => {
        return {
          handler: resolveHandler(policyConfig, { pluginName, apiName }),
          config: (typeof policyConfig === 'object' && policyConfig.config) || {},
        };
      });
    },
  };
};

export default policiesRegistry;
</file>

<file path="src/registries/sanitizers.ts">
import _, { PropertyName } from 'lodash';

type Sanitizer = (value: unknown) => unknown;

const sanitizersRegistry = () => {
  const sanitizers: Record<string, Sanitizer[]> = {};

  return {
    get(path: PropertyName): Sanitizer[] {
      return _.get(sanitizers, path, []);
    },

    add(path: PropertyName, sanitizer: Sanitizer) {
      this.get(path).push(sanitizer);
      return this;
    },

    set(path: PropertyName, value = []) {
      _.set(sanitizers, path, value);
      return this;
    },

    has(path: PropertyName) {
      return _.has(sanitizers, path);
    },
  };
};

export default sanitizersRegistry;
</file>

<file path="src/registries/services.ts">
import { pickBy, has } from 'lodash/fp';
import type { Core, UID } from '@strapi/types';
import { addNamespace, hasNamespace } from './namespace';

export type ServiceFactory = (params: { strapi: Core.Strapi }) => Core.Service | Core.Service;
export type ServiceFactoryMap = Record<string, ServiceFactory>;
export type ServiceMap = Record<string, Core.Service>;
export type ServiceExtendFn = (service: Core.Service) => Core.Service;

const servicesRegistry = (strapi: Core.Strapi) => {
  const services: ServiceFactoryMap = {};
  const instantiatedServices: ServiceMap = {};

  return {
    /**
     * Returns this list of registered services uids
     */
    keys() {
      return Object.keys(services);
    },

    /**
     * Returns the instance of a service. Instantiate the service if not already done
     */
    get(uid: UID.Service) {
      if (instantiatedServices[uid]) {
        return instantiatedServices[uid];
      }

      const service = services[uid];
      if (service) {
        instantiatedServices[uid] = typeof service === 'function' ? service({ strapi }) : service;
        return instantiatedServices[uid];
      }
    },

    /**
     * Returns a map with all the services in a namespace
     */
    getAll(namespace: string): ServiceMap {
      const filteredServices = pickBy((_, uid) => hasNamespace(uid, namespace))(services);

      // create lazy accessor to avoid instantiating the services;
      const map = {};
      for (const uid of Object.keys(filteredServices)) {
        Object.defineProperty(map, uid, {
          enumerable: true,
          get: () => {
            return this.get(uid as UID.Service);
          },
        });
      }

      return map;
    },

    /**
     * Registers a service
     */
    set(uid: string, service: ServiceFactory) {
      services[uid] = service;
      delete instantiatedServices[uid];
      return this;
    },

    /**
     * Registers a map of services for a specific namespace
     */
    add(namespace: string, newServices: ServiceFactoryMap) {
      for (const serviceName of Object.keys(newServices)) {
        const service = newServices[serviceName];
        const uid = addNamespace(serviceName, namespace);

        if (has(uid, services)) {
          throw new Error(`Service ${uid} has already been registered.`);
        }
        services[uid] = service;
      }

      return this;
    },

    /**
     * Wraps a service to extend it
     */
    extend(uid: UID.Service, extendFn: ServiceExtendFn) {
      const currentService = this.get(uid);

      if (!currentService) {
        throw new Error(`Service ${uid} doesn't exist`);
      }

      const newService = extendFn(currentService);
      instantiatedServices[uid] = newService;

      return this;
    },
  };
};

export default servicesRegistry;
</file>

<file path="src/registries/validators.ts">
import _, { PropertyName } from 'lodash';

type Validator = unknown;

const validatorsRegistry = () => {
  const validators: Record<string, Validator[]> = {};

  return {
    get(path: PropertyName): Validator[] {
      return _.get(validators, path, []);
    },

    add(path: PropertyName, validator: Validator) {
      this.get(path).push(validator);
      return this;
    },

    set(path: PropertyName, value = []) {
      _.set(validators, path, value);
      return this;
    },

    has(path: PropertyName) {
      return _.has(validators, path);
    },
  };
};

export default validatorsRegistry;
</file>

<file path="src/services/__tests__/content-api-permissions.test.ts">
import createContentAPI from '../content-api';

const strapiMock = {
  sanitizers: {
    get() {
      return [];
    },
  },
  validators: {
    get() {
      return [];
    },
  },
};

describe('Content API - Permissions', () => {
  const bindToContentAPI = (action: any) => {
    Object.assign(action, { [Symbol.for('__type__')]: ['content-api'] });
    return action;
  };

  describe('Get Actions Map', () => {
    test('When no API are defined, it should return an empty object', () => {
      global.strapi = strapiMock as any;

      const contentAPI = createContentAPI(global.strapi);
      const actionsMap = contentAPI.permissions.getActionsMap();

      expect(actionsMap).toEqual({});
    });

    test('When no controller are defined for an API, it should ignore the API', () => {
      global.strapi = {
        ...strapiMock,
        apis: {
          foo: {},
          bar: {},
        },
      } as any;

      const contentAPI = createContentAPI(global.strapi);
      const actionsMap = contentAPI.permissions.getActionsMap();

      expect(actionsMap).toEqual({});
    });

    test(`Do not register controller if they're not bound to the content API`, () => {
      const actionC = () => {};
      Object.assign(actionC, { [Symbol.for('__type__')]: ['admin-api'] });

      global.strapi = {
        ...strapiMock,
        apis: {
          foo: {
            controllers: {
              controllerA: {
                actionA: bindToContentAPI(() => {}),
                actionB() {},
                actionC,
              },
            },
          },
        },
      } as any;

      const contentAPI = createContentAPI(global.strapi);
      const actionsMap = contentAPI.permissions.getActionsMap();

      expect(actionsMap).toEqual({
        'api::foo': { controllers: { controllerA: ['actionA'] } },
      });
    });

    test('Creates and populate a map of actions from APIs and plugins', () => {
      global.strapi = {
        ...strapiMock,
        apis: {
          foo: {
            controllers: {
              controllerA: {
                actionA: bindToContentAPI(() => {}),
                actionB: bindToContentAPI(() => {}),
              },
            },
          },
          bar: {
            controllers: {
              controllerA: {
                actionA: bindToContentAPI(() => {}),
                actionB: bindToContentAPI(() => {}),
              },
            },
          },
          foobar: {
            controllers: {
              controllerA: {
                actionA: bindToContentAPI(() => {}),
                actionB: bindToContentAPI(() => {}),
              },
              controllerB: {
                actionC: bindToContentAPI(() => {}),
                actionD: bindToContentAPI(() => {}),
              },
            },
          },
        },
        plugins: {
          foo: {
            controllers: {
              controllerA: {
                actionA: bindToContentAPI(() => {}),
                actionB: bindToContentAPI(() => {}),
              },
            },
          },
          bar: {
            controllers: {
              controllerA: {
                actionA: bindToContentAPI(() => {}),
                actionB: bindToContentAPI(() => {}),
              },
            },
          },
        },
      } as any;

      const contentAPI = createContentAPI(global.strapi);
      const actionsMap = contentAPI.permissions.getActionsMap();

      expect(actionsMap).toEqual({
        'api::foo': { controllers: { controllerA: ['actionA', 'actionB'] } },
        'api::bar': { controllers: { controllerA: ['actionA', 'actionB'] } },
        'api::foobar': {
          controllers: {
            controllerA: ['actionA', 'actionB'],
            controllerB: ['actionC', 'actionD'],
          },
        },
        'plugin::foo': { controllers: { controllerA: ['actionA', 'actionB'] } },
        'plugin::bar': { controllers: { controllerA: ['actionA', 'actionB'] } },
      });
    });
  });

  describe('Register Actions', () => {
    beforeEach(() => {
      global.strapi = {
        ...strapiMock,
        apis: {
          foo: {
            controllers: {
              controllerA: {
                actionA: bindToContentAPI(() => {}),
                actionB: bindToContentAPI(() => {}),
              },
              controllerB: {
                actionC: bindToContentAPI(() => {}),
                actionD: bindToContentAPI(() => {}),
              },
            },
          },
        },
        plugins: {
          foo: {
            controllers: {
              controllerA: {
                actionA: bindToContentAPI(() => {}),
              },
            },
          },
        },
      } as any;
    });

    test('The action provider should holds every action from APIs and plugins', async () => {
      const contentAPI = createContentAPI(global.strapi);

      await contentAPI.permissions.registerActions();

      const values = contentAPI.permissions.providers.action.values();

      expect(values).toEqual([
        {
          uid: 'api::foo.controllerA.actionA',
          api: 'api::foo',
          controller: 'controllerA',
          action: 'actionA',
        },
        {
          uid: 'api::foo.controllerA.actionB',
          api: 'api::foo',
          controller: 'controllerA',
          action: 'actionB',
        },
        {
          uid: 'api::foo.controllerB.actionC',
          api: 'api::foo',
          controller: 'controllerB',
          action: 'actionC',
        },
        {
          uid: 'api::foo.controllerB.actionD',
          api: 'api::foo',
          controller: 'controllerB',
          action: 'actionD',
        },
        {
          uid: 'plugin::foo.controllerA.actionA',
          api: 'plugin::foo',
          controller: 'controllerA',
          action: 'actionA',
        },
      ]);
    });

    test('Call registerActions twice should throw a duplicate error', async () => {
      const contentAPI = createContentAPI(global.strapi);

      await contentAPI.permissions.registerActions();

      expect(() => contentAPI.permissions.registerActions()).rejects.toThrowError(
        'Duplicated item key: api::foo.controllerA.actionA'
      );
    });
  });

  describe('Providers', () => {
    test('You should not be able to register action once strapi is loaded', () => {
      global.strapi.isLoaded = true;

      const contentAPI = createContentAPI(global.strapi);

      // Actions
      expect(() =>
        contentAPI.permissions.providers.action.register('foo', {})
      ).rejects.toThrowError(`You can't register new actions outside the bootstrap function.`);

      // Conditions
      expect(() =>
        contentAPI.permissions.providers.condition.register({ name: 'myCondition' })
      ).rejects.toThrowError(`You can't register new conditions outside the bootstrap function.`);

      // Register Actions
      expect(() => contentAPI.permissions.registerActions()).rejects.toThrowError(
        `You can't register new actions outside the bootstrap function.`
      );
    });
  });

  describe('Engine', () => {
    test('Engine warns when registering an unknown action', async () => {
      global.strapi = {
        ...strapiMock,
        log: {
          debug: jest.fn(),
        },
      } as any;

      const contentAPI = createContentAPI(global.strapi);

      const ability = await contentAPI.permissions.engine.generateAbility([{ action: 'foo' }]);

      expect(ability.rules).toHaveLength(0);
      expect(global.strapi.log.debug).toHaveBeenCalledWith(
        `Unknown action "foo" supplied when registering a new permission`
      );
    });

    test('Engine filter out invalid action when generating an ability', async () => {
      global.strapi = {
        ...strapiMock,
        log: {
          debug: jest.fn(),
        },

        apis: {
          foo: {
            controllers: {
              bar: { foobar: bindToContentAPI(() => {}) },
            },
          },
        },
      } as any;

      const contentAPI = createContentAPI(global.strapi);

      await contentAPI.permissions.registerActions();

      const ability = await contentAPI.permissions.engine.generateAbility([
        { action: 'foo' },
        { action: 'api::foo.bar.foobar' },
      ]);

      expect(ability.rules).toHaveLength(1);
      expect(ability.rules).toEqual([
        {
          action: 'api::foo.bar.foobar',
          subject: 'all',
        },
      ]);

      expect(global.strapi.log.debug).toHaveBeenCalledTimes(1);
      expect(global.strapi.log.debug).toHaveBeenCalledWith(
        `Unknown action "foo" supplied when registering a new permission`
      );
    });
  });
});
</file>

<file path="src/services/__tests__/core-store.test.ts">
import { createCoreStore } from '../core-store';

const data = {
  key: 'testKey',
  value: 'testValue',
};

const queryRes = {
  id: 1,
  key: 'testKey',
  value: 'testValue',
  type: 'string',
  environment: null,
  tag: null,
};

const where = {
  key: 'plugin_testName_testKey',
  environment: 'test',
  tag: null,
};

describe('Core Store', () => {
  test('Set key in empty store', async () => {
    const fakeEmptyDBQuery = {
      findOne: jest.fn(() => Promise.resolve()),
      update: jest.fn(() => Promise.resolve(queryRes)),
      create: jest.fn(() => Promise.resolve(queryRes)),
      delete: jest.fn(() => Promise.resolve()),
    };

    const fakeEmptyDB = {
      query: jest.fn(() => fakeEmptyDBQuery),
    };

    const emptyTestStore = createCoreStore({
      db: fakeEmptyDB,
    });

    const store = emptyTestStore({
      environment: 'test',
      type: 'plugin',
      name: 'testName',
    });

    await store.set(data);

    expect(fakeEmptyDB.query).toHaveBeenCalledTimes(2);
    expect(fakeEmptyDBQuery.findOne).toHaveBeenCalledWith({ where });
    expect(fakeEmptyDBQuery.create).toHaveBeenCalledWith({
      data: { ...where, value: JSON.stringify('testValue'), type: 'string' },
    });
  });

  test('Set key in not empty store', async () => {
    const fakeNotEmptyDBQuery = {
      findOne: jest.fn(() => Promise.resolve(queryRes)),
      update: jest.fn(() => Promise.resolve(queryRes)),
      create: jest.fn(() => Promise.resolve(queryRes)),
      delete: jest.fn(() => Promise.resolve()),
    };

    const fakeNotEmptyDB = {
      query: jest.fn(() => fakeNotEmptyDBQuery),
    };

    const notEmptyTestStore = createCoreStore({
      db: fakeNotEmptyDB,
    });

    const store = notEmptyTestStore({
      environment: 'test',
      type: 'plugin',
      name: 'testName',
    });

    await store.set(data);

    expect(fakeNotEmptyDB.query).toHaveBeenCalledTimes(2);
    expect(fakeNotEmptyDBQuery.findOne).toHaveBeenCalledWith({ where });
    expect(fakeNotEmptyDBQuery.update).toHaveBeenCalledWith({
      where: { id: queryRes.id },
      data: {
        type: 'string',
        value: JSON.stringify('testValue'),
      },
    });
  });

  test('Delete key from empty store', async () => {
    const fakeEmptyDBQuery = {
      findOne: jest.fn(() => Promise.resolve()),
      update: jest.fn(() => Promise.resolve(queryRes)),
      create: jest.fn(() => Promise.resolve(queryRes)),
      delete: jest.fn(() => Promise.resolve()),
    };

    const fakeEmptyDB = {
      query: jest.fn(() => fakeEmptyDBQuery),
    };

    const emptyTestStore = createCoreStore({
      db: fakeEmptyDB,
    });

    const store = emptyTestStore({
      environment: 'test',
      type: 'plugin',
      name: 'testName',
    });

    await store.delete(data);

    expect(fakeEmptyDB.query).toHaveBeenCalledTimes(1);
    expect(fakeEmptyDBQuery.delete).toHaveBeenCalledWith({ where });
  });

  test('Delete key from not empty store', async () => {
    const fakeNotEmptyDBQuery = {
      findOne: jest.fn(() => Promise.resolve(queryRes)),
      update: jest.fn(() => Promise.resolve(queryRes)),
      create: jest.fn(() => Promise.resolve(queryRes)),
      delete: jest.fn(() => Promise.resolve()),
    };

    const fakeNotEmptyDB = {
      query: jest.fn(() => fakeNotEmptyDBQuery),
    };

    const notEmptyTestStore = createCoreStore({
      db: fakeNotEmptyDB,
    });

    const store = notEmptyTestStore({
      environment: 'test',
      type: 'plugin',
      name: 'testName',
    });

    const rest = await store.delete(data);

    expect(fakeNotEmptyDB.query).toHaveBeenCalledTimes(1);
    expect(fakeNotEmptyDBQuery.delete).toHaveBeenCalledWith({ where });
    expect(rest).toEqual(undefined);
  });
});
</file>

<file path="src/services/__tests__/event-hub.test.ts">
import createEventHub from '../event-hub';

describe('Event Hub', () => {
  it('only triggers the callback once with once()', async () => {
    const { once, emit } = createEventHub();

    const fn = jest.fn();

    const args = [1, 2, 3];
    once('my-event', fn);

    await emit('my-event', ...args);
    await emit('my-event');
    await emit('my-event');

    expect(fn).toHaveBeenCalledTimes(1);
    expect(fn).toHaveBeenCalledWith(...args);
  });

  it('subscribes and unsubscribes to all events', async () => {
    const { subscribe, unsubscribe, emit } = createEventHub();

    const fn = jest.fn();
    subscribe(fn);

    const args1 = [1, 2, 3];
    const args2 = [4, 5, 6];

    await emit('my-event', ...args1);
    await emit('my-event', ...args2);
    await emit('my-other-event');

    expect(fn).toHaveBeenCalled();
    expect(fn).toHaveBeenNthCalledWith(1, 'my-event', ...args1);
    expect(fn).toHaveBeenNthCalledWith(2, 'my-event', ...args2);
    expect(fn).toHaveBeenNthCalledWith(3, 'my-other-event');

    // Unsubscribes with unsubscribe()
    unsubscribe(fn);
    await emit('my-event');
    expect(fn).toHaveBeenCalledTimes(3);

    // Unsubscribes with the returned function
    const unsubscribe2 = subscribe(fn);
    await emit('my-event');
    expect(fn).toHaveBeenCalledTimes(4);
    unsubscribe2();
    await emit('my-event');
    expect(fn).toHaveBeenCalledTimes(4);

    // Avoid removing the wrong subscriber when unsubscribe is given a non-existing subscriber
    const unsubscribe3 = subscribe(fn);
    const unrelatedFunction = jest.fn();
    unsubscribe(unrelatedFunction);
    await emit('my-event');
    expect(fn).toHaveBeenCalledTimes(5);
    unsubscribe3();
  });

  it('adds and removes simple listeners', async () => {
    const { on, off, emit } = createEventHub();

    const fn = jest.fn();
    const args = [1, 2, 3];

    // Listens to event with on()
    on('my-event', fn);
    await emit('my-event', ...args);
    expect(fn).toHaveBeenCalledWith(...args);

    // Removes listener with off()
    off('my-event', fn);
    await emit('my-event');
    expect(fn).toHaveBeenCalledTimes(1);

    // Removes listener with the returned function
    const off2 = on('my-event', fn);
    await emit('my-event', ...args);
    expect(fn).toHaveBeenCalledTimes(2);
    off2();
    await emit('my-event');
    expect(fn).toHaveBeenCalledTimes(2);
  });

  it('removes all subscribers on destroy()', async () => {
    const eventHub = createEventHub();

    const fn = jest.fn();
    const fn2 = jest.fn();
    eventHub.subscribe(fn);
    eventHub.on('my-event', fn2);

    await eventHub.emit('my-event');
    expect(fn).toHaveBeenCalled();
    expect(fn2).toHaveBeenCalled();

    eventHub.destroy();

    // Subscribers are removed
    await eventHub.emit('my-event');
    expect(fn).toHaveBeenCalledTimes(1);
    expect(fn2).toHaveBeenCalledTimes(1);
  });

  it('removes all subscribers on removeAllSubscribers()', async () => {
    const eventHub = createEventHub();

    const fn = jest.fn();
    eventHub.subscribe(fn);

    await eventHub.emit('my-event');
    expect(fn).toHaveBeenCalled();

    eventHub.removeAllSubscribers();

    // Subscribers are removed
    await eventHub.emit('my-event');
    expect(fn).toHaveBeenCalledTimes(1);
  });
});
</file>

<file path="src/services/__tests__/fs.test.ts">
import path from 'path';
import fse from 'fs-extra';
import fs from '../fs';

jest.mock('fs-extra', () => ({
  ensureFile: jest.fn(() => Promise.resolve()),
  writeFile: jest.fn(() => Promise.resolve()),
}));

describe('Strapi fs utils', () => {
  const strapi = {
    dirs: { dist: { root: '/tmp' }, app: { root: '/tmp' } },
  };

  test('Provides new functions', () => {
    const strapiFS = fs(strapi);

    expect(strapiFS.writeAppFile).toBeInstanceOf(Function);
    expect(strapiFS.writePluginFile).toBeInstanceOf(Function);
  });

  describe('Write App File', () => {
    test('Makes sure the path exists and writes', async () => {
      const strapiFS = fs(strapi);

      const content = '';

      await strapiFS.writeAppFile('test', content);

      expect(fse.ensureFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'));
      expect(fse.writeFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'), content);
    });

    test('Normalize the path to avoid relative access to folders in parent directories', async () => {
      const strapiFS = fs(strapi);

      const content = '';

      await strapiFS.writeAppFile('../../test', content);

      expect(fse.ensureFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'));
      expect(fse.writeFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test'), content);
    });

    test('Works with array path', async () => {
      const strapiFS = fs(strapi);

      const content = '';

      await strapiFS.writeAppFile(['test', 'sub', 'path'], content);

      expect(fse.ensureFile).toHaveBeenCalledWith(path.join('/', 'tmp', 'test', 'sub', 'path'));
      expect(fse.writeFile).toHaveBeenCalledWith(
        path.join('/', 'tmp', 'test', 'sub', 'path'),
        content
      );
    });
  });

  describe('Write Plugin File', () => {
    test('Scopes the writes in the extensions folder', async () => {
      const strapiFS = fs(strapi);

      const content = '';

      strapiFS.writeAppFile = jest.fn(() => Promise.resolve());

      await strapiFS.writePluginFile('users-permissions', ['test', 'sub', 'path'], content);

      expect(strapiFS.writeAppFile).toHaveBeenCalledWith(
        'extensions/users-permissions/test/sub/path',
        content
      );
    });
  });
});
</file>

<file path="src/services/__tests__/worker-queue.test.ts">
import WorkerQueue from '../worker-queue';

describe('WorkerQueue', () => {
  test('Executes worker', async () => {
    const fn = jest.fn();
    const input = 1;

    const q = new WorkerQueue({
      logger: console.log.bind(console),
      concurrency: 1,
    } as any);
    q.subscribe(fn);

    q.enqueue(input);

    await new Promise((resolve) => {
      setTimeout(resolve);
    });

    expect(fn).toHaveBeenCalledWith(input);
    expect(fn).toHaveBeenCalledTimes(1);
  });

  test('Executes worker', async () => {
    const fn = jest.fn();
    const input = 1;

    const q = new WorkerQueue({
      logger: console.log.bind(console),
      concurrency: 1,
    } as any);
    q.subscribe(fn);

    q.enqueue(input);
    q.enqueue(input);
    q.enqueue(input);

    await new Promise((resolve) => {
      setTimeout(resolve);
    });

    expect(fn).toHaveBeenCalledWith(input);
    expect(fn).toHaveBeenCalledTimes(3);
  });
});
</file>

<file path="src/services/auth/index.ts">
import assert from 'assert/strict';
import { has } from 'lodash/fp';

import { errors } from '@strapi/utils';
import type { Core } from '@strapi/types';
import type { ParameterizedContext } from 'koa';

interface AuthenticationResponse {
  authenticated?: boolean;
  credentials?: unknown;
  ability?: unknown;
  error?: Error | null;
}

interface AuthenticationInfo {
  strategy: Strategy;
  credentials: unknown;
  ability: unknown;
}

interface Strategy {
  name: string;
  authenticate: (ctx: ParameterizedContext) => Promise<AuthenticationResponse>;
  verify?: (auth: AuthenticationInfo, config: Core.RouteConfig['auth']) => Promise<any>;
}

interface Authentication {
  register: (type: string, strategy: Strategy) => Authentication;
  authenticate: Core.MiddlewareHandler;
  verify: (auth: AuthenticationInfo, config?: Core.RouteConfig['auth']) => Promise<any>;
}

const INVALID_STRATEGY_MSG =
  'Invalid auth strategy. Expecting an object with properties {name: string, authenticate: function, verify: function}';

const validStrategy = (strategy: Strategy) => {
  assert(has('authenticate', strategy), INVALID_STRATEGY_MSG);
  assert(typeof strategy.authenticate === 'function', INVALID_STRATEGY_MSG);

  if (has('verify', strategy)) {
    assert(typeof strategy.verify === 'function', INVALID_STRATEGY_MSG);
  }
};

const createAuthentication = (): Authentication => {
  const strategies: Record<string, Strategy[]> = {};

  return {
    register(type, strategy) {
      validStrategy(strategy);

      if (!strategies[type]) {
        strategies[type] = [];
      }

      strategies[type].push(strategy);

      return this;
    },

    async authenticate(ctx, next) {
      const route: Core.Route = ctx.state.route;

      // use route strategy
      const config = route?.config?.auth;

      if (config === false) {
        return next();
      }

      const routeStrategies = route.info.type ? strategies[route.info.type] : [];
      const configStrategies = (config?.strategies ?? routeStrategies ?? []) as Array<
        string | Strategy
      >;

      const strategiesToUse: Strategy[] = configStrategies.reduce(
        (acc, strategy: string | Strategy) => {
          // Resolve by strategy name
          if (typeof strategy === 'string') {
            const routeStrategy = routeStrategies.find((rs) => rs.name === strategy);

            if (routeStrategy) {
              acc.push(routeStrategy);
            }
          }

          // Use the given strategy as is
          else if (typeof strategy === 'object') {
            validStrategy(strategy);

            acc.push(strategy);
          }

          return acc;
        },
        [] as Strategy[]
      );

      for (const strategy of strategiesToUse) {
        const result = await strategy.authenticate(ctx);

        const { authenticated = false, credentials, ability = null, error = null } = result || {};

        if (error !== null) {
          return ctx.unauthorized(error);
        }

        if (authenticated) {
          ctx.state.isAuthenticated = true;
          ctx.state.auth = {
            strategy,
            credentials,
            ability,
          };

          return next();
        }
      }

      return ctx.unauthorized('Missing or invalid credentials');
    },

    async verify(auth, config = {}) {
      if (config === false) {
        return;
      }

      if (!auth) {
        throw new errors.UnauthorizedError();
      }

      if (typeof auth.strategy.verify === 'function') {
        return auth.strategy.verify(auth, config);
      }
    },
  };
};

export default createAuthentication;
</file>

<file path="src/services/content-api/permissions/providers/action.ts">
import { providerFactory } from '@strapi/utils';

export default (options = {}) => {
  const provider = providerFactory(options);

  return {
    ...provider,

    async register(action: string, payload: Record<string, unknown>) {
      if (strapi.isLoaded) {
        throw new Error(`You can't register new actions outside the bootstrap function.`);
      }

      return provider.register(action, payload);
    },
  };
};
</file>

<file path="src/services/content-api/permissions/providers/condition.ts">
import { providerFactory } from '@strapi/utils';

export interface Condition {
  name: string;
  [key: string]: unknown;
}

export default (options = {}) => {
  const provider = providerFactory(options);

  return {
    ...provider,

    async register(condition: Condition) {
      if (strapi.isLoaded) {
        throw new Error(`You can't register new conditions outside the bootstrap function.`);
      }

      return provider.register(condition.name, condition);
    },
  };
};
</file>

<file path="src/services/content-api/permissions/providers/index.ts">
export { default as createActionProvider } from './action';
export { default as createConditionProvider } from './condition';
</file>

<file path="src/services/content-api/permissions/engine.ts">
import permissions from '@strapi/permissions';

type Options = Parameters<typeof permissions.engine.new>[0];

export default ({ providers }: Options) => permissions.engine.new({ providers });
</file>

<file path="src/services/content-api/permissions/index.ts">
import _ from 'lodash';
import type { Core } from '@strapi/types';
import { createActionProvider, createConditionProvider } from './providers';
import createPermissionEngine from './engine';

const typeSymbol = Symbol.for('__type__');

interface ValidatePermissionHandler {
  (params: { permission: { action: string } }): boolean;
}

/**
 * Creates a handler that checks if the permission's action exists in the action registry
 */
const createValidatePermissionHandler =
  (actionProvider: ReturnType<typeof createActionProvider>): ValidatePermissionHandler =>
  ({ permission }) => {
    const action = actionProvider.get(permission.action);

    // If the action isn't registered into the action provider, then ignore the permission and warn the user
    if (!action) {
      strapi.log.debug(
        `Unknown action "${permission.action}" supplied when registering a new permission`
      );

      return false;
    }

    return true;
  };

/**
 * Create instances of providers and permission engine for the core content-API service.
 * Also, expose utilities to get information about available actions and such.
 */
export default (strapi: Core.Strapi) => {
  // NOTE: Here we define both an action and condition provider,
  // but at the moment, we're only using the action one.
  const providers = {
    action: createActionProvider(),
    condition: createConditionProvider(),
  };

  /**
   * Get a tree representation of the available Content API actions
   * based on the methods of the Content API controllers.
   *
   * @note Only actions bound to a content-API route are returned.
   */
  const getActionsMap = () => {
    const actionMap: Record<
      string,
      {
        controllers: Record<string, string[]>;
      }
    > = {};

    /**
     * Check if a controller's action is bound to the
     * content-api by looking at a potential __type__ symbol
     */
    const isContentApi = (action: Core.ControllerHandler & { [s: symbol]: any }) => {
      if (!_.has(action, typeSymbol)) {
        return false;
      }

      return action[typeSymbol].includes('content-api');
    };

    /**
     * Register actions from a specific API source into the result tree
     */
    const registerAPIsActions = (
      apis: Record<string, Core.Plugin | Core.Module>,
      source: 'api' | 'plugin'
    ) => {
      _.forEach(apis, (api, apiName) => {
        const controllers = _.reduce(
          api.controllers,
          (acc, controller, controllerName) => {
            const contentApiActions = _.pickBy(controller, isContentApi);

            if (_.isEmpty(contentApiActions)) {
              return acc;
            }

            acc[controllerName] = Object.keys(contentApiActions);

            return acc;
          },
          {} as Record<string, string[]>
        );

        if (!_.isEmpty(controllers)) {
          actionMap[`${source}::${apiName}`] = { controllers };
        }
      });
    };

    registerAPIsActions(strapi.apis, 'api');
    registerAPIsActions(strapi.plugins, 'plugin');

    return actionMap;
  };

  /**
   * Register all the content-API controllers actions into the action provider.
   * This method make use of the {@link getActionsMap} to generate the list of actions to register.
   */
  const registerActions = async () => {
    const actionsMap = getActionsMap();

    // For each API
    for (const [api, value] of Object.entries(actionsMap)) {
      const { controllers } = value;

      // Register controllers methods as actions
      for (const [controller, actions] of Object.entries(controllers)) {
        // Register each action individually
        await Promise.all(
          actions.map((action) => {
            const actionUID = `${api}.${controller}.${action}`;

            return providers.action.register(actionUID, {
              api,
              controller,
              action,
              uid: actionUID,
            });
          })
        );
      }
    }
  };

  // Create an instance of a content-API permission engine
  // and binds a custom validation handler to it
  const engine = createPermissionEngine({ providers });

  engine.on(
    'before-format::validate.permission',
    createValidatePermissionHandler(providers.action)
  );

  return {
    engine,
    providers,
    registerActions,
    getActionsMap,
  };
};
</file>

<file path="src/services/content-api/index.ts">
import _ from 'lodash';
import { sanitize, validate } from '@strapi/utils';

import type { Core, UID } from '@strapi/types';

import instantiatePermissionsUtilities from './permissions';

const transformRoutePrefixFor = (pluginName: string) => (route: Core.Route) => {
  const prefix = route.config && route.config.prefix;
  const path = prefix !== undefined ? `${prefix}${route.path}` : `/${pluginName}${route.path}`;

  return {
    ...route,
    path,
  };
};

const filterContentAPI = (route: Core.Route) => route.info.type === 'content-api';

/**
 * Create a content API container that holds logic, tools and utils. (eg: permissions, ...)
 */
const createContentAPI = (strapi: Core.Strapi) => {
  const getRoutesMap = async () => {
    const routesMap: Record<string, Core.Route[]> = {};

    _.forEach(strapi.apis, (api, apiName) => {
      const routes = _.flatMap(api.routes, (route) => {
        if ('routes' in route) {
          return route.routes;
        }

        return route;
      }).filter(filterContentAPI);

      if (routes.length === 0) {
        return;
      }

      const apiPrefix = strapi.config.get('api.rest.prefix');
      routesMap[`api::${apiName}`] = routes.map((route) => ({
        ...route,
        path: `${apiPrefix}${route.path}`,
      }));
    });

    _.forEach(strapi.plugins, (plugin, pluginName) => {
      const transformPrefix = transformRoutePrefixFor(pluginName);

      if (Array.isArray(plugin.routes)) {
        return plugin.routes.map(transformPrefix).filter(filterContentAPI);
      }

      const routes = _.flatMap(plugin.routes, (route) => route.routes.map(transformPrefix)).filter(
        filterContentAPI
      );

      if (routes.length === 0) {
        return;
      }

      const apiPrefix = strapi.config.get('api.rest.prefix');
      routesMap[`plugin::${pluginName}`] = routes.map((route) => ({
        ...route,
        path: `${apiPrefix}${route.path}`,
      }));
    });

    return routesMap;
  };

  const sanitizer = sanitize.createAPISanitizers({
    getModel(uid: string) {
      return strapi.getModel(uid as UID.Schema);
    },
    // NOTE: use lazy access to allow registration of sanitizers after the creation of the container
    get sanitizers() {
      return {
        input: strapi.sanitizers.get('content-api.input'),
        output: strapi.sanitizers.get('content-api.output'),
      };
    },
  });

  const validator = validate.createAPIValidators({
    getModel(uid: string) {
      return strapi.getModel(uid as UID.Schema);
    },
    // NOTE: use lazy access to allow registration of validators after the creation of the container
    get validators() {
      return {
        input: strapi.validators.get('content-api.input'),
      };
    },
  });

  return {
    permissions: instantiatePermissionsUtilities(strapi),
    getRoutesMap,
    sanitize: sanitizer,
    validate: validator,
  };
};

export default createContentAPI;
</file>

<file path="src/services/document-service/__tests__/middlewares.test.ts">
import { createMiddlewareManager } from '../middlewares/middleware-manager';

describe('middlewares', () => {
  describe('wrapObject', () => {
    const manager = createMiddlewareManager();

    it('should wrap object', async () => {
      const obj = {
        async test() {
          return 'test';
        },
      };

      const wrapped = manager.wrapObject(obj);

      expect(await wrapped.test()).toBe('test');
    });

    it('should wrap object with context', async () => {
      const manager = createMiddlewareManager();
      const overwrittenId = 'overwrittenId';
      const middlewareFn = jest.fn(async (ctx: any, next: any) => {
        ctx.params.id = overwrittenId;
        return next();
      });

      manager.use(middlewareFn);

      const obj = {
        test({ id }: { id: number }) {
          return id;
        },
      };

      const wrapped = manager.wrapObject(obj, {
        defaultLocale: 'en',
      });

      expect(await wrapped.test({ id: 1 })).toBe(overwrittenId);
      expect(middlewareFn).toHaveBeenCalled();
    });
  });
});
</file>

<file path="src/services/document-service/attributes/index.ts">
import { curry } from 'lodash/fp';

import type { UID, Modules, Schema } from '@strapi/types';

import transforms from './transforms';

// aliasing the type to make it easier to read
type Data = Modules.Documents.Params.Data.Input<UID.Schema>;

const applyTransforms = curry((schema: Schema.Schema, data: Data) => {
  const attributeNames = Object.keys(data) as Array<keyof typeof data & string>;

  for (const attributeName of attributeNames) {
    const value = data[attributeName];

    const attribute = schema.attributes[attributeName];

    if (!attribute) {
      continue;
    }

    const transform = transforms[attribute.type];

    if (transform) {
      const attributeContext = { attributeName, attribute };

      data[attributeName] = transform(value, attributeContext);
    }
  }

  return data;
});

export { applyTransforms };
</file>

<file path="src/services/document-service/attributes/transforms.ts">
import { getOr, toNumber, isString } from 'lodash/fp';
import type { Schema } from '@strapi/types';
import bcrypt from 'bcryptjs';

type Transforms = {
  [TKind in Schema.Attribute.Kind]?: (
    value: unknown,
    context: {
      attribute: Schema.Attribute.AnyAttribute;
      attributeName: string;
    }
  ) => any;
};

const transforms: Transforms = {
  password(value, context) {
    const { attribute } = context;

    if (attribute.type !== 'password') {
      throw new Error('Invalid attribute type');
    }

    if (!isString(value) && !(value instanceof Buffer)) {
      return value;
    }

    const rounds = toNumber(getOr(10, 'encryption.rounds', attribute));

    return bcrypt.hashSync(value.toString(), rounds);
  },
};

export default transforms;
</file>

<file path="src/services/document-service/middlewares/errors.ts">
import { errors as databaseErrors } from '@strapi/database';
import { errors } from '@strapi/utils';

import type { Middleware } from './middleware-manager';

const databaseErrorsToTransform = [
  databaseErrors.InvalidTimeError,
  databaseErrors.InvalidDateTimeError,
  databaseErrors.InvalidDateError,
  databaseErrors.InvalidRelationError,
];

/**
 * Handle database errors
 */
export const databaseErrorsMiddleware: Middleware = async (ctx, next) => {
  try {
    return await next();
  } catch (error) {
    if (databaseErrorsToTransform.some((errorToTransform) => error instanceof errorToTransform)) {
      if (error instanceof Error) {
        throw new errors.ValidationError(error.message);
      }

      throw error;
    }
    throw error;
  }
};
</file>

<file path="src/services/document-service/middlewares/index.ts">
export { databaseErrorsMiddleware } from './errors';
export { createMiddlewareManager } from './middleware-manager';
</file>

<file path="src/services/document-service/middlewares/middleware-manager.ts">
export type Middleware = (ctx: any, next: () => Promise<void>) => Promise<void> | void;

export type Options = {
  exclude?: string[];
};

export const createMiddlewareManager = () => {
  const middlewares: Middleware[] = [];

  const manager = {
    use(middleware: Middleware) {
      middlewares.push(middleware);

      return () => middlewares.splice(middlewares.indexOf(middleware), 1);
    },

    async run(ctx: any, cb: () => void) {
      let index = 0;
      const next = async () => {
        if (index < middlewares.length) {
          // eslint-disable-next-line no-plusplus
          return middlewares[index++](ctx, next);
        }

        return cb();
      };

      return next();
    },

    wrapObject<TSource>(source: TSource, ctxDefaults = {}, opts: Options = {}): TSource {
      const facade: TSource = {} as TSource;
      const { exclude = [] } = opts;

      for (const key in source) {
        if (Object.hasOwnProperty.call(source, key)) {
          const prop = source[key];

          if (exclude.includes(key)) {
            facade[key] = prop;
          } else if (typeof prop === 'function') {
            const newMethod = async (params: any = {}) => {
              const ctx = {
                ...ctxDefaults,
                action: key,
                params,
              };

              return manager.run(ctx, () => prop(ctx.params));
            };

            facade[key] = newMethod as typeof prop;
          } else {
            facade[key] = prop;
          }
        }
      }

      return facade;
    },
  };

  return manager;
};
</file>

<file path="src/services/document-service/transform/__tests__/fields.test.ts">
import { transformFields } from '../fields';

describe('transformFields', () => {
  it('should add documentId if it is not present in the fields', () => {
    const input = [] as string[];
    const expected = ['documentId'];
    expect(transformFields(input)).toEqual(expected);
  });

  it('should keep rest of fields', () => {
    const input = ['id', 'name'];
    const expected = ['id', 'name', 'documentId'];
    expect(transformFields(input)).toEqual(expected);
  });

  it('should add documentId if it is not present in the fields', () => {
    const input = ['name', 'description'];
    const expected = ['name', 'description', 'documentId'];
    expect(transformFields(input)).toEqual(expected);
  });

  it('should handle empty field arrays', () => {
    const input: string[] = [];
    expect(transformFields(input)).toEqual(input);
  });

  describe('string fields', () => {
    it('should handle * fields', () => {
      const input = '*';
      expect(transformFields(input)).toEqual(input);
    });

    it('should include document id', () => {
      const input = 'name,description';
      const expected = 'name,description,documentId';
      expect(transformFields(input)).toEqual(expected);

      const input2 = '';
      const expected2 = 'documentId';
      expect(transformFields(input2)).toEqual(expected2);
    });

    it('should not include documentId if it is already present', () => {
      const input = 'name,description,documentId';
      expect(transformFields(input)).toEqual(input);

      const input2 = 'documentId';
      expect(transformFields(input2)).toEqual(input2);
    });
  });
});
</file>

<file path="src/services/document-service/transform/__tests__/id-map.test.ts">
import type { Core } from '@strapi/types';
import { createIdMap } from '../id-map';

const ARTICLE_UID = 'api::article.article';
const CATEGORY_UID = 'api::category.category';

const expectedQuery = (documentId: string, locale: string, status = 'draft') => ({
  select: ['id', 'documentId', 'locale', 'publishedAt'],
  where: {
    documentId: { $in: [documentId] },
    locale,
    publishedAt: status === 'draft' ? null : { $ne: null },
  },
});

describe('Extract document ids from relation data', () => {
  const findArticles = jest.fn(() => ({}));
  const findCategories = jest.fn(() => ({}));

  const findManyQueries = {
    [ARTICLE_UID]: findArticles,
    [CATEGORY_UID]: findCategories,
  } as Record<string, jest.Mock>;

  beforeAll(() => {
    global.strapi = {
      db: {
        query: jest.fn((uid) => ({ findMany: findManyQueries[uid] })),
      },
      getModel: () => ({
        options: { draftAndPublish: true },
      }),
    } as unknown as Core.Strapi;
  });

  it('Load single document id', async () => {
    const idMap = createIdMap({ strapi: global.strapi });

    const documentId = 'Article1';
    const locale = 'en';
    const status = 'published';

    findArticles.mockReturnValueOnce([{ id: 1, documentId, locale, publishedAt: '27-11-2024' }]);

    // Add 1 document to load
    idMap.add({ uid: ARTICLE_UID, documentId, locale, status });
    await idMap.load();

    // Check that the id is loaded
    expect(idMap.get({ uid: ARTICLE_UID, documentId, locale, status })).toEqual(1);
    expect(findArticles).toHaveBeenCalledWith(expectedQuery(documentId, locale, status));
  });

  it('Load with no locale', async () => {
    const idMap = createIdMap({ strapi: global.strapi });

    const documentId = 'Article1';
    const keyFields = { uid: ARTICLE_UID, documentId, status: 'draft', locale: null } as const;
    findArticles.mockReturnValueOnce([{ id: 1, documentId, locale: null, publishedAt: undefined }]);

    // Add 1 document to load
    idMap.add(keyFields);
    await idMap.load();

    // Check that the id is loaded
    expect(idMap.get(keyFields)).toEqual(1);
  });

  it('Load multiple document ids from different UIDs', async () => {
    const idMap = createIdMap({ strapi: global.strapi });

    const articleDocumentId = 'Article1';
    const categoryDocumentId = 'Category1';
    const locale = 'en';
    const status = 'draft';

    findArticles.mockReturnValueOnce([
      { id: 1, documentId: articleDocumentId, locale, publishedAt: '27-11-2024' },
    ]);
    findCategories.mockReturnValueOnce([
      { id: 2, documentId: categoryDocumentId, locale, publishedAt: '27-11-2024' },
    ]);

    // Add 2 documents to load
    idMap.add({ uid: ARTICLE_UID, documentId: articleDocumentId, locale, status });
    idMap.add({ uid: CATEGORY_UID, documentId: categoryDocumentId, locale, status });
    // Should load articles and categories separately
    await idMap.load();

    // Check that the ids are loaded
    expect(idMap.get({ uid: ARTICLE_UID, documentId: articleDocumentId, locale })).toEqual(1);
    expect(idMap.get({ uid: CATEGORY_UID, documentId: categoryDocumentId, locale })).toEqual(2);

    expect(findArticles).toHaveBeenCalledWith(expectedQuery(articleDocumentId, locale));
    expect(findCategories).toHaveBeenCalledWith(expectedQuery(categoryDocumentId, locale));
  });

  it('Load different locales of the same document id', async () => {
    const idMap = createIdMap({ strapi: global.strapi });

    const documentId = 'Article1';
    const enLocale = 'en';
    const frLocale = 'fr';
    const status = 'draft';

    findArticles
      .mockReturnValueOnce([{ id: 1, documentId, locale: enLocale, publishedAt: null }])
      .mockReturnValueOnce([{ id: 2, documentId, locale: frLocale, publishedAt: null }]);

    // Add 2 documents to load
    idMap.add({ uid: ARTICLE_UID, documentId, locale: enLocale, status });
    idMap.add({ uid: ARTICLE_UID, documentId, locale: frLocale, status });
    await idMap.load();

    // Check that the ids are loaded
    expect(idMap.get({ uid: ARTICLE_UID, documentId, locale: enLocale, status })).toEqual(1);
    expect(idMap.get({ uid: ARTICLE_UID, documentId, locale: frLocale, status })).toEqual(2);

    expect(findArticles).toHaveBeenCalledWith(expectedQuery(documentId, enLocale, status));
    expect(findArticles).toHaveBeenCalledWith(expectedQuery(documentId, frLocale, status));
  });
});
</file>

<file path="src/services/document-service/transform/__tests__/id-transform-i18n.test.ts">
import { PRODUCT_UID, CATEGORY_UID, models } from './utils';
import { transformParamsDocumentId } from '../id-transform';

const findProducts = jest.fn(() => ({}));
const findCategories = jest.fn(() => ({}));

const findManyQueries = {
  [PRODUCT_UID]: findProducts,
  [CATEGORY_UID]: findCategories,
} as Record<string, jest.Mock>;

// TODO: Relation between published documents
describe('Transform relational data', () => {
  global.strapi = {
    getModel: (uid: string) => models[uid],
    plugins: {
      i18n: {
        services: {
          'content-types': {
            isLocalizedContentType(model: any) {
              // Localize category content type
              if (model.uid === CATEGORY_UID) {
                return true;
              }
              // Shop is not localized
              return false;
            },
          },
          locales: {
            getDefaultLocale() {
              return 'en';
            },
          },
        },
      },
    },
    db: {
      query: jest.fn((uid) => ({ findMany: findManyQueries[uid] })),
    },
  } as any;

  beforeEach(() => {
    findCategories.mockReturnValue([
      { id: 'category-1-en-draft', documentId: 'category-1', locale: 'en', publishedAt: null },
      { id: 'category-1-fr-draft', documentId: 'category-1', locale: 'fr', publishedAt: null },
      { id: 'category-2-en-draft', documentId: 'category-2', locale: 'en', publishedAt: null },
      { id: 'category-3-en-draft', documentId: 'category-3', locale: 'en', publishedAt: null },
      { id: 'category-4-en-draft', documentId: 'category-4', locale: 'en', publishedAt: null },
      { id: 'category-5-en-draft', documentId: 'category-5', locale: 'en', publishedAt: null },
      { id: 'category-6-en-draft', documentId: 'category-6', locale: 'en', publishedAt: null },
      { id: 'category-7-en-draft', documentId: 'category-7', locale: 'en', publishedAt: null },
      { id: 'category-8-en-draft', documentId: 'category-8', locale: 'en', publishedAt: null },
      { id: 'category-9-en-draft', documentId: 'category-9', locale: 'en', publishedAt: null },
      { id: 'category-10-en-draft', documentId: 'category-10', locale: 'en', publishedAt: null },
    ]);

    findProducts.mockReturnValue([
      { id: 'product-1-draft', documentId: 'product-1', locale: null, publishedAt: null },
      { id: 'product-1-published', documentId: 'product-1', locale: null, publishedAt: new Date() },
      { id: 'product-2-draft', documentId: 'product-2', locale: null, publishedAt: null },
      { id: 'product-3-draft', documentId: 'product-3', locale: null, publishedAt: null },
    ]);
  });

  describe('Non I18n (products) -> I18n (categories)', () => {
    it('Connect to locales of the same category document', async () => {
      const { data } = await transformParamsDocumentId(PRODUCT_UID, {
        data: {
          name: 'test',
          categories: [
            { documentId: 'category-1', locale: 'en' },
            { documentId: 'category-1', locale: 'fr' },
            { documentId: 'category-2', locale: 'en' },
          ],
          category: { documentId: 'category-4', locale: 'en' },
          relatedProducts: [{ documentId: 'product-1' }, { documentId: 'product-2', locale: null }],
        },
        locale: 'en',
        status: 'draft',
      });

      expect(data).toMatchObject({
        name: 'test',
        categories: {
          set: [
            { id: 'category-1-en-draft' },
            { id: 'category-1-fr-draft' },
            { id: 'category-2-en-draft' },
          ],
        },
        category: { set: [{ id: 'category-4-en-draft' }] },
        relatedProducts: { set: [{ id: 'product-1-draft' }, { id: 'product-2-draft' }] },
      });
    });

    it('Connect to the default locale if not provided', async () => {
      // Should connect to the default locale if not provided in the relation
      const { data } = await transformParamsDocumentId(PRODUCT_UID, {
        data: {
          name: 'test',
          categories: [{ documentId: 'category-1' }],
        },
        status: 'draft',
      });

      expect(data).toMatchObject({
        name: 'test',
        categories: { set: [{ id: 'category-1-en-draft' }] },
      });
    });

    it('Connect and reorder', async () => {
      // Should connect and reorder the relations,
      const { data } = await transformParamsDocumentId(PRODUCT_UID, {
        data: {
          name: 'test',
          categories: {
            connect: [
              {
                documentId: 'category-1',
                locale: 'fr',
                position: { before: 'category-2', locale: 'en' },
              },
              {
                documentId: 'category-2',
                locale: 'en',
                position: { after: 'category-1', locale: 'fr' },
              },
            ],
          },
        },
        status: 'draft',
      });

      expect(data).toMatchObject({
        name: 'test',
        categories: {
          connect: [
            { id: 'category-1-fr-draft', position: { before: 'category-2-en-draft' } },
            { id: 'category-2-en-draft', position: { after: 'category-1-fr-draft' } },
          ],
        },
      });
    });
  });

  describe('I18n (categories) -> Non I18n (products)', () => {
    it('Ignore locale when connecting to non localized content type', async () => {
      // Should ignore the locale when connecting to non localized content type
      const { data } = await transformParamsDocumentId(CATEGORY_UID, {
        data: {
          products: [{ documentId: 'product-1' }, { documentId: 'product-2', locale: 'en' }],
        },
        locale: 'en',
        status: 'draft',
      });

      expect(data).toMatchObject({
        products: { set: [{ id: 'product-1-draft' }, { id: 'product-2-draft' }] },
      });
    });
  });

  describe('I18n (categories) -> I18n (categories)', () => {
    it('Connect to source locale if not provided', async () => {
      // Should connect to the source locale if not provided in the relation
      const { data } = await transformParamsDocumentId(CATEGORY_UID, {
        data: {
          relatedCategories: [{ documentId: 'category-1' }],
        },
        locale: 'fr',
        status: 'draft',
      });

      expect(data).toMatchObject({
        relatedCategories: { set: [{ id: 'category-1-fr-draft' }] },
      });
    });

    it("Connect to source locale if the locale of the relation doesn't match", async () => {
      // Should not be able to connect to different locales than the current one
      const { data } = await transformParamsDocumentId(CATEGORY_UID, {
        data: {
          // Connect to another locale than the current one
          relatedCategories: [{ documentId: 'category-1', locale: 'fr' }],
        },
        locale: 'en',
        status: 'draft',
      });

      expect(data).toMatchObject({
        relatedCategories: {
          set: [{ id: 'category-1-en-draft' }],
        },
      });
    });
  });
});
</file>

<file path="src/services/document-service/transform/__tests__/id-transform-no-dp.test.ts">
import { PRODUCT_UID, SHOP_UID, models } from './utils';
import { transformParamsDocumentId } from '../id-transform';

const findProducts = jest.fn(() => ({}));
const findShops = jest.fn(() => ({}));

const findManyQueries = {
  [PRODUCT_UID]: findProducts,
  [SHOP_UID]: findShops,
} as Record<string, jest.Mock>;

describe('Transform relational data', () => {
  global.strapi = {
    getModel: (uid: string) => models[uid],
    plugins: {
      i18n: {
        services: {
          'content-types': {
            isLocalizedContentType() {
              return true;
            },
          },
          locales: {
            getDefaultLocale() {
              return 'en';
            },
          },
        },
      },
    },
    db: {
      query: jest.fn((uid) => ({ findMany: findManyQueries[uid] })),
    },
  } as any;

  beforeEach(() => {
    findShops.mockReturnValue([
      { id: 'shop-1-en', documentId: 'shop-1', locale: 'en' },
      { id: 'shop-1-fr', documentId: 'shop-1', locale: 'fr' },
      { id: 'shop-2-en', documentId: 'shop-2', locale: 'en' },
      { id: 'shop-3-en', documentId: 'shop-3', locale: 'en' },
      { id: 'shop-4-en', documentId: 'shop-4', locale: 'en' },
      { id: 'shop-5-en', documentId: 'shop-5', locale: 'en' },
      { id: 'shop-6-en', documentId: 'shop-6', locale: 'en' },
      { id: 'shop-7-en', documentId: 'shop-7', locale: 'en' },
      { id: 'shop-8-en', documentId: 'shop-8', locale: 'en' },
      { id: 'shop-9-en', documentId: 'shop-9', locale: 'en' },
      { id: 'shop-10-en', documentId: 'shop-10', locale: 'en' },
    ]);

    findProducts.mockReturnValue([
      { id: 'product-1-en-draft', documentId: 'product-1', locale: 'en', publishedAt: null },
      {
        id: 'product-1-en-published',
        documentId: 'product-1',
        locale: 'en',
        publishedAt: new Date(),
      },
      { id: 'product-2-en-draft', documentId: 'product-2', locale: 'en', publishedAt: null },
      { id: 'product-3-en-draft', documentId: 'product-3', locale: 'en', publishedAt: null },
    ]);
  });

  describe('Non DP (shop) -> DP (product)', () => {
    it('Connect to multiple status of products', async () => {
      const { data } = await transformParamsDocumentId(SHOP_UID, {
        data: {
          name: 'test',
          products: [
            { documentId: 'product-1', locale: 'en', status: 'published' },
            { documentId: 'product-2', locale: 'en', status: 'draft' },
          ],
          product: { documentId: 'product-1', locale: 'en', status: 'draft' },
        },
        locale: 'en',
        status: 'draft',
      });

      expect(data).toMatchObject({
        name: 'test',
        products: { set: [{ id: 'product-1-en-published' }, { id: 'product-2-en-draft' }] },
        product: { set: [{ id: 'product-1-en-draft' }] },
      });
    });

    it('Connect to to both draft and publish by default', async () => {
      // Should connect to the default locale if not provided in the relation
      const { data } = await transformParamsDocumentId(SHOP_UID, {
        data: {
          name: 'test',
          products: [
            { documentId: 'product-1', locale: 'en' },
            { documentId: 'product-2', locale: 'en' },
          ],
          product: { documentId: 'product-1', locale: 'en' },
        },
        // Should connect to draft versions of the products
        locale: 'en',
        status: 'draft',
      });

      // Transform relations to connect to the draft and published versions of the products
      // If published version is not available, it should connect to the draft version
      expect(data).toMatchObject({
        name: 'test',
        products: {
          set: [
            { id: 'product-1-en-draft' },
            { id: 'product-1-en-published' },
            { id: 'product-2-en-draft' },
          ],
        },
        product: { set: [{ id: 'product-1-en-draft' }, { id: 'product-1-en-published' }] },
      });
    });

    it('Connect and reorder', async () => {
      // Should connect and reorder the relations,
      const { data } = await transformParamsDocumentId(SHOP_UID, {
        data: {
          name: 'test',
          products: {
            connect: [
              {
                documentId: 'product-1',
                locale: 'en',
                position: { before: 'product-2', locale: 'en' }, // Should expect draft by default
              },
            ],
          },
          product: {
            connect: {
              documentId: 'product-1',
              locale: 'en',
              position: { before: 'product-2', locale: 'en' }, // Should expect draft by default
            },
          },
        },
        status: 'draft',
        locale: 'en',
      });

      expect(data).toMatchObject({
        name: 'test',
        products: {
          connect: [
            { id: 'product-1-en-draft', position: { before: 'product-2-en-draft' } },
            { id: 'product-1-en-published', position: { before: 'product-2-en-draft' } },
          ],
        },
        product: {
          connect: [
            { id: 'product-1-en-draft', position: { before: 'product-2-en-draft' } },
            { id: 'product-1-en-published', position: { before: 'product-2-en-draft' } },
          ],
        },
      });
    });
  });
});
</file>

<file path="src/services/document-service/transform/__tests__/id-transform.test.ts">
import type { Core } from '@strapi/types';

import { PRODUCT_UID, CATEGORY_UID, models } from './utils';
import { transformParamsDocumentId } from '../id-transform';

const findProducts = jest.fn(() => ({}));
const findCategories = jest.fn(() => ({}));

const findManyQueries = {
  [PRODUCT_UID]: findProducts,
  [CATEGORY_UID]: findCategories,
} as Record<string, jest.Mock>;

describe('Transform relational data', () => {
  global.strapi = {
    getModel: (uid: string) => models[uid],
    plugins: {
      i18n: {
        services: {
          'content-types': {
            isLocalizedContentType() {
              return true;
            },
          },
          locales: {
            getDefaultLocale() {
              return 'en';
            },
          },
        },
      },
    },
    db: {
      query: jest.fn((uid) => ({ findMany: findManyQueries[uid] })),
    },
  } as unknown as Core.Strapi;

  beforeEach(() => {
    findCategories.mockReturnValue([
      { id: 'doc1-en-draft', documentId: 'doc1', locale: 'en', publishedAt: null },
      { id: 'doc1-fr-draft', documentId: 'doc1', locale: 'fr', publishedAt: null },
      { id: 'doc2-en-draft', documentId: 'doc2', locale: 'en', publishedAt: null },
      { id: 'doc3-en-draft', documentId: 'doc3', locale: 'en', publishedAt: null },
      { id: 'doc4-en-draft', documentId: 'doc4', locale: 'en', publishedAt: null },
      { id: 'doc5-en-draft', documentId: 'doc5', locale: 'en', publishedAt: null },
      { id: 'doc6-en-draft', documentId: 'doc6', locale: 'en', publishedAt: null },
      { id: 'doc7-en-draft', documentId: 'doc7', locale: 'en', publishedAt: null },
      { id: 'doc8-en-draft', documentId: 'doc8', locale: 'en', publishedAt: null },
      { id: 'doc9-en-draft', documentId: 'doc9', locale: 'en', publishedAt: null },
      { id: 'doc10-en-draft', documentId: 'doc10', locale: 'en', publishedAt: null },
    ]);

    findProducts.mockReturnValue([
      { id: 'doc1-en-draft', documentId: 'doc1', locale: 'en', publishedAt: null },
      { id: 'doc1-fr-draft', documentId: 'doc1', locale: 'fr', publishedAt: null },
      { id: 'doc2-en-draft', documentId: 'doc2', locale: 'en', publishedAt: null },
      { id: 'doc3-en-draft', documentId: 'doc3', locale: 'en', publishedAt: null },
    ]);
  });

  describe('Shorthand syntax', () => {
    it('Shorthand syntax', async () => {
      const { data } = await transformParamsDocumentId(PRODUCT_UID, {
        data: {
          name: 'test',
          categories: ['doc1', 'doc2', 'doc3'],
          category: 'doc4',
          relatedProducts: ['doc1', 'doc2', 'doc3'],
        },
        locale: 'en',
        status: 'draft',
      });

      expect(data).toEqual({
        name: 'test',
        categories: {
          set: [{ id: 'doc1-en-draft' }, { id: 'doc2-en-draft' }, { id: 'doc3-en-draft' }],
        },
        category: { set: [{ id: 'doc4-en-draft' }] },
        relatedProducts: {
          set: [{ id: 'doc1-en-draft' }, { id: 'doc2-en-draft' }, { id: 'doc3-en-draft' }],
        },
      });
    });

    it('Should ignore number values', async () => {
      const { data } = await transformParamsDocumentId(PRODUCT_UID, {
        data: {
          name: 'test',
          categories: [1, 2, 'doc1'],
          category: 4,
        },
        locale: 'en',
        status: 'draft',
      });

      expect(data).toEqual({
        name: 'test',
        categories: {
          set: [{ id: 1 }, { id: 2 }, { id: 'doc1-en-draft' }],
        },
        category: { set: [{ id: 4 }] },
      });
    });

    it('Handles nullish values', async () => {
      const { data } = await transformParamsDocumentId(PRODUCT_UID, {
        data: {
          name: 'test',
          categories: undefined,
          category: null,
        },
        locale: 'en',
        status: 'draft',
      });

      expect(data).toEqual({
        name: 'test',
        categories: undefined,
        category: null,
      });
    });
  });

  describe('Longhand syntax', () => {
    it('Longhand syntax', async () => {
      const { data } = await transformParamsDocumentId(PRODUCT_UID, {
        data: {
          name: 'test',
          categories: [{ documentId: 'doc1' }, { documentId: 'doc2' }, { documentId: 'doc3' }],
          category: { documentId: 'doc4' },
        },
        locale: 'en',
        status: 'draft',
      });

      expect(data).toMatchObject({
        name: 'test',
        categories: {
          set: [{ id: 'doc1-en-draft' }, { id: 'doc2-en-draft' }, { id: 'doc3-en-draft' }],
        },
        category: { set: [{ id: 'doc4-en-draft' }] },
      });
    });

    it('Longhand syntax with id', async () => {
      const { data } = await transformParamsDocumentId(PRODUCT_UID, {
        data: {
          name: 'test',
          categories: [{ id: 1 }],
          category: { id: 2 },
        },
        locale: 'en',
        status: 'draft',
      });

      expect(data).toMatchObject({
        name: 'test',
        categories: { set: [{ id: 1 }] },
        category: { set: [{ id: 2 }] },
      });
    });

    it('Document id takes priority over id', async () => {
      const { data } = await transformParamsDocumentId(PRODUCT_UID, {
        data: {
          name: 'test',
          categories: [{ id: 1, documentId: 'doc2' }],
          category: { id: 2, documentId: 'doc4' },
        },
        locale: 'en',
        status: 'draft',
      });

      expect(data).toMatchObject({
        name: 'test',
        categories: { set: [{ id: 'doc2-en-draft' }] },
        category: { set: [{ id: 'doc4-en-draft' }] },
      });
    });
  });

  it('Set', async () => {
    const { data } = await transformParamsDocumentId(PRODUCT_UID, {
      data: {
        name: 'test',
        categories: { set: ['doc1', 'doc2', 'doc3'] },
        category: { set: 'doc4' },
      },
      locale: 'en',
      status: 'draft',
    });

    expect(data).toEqual({
      name: 'test',
      categories: {
        set: [{ id: 'doc1-en-draft' }, { id: 'doc2-en-draft' }, { id: 'doc3-en-draft' }],
      },
      category: { set: [{ id: 'doc4-en-draft' }] },
    });
  });

  it('Connect', async () => {
    const { data } = await transformParamsDocumentId(PRODUCT_UID, {
      data: {
        name: 'test',
        categories: { connect: ['doc1', 'doc2', 'doc3'] },
        category: { connect: 'doc4' },
      },
      locale: 'en',
      status: 'draft',
    });

    expect(data).toEqual({
      name: 'test',
      categories: {
        connect: [{ id: 'doc1-en-draft' }, { id: 'doc2-en-draft' }, { id: 'doc3-en-draft' }],
      },
      category: { connect: [{ id: 'doc4-en-draft' }] },
    });
  });

  it('Connect before', async () => {
    const { data } = await transformParamsDocumentId(PRODUCT_UID, {
      data: {
        name: 'test',
        categories: { connect: [{ documentId: 'doc1', position: { before: 'doc2' } }] },
        category: { connect: 'doc4' },
      },
      locale: 'en',
      status: 'draft',
    });

    expect(data).toMatchObject({
      name: 'test',
      categories: { connect: [{ id: 'doc1-en-draft', position: { before: 'doc2-en-draft' } }] },
      category: { connect: [{ id: 'doc4-en-draft' }] },
    });
  });

  it('Connect after', async () => {
    const { data } = await transformParamsDocumentId(PRODUCT_UID, {
      data: {
        name: 'test',
        categories: { connect: [{ documentId: 'doc1', position: { after: 'doc2' } }] },
        category: { connect: 'doc4' },
      },
      locale: 'en',
      status: 'draft',
    });

    expect(data).toMatchObject({
      name: 'test',
      categories: { connect: [{ id: 'doc1-en-draft', position: { after: 'doc2-en-draft' } }] },
      category: { connect: [{ id: 'doc4-en-draft' }] },
    });
  });

  it('Disconnect', async () => {
    const { data } = await transformParamsDocumentId(PRODUCT_UID, {
      data: {
        name: 'test',
        categories: { disconnect: ['doc1', 'doc2', 'doc3'] },
        category: { disconnect: 'doc4' },
      },
      locale: 'en',
      status: 'draft',
    });

    expect(data).toMatchObject({
      name: 'test',
      categories: {
        disconnect: [{ id: 'doc1-en-draft' }, { id: 'doc2-en-draft' }, { id: 'doc3-en-draft' }],
      },
      category: { disconnect: [{ id: 'doc4-en-draft' }] },
    });
  });

  it('Multiple', async () => {
    const { data } = await transformParamsDocumentId(PRODUCT_UID, {
      data: {
        name: 'test',
        categories: {
          set: ['doc1', 'doc2', 'doc3'],
          connect: ['doc4', 'doc5'],
          disconnect: ['doc6', 'doc7'],
        },
        category: {
          set: 'doc8',
          connect: 'doc9',
          disconnect: 'doc10',
        },
      },
      locale: 'en',
      status: 'draft',
    });

    expect(data).toMatchObject({
      name: 'test',
      categories: {
        set: [{ id: 'doc1-en-draft' }, { id: 'doc2-en-draft' }, { id: 'doc3-en-draft' }],
        connect: [{ id: 'doc4-en-draft' }, { id: 'doc5-en-draft' }],
        disconnect: [{ id: 'doc6-en-draft' }, { id: 'doc7-en-draft' }],
      },
      category: {
        set: [{ id: 'doc8-en-draft' }],
        connect: [{ id: 'doc9-en-draft' }],
        disconnect: [{ id: 'doc10-en-draft' }],
      },
    });
  });
});
</file>

<file path="src/services/document-service/transform/__tests__/map-relation.test.ts">
import { mapRelation } from '../relations/utils/map-relation';

const mapper = mapRelation(async (relation) => {
  if (!relation) return 'default';

  if (relation.id) {
    return { ...relation, id: 'mapped' };
  }

  if (relation.documentId) {
    return { ...relation, documentId: 'mapped' };
  }

  return 'error';
});

describe('map relation', () => {
  describe('long hand', () => {
    it('long hand', async () => {
      const relation = { id: 1 };
      const expectedRelation = { set: [{ id: 'mapped' }] };
      expect(await mapper(relation)).toMatchObject(expectedRelation);

      const relationDocId = { documentId: 1 };
      const expectedRelationDocId = { set: [{ documentId: 'mapped' }] };
      expect(await mapper(relationDocId)).toMatchObject(expectedRelationDocId);
    });

    describe('connect', () => {
      it('regular connect', async () => {
        const relation = { connect: { id: 1 } };
        const expectedRelation = { connect: [{ id: 'mapped' }] };
        expect(await mapper(relation)).toMatchObject(expectedRelation);

        // It keeps the other attributes
        const relationDocId = { connect: { documentId: 1, locale: 'en' } };
        const expectedRelationDocId = { connect: [{ documentId: 'mapped' }] };
        expect(await mapper(relationDocId)).toMatchObject(expectedRelationDocId);
      });

      it('connect  array', async () => {
        const relation = {
          connect: [{ id: 1 }],
        };

        const expectedRelation = {
          connect: [{ id: 'mapped' }],
        };

        expect(await mapper(relation)).toMatchObject(expectedRelation);
      });

      it('connect map to multiple', async () => {
        const relation = {
          connect: [{ id: 1 }, { id: 1 }],
        };
        const expectedRelation = {
          connect: [{ id: 'mapped1' }, { id: 'mapped2' }, { id: 'mapped1' }, { id: 'mapped2' }],
        };

        const mapper = mapRelation(async () => {
          return [{ id: 'mapped1' }, { id: 'mapped2' }];
        });

        expect(await mapper(relation)).toMatchObject(expectedRelation);
      });
    });

    it('disconnect', async () => {
      const relation = { disconnect: { id: 1 } };
      const expectedRelation = { disconnect: [{ id: 'mapped' }] };
      expect(await mapper(relation)).toMatchObject(expectedRelation);

      const relationArray = { disconnect: [{ id: 1 }, { id: 2 }] };
      const expectedRelationArray = { disconnect: [{ id: 'mapped' }, { id: 'mapped' }] };
      expect(await mapper(relationArray)).toMatchObject(expectedRelationArray);
    });

    it('set', async () => {
      const relation = { set: { id: 1 } };
      const expectedRelation = { set: [{ id: 'mapped' }] };
      expect(await mapper(relation)).toMatchObject(expectedRelation);

      const relationArray = { set: [{ id: 1 }, { id: 2 }] };
      const expectedRelationArray = { set: [{ id: 'mapped' }, { id: 'mapped' }] };
      expect(await mapper(relationArray)).toMatchObject(expectedRelationArray);
    });
  });

  describe('short hand', () => {
    it('short hand', async () => {
      const numberRelation = 1;
      const stringRelation = '1';

      const expectedRelation = { set: [{ id: 'mapped' }] };

      expect(await mapper(numberRelation)).toMatchObject(expectedRelation);
      expect(await mapper(stringRelation)).toMatchObject(expectedRelation);
    });

    it('short hand multiple', async () => {
      const relation = [1, '1', { id: 1 }] as any;

      const expectedRelation = { set: [{ id: 'mapped' }, { id: 'mapped' }, { id: 'mapped' }] };

      expect(await mapper(relation)).toMatchObject(expectedRelation);
    });
  });

  it('default', async () => {
    const relation = null as any;
    const expectedRelation = 'default';

    expect(await mapper(relation)).toBe(expectedRelation);
  });
});
</file>

<file path="src/services/document-service/transform/__tests__/populate.test.ts">
import { PRODUCT_UID, CATEGORY_UID, models } from './utils';

import { transformPopulate } from '../populate';

const findProducts = jest.fn(() => ({}));
const findCategories = jest.fn(() => ({}));

const findManyQueries = {
  [PRODUCT_UID]: findProducts,
  [CATEGORY_UID]: findCategories,
} as Record<string, jest.Mock>;

describe('transformPopulate', () => {
  beforeAll(() => {
    global.strapi = {
      getModel: (uid: string) => models[uid],
      db: {
        query: jest.fn((uid) => ({ findMany: findManyQueries[uid] })),
        metadata: {
          get: jest.fn(() => ({
            columnToAttribute: [],
          })),
        },
      },
    } as any;
  });

  // TODO: Are these all realistic formats for populate?
  it('should not modify simple populate', async () => {
    const input = { id: 'someValue' };
    const expected = { id: 'someValue' };

    expect(await transformPopulate(input, { uid: CATEGORY_UID })).toEqual(expected);
  });

  it('should handle empty objects', async () => {
    const input = {};
    const expected = {};

    expect(await transformPopulate(input, { uid: PRODUCT_UID })).toEqual(expected);
  });

  it('should ignore non relational nested values', async () => {
    const input = { _tmp: { id: 'nestedValue' } };

    expect(await transformPopulate(input, { uid: PRODUCT_UID })).toEqual(input);
  });

  it('should ignore non relational nested filters', async () => {
    const input = { _tmp: { filters: { id: 'nestedValue', something: 'else' } } };

    expect(await transformPopulate(input, { uid: PRODUCT_UID })).toEqual(input);
  });

  it('should handle arrays in relational fields', async () => {
    const input = { categories: { fields: ['this', 'that'] } };
    const expected = { categories: { fields: ['this', 'that', 'documentId'] } };

    expect(await transformPopulate(input, { uid: PRODUCT_UID })).toEqual(expected);
  });
});
</file>

<file path="src/services/document-service/transform/__tests__/utils.ts">
import type { Schema, Internal } from '@strapi/types';

const createSchemaFromAttributes = (
  uid: Internal.UID.ContentType,
  attributes: Schema.Attributes,
  singularName?: string,
  pluralName?: string,
  options?: Schema.ContentType['options']
): Schema.ContentType => {
  return {
    uid,
    info: {
      displayName: 'Test',
      singularName: singularName || 'test',
      pluralName: pluralName || 'tests',
    },
    kind: 'collectionType',
    modelName: uid,
    options: {
      draftAndPublish: true,
      ...options,
    },
    globalId: uid,
    modelType: 'contentType',
    attributes,
  };
};

export const CATEGORY_UID = 'api::category.category' as Internal.UID.ContentType;
export const PRODUCT_UID = 'api::product.product' as Internal.UID.ContentType;
export const SHOP_UID = 'api::shop.shop' as Internal.UID.ContentType;

export const models: Record<string, Schema.ContentType> = {
  [CATEGORY_UID]: createSchemaFromAttributes(
    CATEGORY_UID,
    {
      id: {
        type: 'string',
      },
      name: {
        type: 'string',
      },
      relatedCategories: {
        type: 'relation',
        relation: 'oneToMany',
        target: CATEGORY_UID,
      },
      products: {
        type: 'relation',
        relation: 'manyToMany',
        target: PRODUCT_UID,
        mappedBy: 'categories',
      },
    },
    'category',
    'categories'
  ),
  [PRODUCT_UID]: createSchemaFromAttributes(
    PRODUCT_UID,
    {
      id: {
        type: 'string',
      },
      name: {
        type: 'string',
      },
      categories: {
        type: 'relation',
        relation: 'manyToMany',
        target: CATEGORY_UID,
        inversedBy: 'products',
      },
      category: {
        type: 'relation',
        relation: 'oneToOne',
        target: CATEGORY_UID,
      },
      relatedProducts: {
        type: 'relation',
        relation: 'oneToMany',
        target: PRODUCT_UID,
      },
      shops: {
        type: 'relation',
        relation: 'manyToMany',
        target: SHOP_UID,
        inversedBy: 'products',
      },
      shop: {
        type: 'relation',
        relation: 'oneToOne',
        target: SHOP_UID,
        inversedBy: 'product',
      },
    },
    'product',
    'products'
  ),
  [SHOP_UID]: createSchemaFromAttributes(
    SHOP_UID,
    {
      id: {
        type: 'string',
      },
      name: {
        type: 'string',
      },
      products: {
        type: 'relation',
        relation: 'manyToMany',
        target: PRODUCT_UID,
        mappedBy: 'shop',
      },
      product: {
        type: 'relation',
        relation: 'oneToOne',
        target: PRODUCT_UID,
        mappedBy: 'shops',
      },
    },
    'shop',
    'shops',
    { draftAndPublish: false }
  ),
};
</file>

<file path="src/services/document-service/transform/relations/extract/data-ids.ts">
import { curry } from 'lodash/fp';

import type { UID } from '@strapi/types';
import { relations } from '@strapi/utils';
import { IdMap } from '../../id-map';
import { getRelationTargetLocale } from '../utils/i18n';
import { getRelationTargetStatus } from '../utils/dp';
import { mapRelation, traverseEntityRelations } from '../utils/map-relation';
import { LongHandDocument } from '../utils/types';

const { isPolymorphic } = relations;

interface Options {
  uid: UID.Schema;
  locale?: string | null;
  status?: 'draft' | 'published';
}

/**
 * Load a relation documentId into the idMap.
 */
const addRelationDocId = curry(
  (idMap: IdMap, source: Options, targetUid: UID.Schema, relation: LongHandDocument) => {
    const targetLocale = getRelationTargetLocale(relation, {
      targetUid,
      sourceUid: source.uid,
      sourceLocale: source.locale,
    });

    const targetStatus = getRelationTargetStatus(relation, {
      targetUid,
      sourceUid: source.uid,
      sourceStatus: source.status,
    });

    targetStatus.forEach((status) => {
      idMap.add({
        uid: targetUid,
        documentId: relation.documentId,
        locale: targetLocale,
        status,
      });
    });
  }
);

/**
 * Iterate over all relations of a data object and extract all relational document ids.
 * Those will later be transformed to entity ids.
 */
const extractDataIds = (idMap: IdMap, data: Record<string, any>, source: Options) => {
  return traverseEntityRelations(
    async ({ attribute, value }) => {
      if (!attribute) {
        return;
      }
      const isPolymorphicRelation = isPolymorphic(attribute);
      const addDocId = addRelationDocId(idMap, source);

      return mapRelation((relation) => {
        if (!relation || !relation.documentId) {
          return relation;
        }

        // Regular relations will always target the same target
        // if its a polymorphic relation we need to get it from the data itself
        const targetUid = isPolymorphicRelation ? relation.__type : attribute.target;

        addDocId(targetUid, relation);

        // Handle positional arguments
        const position = relation.position;

        // The positional relation target uid can be different for polymorphic relations
        let positionTargetUid = targetUid;
        if (isPolymorphicRelation && position?.__type) {
          positionTargetUid = position.__type;
        }

        if (position?.before) {
          addDocId(positionTargetUid, { ...relation, ...position, documentId: position.before });
        }

        if (position?.after) {
          addDocId(positionTargetUid, { ...relation, ...position, documentId: position.after });
        }

        return relation;
      }, value as any);
    },
    { schema: strapi.getModel(source.uid), getModel: strapi.getModel.bind(strapi) },
    data
  );
};

export { extractDataIds };
</file>

<file path="src/services/document-service/transform/relations/transform/data-ids.ts">
import { curry } from 'lodash/fp';

import type { UID } from '@strapi/types';
import { errors, relations } from '@strapi/utils';

import { ID, LongHandDocument } from '../utils/types';
import { IdMap } from '../../id-map';
import { getRelationTargetLocale } from '../utils/i18n';
import { getRelationTargetStatus } from '../utils/dp';
import { mapRelation, traverseEntityRelations } from '../utils/map-relation';

const { isPolymorphic } = relations;

interface Options {
  uid: UID.Schema;
  locale?: string | null;
  status?: 'draft' | 'published';
  allowMissingId?: boolean; // Whether to ignore missing ids and not throw any error
}

/**
 * Get the entry ids for a given documentId.
 */
const getRelationIds = curry(
  (idMap: IdMap, source: Options, targetUid: UID.Schema, relation: LongHandDocument) => {
    // locale to connect to
    const targetLocale = getRelationTargetLocale(relation, {
      targetUid,
      sourceUid: source.uid,
      sourceLocale: source.locale,
    });

    // status(es) to connect to
    const targetStatus = getRelationTargetStatus(relation, {
      targetUid,
      sourceUid: source.uid,
      sourceStatus: source.status,
    });

    const ids: ID[] = [];

    // Find mapping between documentID -> id(s).
    // There are scenarios where a single documentID can map to multiple ids.
    // e.g when connecting Non DP -> DP and connecting to both the draft and publish version at the same time
    for (const tStatus of targetStatus) {
      const entryId = idMap.get({
        uid: targetUid,
        documentId: relation.documentId,
        locale: targetLocale,
        status: tStatus,
      });

      if (entryId) ids.push(entryId);
    }

    if (!ids.length && !source.allowMissingId) {
      throw new errors.ValidationError(
        `Document with id "${relation.documentId}", locale "${targetLocale}" not found`
      );
    }

    return ids;
  }
);

/**
 * Iterate over all relations of a data object and transform all relational document ids to entity ids.
 */
const transformDataIdsVisitor = (idMap: IdMap, data: Record<string, any>, source: Options) => {
  return traverseEntityRelations(
    async ({ key, value, attribute }, { set }) => {
      if (!attribute) {
        return;
      }
      const isPolymorphicRelation = isPolymorphic(attribute);
      const getIds = getRelationIds(idMap, source);

      // Transform the relation documentId to entity id
      const newRelation = await mapRelation((relation) => {
        if (!relation || !relation.documentId) {
          return relation;
        }

        // Find relational attributes, and return the document ids
        // if its a polymorphic relation we need to get it from the data itself
        const targetUid: UID.Schema = isPolymorphicRelation ? relation.__type : attribute.target;
        const ids: ID[] = getIds(targetUid, relation);

        // Handle positional arguments
        const position = { ...relation.position };

        // The positional relation target uid can be different for polymorphic relations
        let positionTargetUid: UID.Schema = targetUid;
        if (isPolymorphicRelation && position?.__type) {
          positionTargetUid = position.__type;
        }

        if (position.before) {
          const beforeRelation = { ...relation, ...position, documentId: position.before };
          const beforeIds: ID[] = getIds(positionTargetUid, beforeRelation);
          position.before = beforeIds.at(0);
        }

        if (position.after) {
          const afterRelation = { ...relation, ...position, documentId: position.after };
          position.after = getIds(positionTargetUid, afterRelation).at(0);
        }

        // Transform all ids to new relations
        return ids?.map((id) => {
          const newRelation = { id } as typeof relation;

          if (relation.position) {
            newRelation.position = position;
          }

          // Insert type if its a polymorphic relation
          if (isPolymorphicRelation) {
            newRelation.__type = targetUid;
          }

          return newRelation;
        });
      }, value as any);

      set(key, newRelation as any);
    },
    { schema: strapi.getModel(source.uid), getModel: strapi.getModel.bind(strapi) },
    data
  );
};

export { transformDataIdsVisitor };
</file>

<file path="src/services/document-service/transform/relations/transform/default-locale.ts">
import type { UID } from '@strapi/types';

import { getDefaultLocale, isLocalizedContentType } from '../utils/i18n';
import { mapRelation, traverseEntityRelations } from '../utils/map-relation';

/**
 * In scenarios like Non i18n CT -> i18n CT
 * relations can be connected to multiple locales,
 * in case user does not provide the locale, this sets it to the default one.
 */
const setDefaultLocaleToRelations = (data: Record<string, any>, uid: UID.Schema) => {
  // I18n CT -> anything will already have a locale set (source locale)
  if (isLocalizedContentType(uid)) {
    return data;
  }

  // Store the default locale to avoid multiple calls
  let defaultLocale: string;

  /**
   * Traverse the entity input data and set the default locale to relations
   */
  return traverseEntityRelations(
    async ({ key, value }, { set }) => {
      /**
       * Assign default locale on long hand expressed relations
       * e.g { documentId } -> { documentId, locale }
       */
      const relation = await mapRelation(async (relation) => {
        if (!relation || !relation?.documentId || relation?.locale) {
          return relation;
        }

        // Set default locale if not provided
        if (!defaultLocale) {
          defaultLocale = await getDefaultLocale();
        }

        // Assign default locale to the positional argument
        const position = relation.position;
        if (position && typeof position === 'object' && !position.locale) {
          relation.position.locale = defaultLocale;
        }

        return { ...relation, locale: defaultLocale };
      }, value as any);

      // @ts-expect-error - fix type
      set(key, relation);
    },
    { schema: strapi.getModel(uid), getModel: strapi.getModel.bind(strapi) },
    data
  );
};

export { setDefaultLocaleToRelations };
</file>

<file path="src/services/document-service/transform/relations/utils/data.ts">
import { isObject } from 'lodash/fp';
import { ID, LongHand } from './types';

export const isShortHand = (relation: any): relation is ID => {
  return typeof relation === 'string' || typeof relation === 'number';
};

export const isLongHand = (relation: any): relation is LongHand => {
  return isObject(relation) && ('id' in relation || 'documentId' in relation);
};
</file>

<file path="src/services/document-service/transform/relations/utils/dp.ts">
import { isNil } from 'lodash/fp';

import { contentTypes } from '@strapi/utils';
import type { UID } from '@strapi/types';

import { LongHandDocument } from './types';

type Status = 'draft' | 'published';

export const getRelationTargetStatus = (
  relation: Pick<LongHandDocument, 'documentId' | 'status'>,
  opts: {
    targetUid: UID.Schema;
    sourceUid: UID.Schema;
    sourceStatus?: Status;
  }
): Status[] => {
  // Ignore if the target content type does not have draft and publish enabled
  const targetContentType = strapi.getModel(opts.targetUid);
  const sourceContentType = strapi.getModel(opts.sourceUid);

  const targetHasDP = contentTypes.hasDraftAndPublish(targetContentType);
  const sourceHasDP = contentTypes.hasDraftAndPublish(sourceContentType);

  if (!targetHasDP) {
    return ['published'];
  }

  /**
   * If both source and target have DP enabled,
   * connect it to the same status as the source status
   */
  if (sourceHasDP && !isNil(opts.sourceStatus)) {
    return [opts.sourceStatus];
  }

  /**
   * Use the status from the relation if it's set
   */
  if (relation.status) {
    switch (relation.status) {
      case 'published':
        return ['published'];
      default:
        // Default to draft if it's an invalid status (e.g. modified)
        return ['draft'];
    }
  }

  /**
   * If DP is disabled and relation does not specify any status
   * Connect to both draft and published versions
   */
  if (!sourceHasDP) {
    return ['draft', 'published'];
  }

  // Default to draft as a fallback
  return ['draft'];
};
</file>

<file path="src/services/document-service/transform/relations/utils/i18n.ts">
import type { UID } from '@strapi/types';
import { LongHandDocument } from './types';

export const isLocalizedContentType = (uid: UID.Schema) => {
  const model = strapi.getModel(uid);
  return strapi.plugin('i18n').service('content-types').isLocalizedContentType(model);
};

export const getDefaultLocale = () => {
  return strapi.plugin('i18n').service('locales').getDefaultLocale();
};

export const getRelationTargetLocale = (
  relation: LongHandDocument,
  opts: {
    targetUid: UID.Schema;
    sourceUid: UID.Schema;
    sourceLocale?: string | null;
  }
) => {
  const targetLocale = relation.locale || opts.sourceLocale;

  const isTargetLocalized = isLocalizedContentType(opts.targetUid);
  const isSourceLocalized = isLocalizedContentType(opts.sourceUid);

  // Both source and target locales should match
  if (isSourceLocalized && isTargetLocalized) {
    return opts.sourceLocale;
  }

  if (isTargetLocalized) {
    return targetLocale;
  }

  return null;
};
</file>

<file path="src/services/document-service/transform/relations/utils/map-relation.ts">
/* eslint-disable node/no-callback-literal */
import { isObject, curry, isNil } from 'lodash/fp';

import { traverseEntity, async } from '@strapi/utils';

import { Relation } from './types';

const isNumeric = (value: any): value is number => {
  if (Array.isArray(value)) return false; // Handle [1, 'docId'] case
  const parsed = parseInt(value, 10);
  return !Number.isNaN(parsed);
};

const toArray = (value: any) => {
  // Keep value as it is if it's a nullish value
  if (isNil(value)) return value;
  if (Array.isArray(value)) return value;

  return [value];
};

/**
 * There are multiple ways to create Strapi relations.
 * This is a utility to traverse and transform relation data
 *
 *
 * For consistency and ease of use, the response will always be an object with the following shape:
 * { set: [{...}], connect: [{...}], disconnect: [{...}] }
 *
 * @example
 * transformRelationData({
 *  onLongHand: (relation) => {
 *    // Change the id of the relation
 *    return { id: 'other' };
 *  },
 * }, relation)
 */
const mapRelation = async (
  callback: (relation: any) => any,
  rel: Relation,
  isRecursive = false
): Promise<Relation> => {
  let relation: Relation = rel;

  const wrapInSet = (value: any) => {
    // Ignore wrapping if it's a recursive call
    if (isRecursive) {
      return value;
    }
    return { set: toArray(value) };
  };

  // undefined | null
  if (isNil(relation)) {
    return callback(relation);
  }

  // LongHand[] | ShortHand[]
  if (Array.isArray(relation)) {
    return async
      .map(relation, (r: Relation) => mapRelation(callback, r, true))
      .then((result: any) => result.flat().filter(Boolean))
      .then(wrapInSet);
  }

  // LongHand
  if (isObject(relation)) {
    // { id: 1 } || { documentId: 1 }
    if ('id' in relation || 'documentId' in relation) {
      const result = await callback(relation);
      return wrapInSet(result);
    }

    // If not connecting anything, return default visitor
    if (!relation.set && !relation.disconnect && !relation.connect) {
      return callback(relation);
    }

    // { set }
    if (relation.set) {
      const set: any = await mapRelation(callback, relation.set, true);
      relation = { ...relation, set: toArray(set) };
    }

    // { disconnect}
    if (relation.disconnect) {
      const disconnect: any = await mapRelation(callback, relation.disconnect, true);
      relation = { ...relation, disconnect: toArray(disconnect) };
    }

    // { connect }
    if (relation.connect) {
      // Transform the relation to connect
      const connect: any = await mapRelation(callback, relation.connect, true);
      relation = { ...relation, connect: toArray(connect) };
    }

    return relation;
  }

  // ShortHand
  if (isNumeric(relation)) {
    const result = await callback({ id: relation });
    return wrapInSet(result);
  }

  if (typeof relation === 'string') {
    const result = await callback({ documentId: relation });
    return wrapInSet(result);
  }

  // Anything else
  return callback(relation);
};

type TraverseEntity = Parameters<typeof traverseEntity>;

/**
 * Utility function, same as `traverseEntity` but only for relations.
 */
const traverseEntityRelations = async (
  visitor: TraverseEntity[0],
  options: TraverseEntity[1],
  data: TraverseEntity[2]
) => {
  return traverseEntity(
    async (options, utils) => {
      const { attribute } = options;

      if (!attribute) {
        return;
      }

      if (attribute.type !== 'relation') {
        return;
      }

      // TODO: Handle join columns
      if (attribute.useJoinTable === false) {
        return;
      }

      return visitor(options, utils);
    },
    options,
    data
  );
};

const mapRelationCurried = curry(mapRelation);
const traverseEntityRelationsCurried = curry(traverseEntityRelations);

export {
  mapRelationCurried as mapRelation,
  traverseEntityRelationsCurried as traverseEntityRelations,
};
</file>

<file path="src/services/document-service/transform/relations/utils/types.ts">
// TODO: Shorthand id should only be a string on documents.
// It's also a number here to make it works with existing V4 types.
export type ID = string | number;
export type ShortHand = ID;
// Relation can be connected either with an id or document ID
export type LongHandEntity = { id: ID; position?: object };
export type LongHandDocument = {
  documentId: ID;
  locale?: string;
  status?: 'draft' | 'published';
  position?: object;
};

export type LongHand = LongHandEntity | LongHandDocument;
export type RelationPrimitives = ShortHand | LongHand | ShortHand[] | LongHand[] | null | undefined;
export type Relation =
  | RelationPrimitives
  | { connect?: RelationPrimitives; disconnect?: RelationPrimitives; set?: RelationPrimitives };

export type GetIds = (relation: ID) => ID[] | null;
</file>

<file path="src/services/document-service/transform/data.ts">
import { createIdMap } from './id-map';
import { extractDataIds as extractDataRelationIds } from './relations/extract/data-ids';
import { transformDataIdsVisitor as transformRelationDataIds } from './relations/transform/data-ids';
import { setDefaultLocaleToRelations } from './relations/transform/default-locale';

/**
 * Transforms input data, containing relation document ids, to entity ids.
 */
export const transformData = async (data: any, opts: any) => {
  const idMap = createIdMap({ strapi });

  // Assign default locales
  const transformedData = await setDefaultLocaleToRelations(data, opts.uid);

  // Extract any relation ids from the input
  await extractDataRelationIds(idMap, transformedData, opts);

  // Load any relation the extract methods found
  await idMap.load();

  // Transform any relation ids to entity ids
  return transformRelationDataIds(idMap, transformedData, opts);
};
</file>

<file path="src/services/document-service/transform/fields.ts">
import type { Modules, UID } from '@strapi/types';

type Fields = Modules.Documents.Params.Pick<UID.Schema, 'fields'>['fields'];

export const transformFields = (fields: Fields): Fields => {
  // If  it's a string, and it doesn't contain documentId, should be an array
  if (typeof fields === 'string') {
    // '*' => '*'
    if (fields === '*') {
      return fields;
    }

    // '' => 'documentId'
    if (fields === '') {
      return 'documentId';
    }

    // 'name,description' => 'name,description,documentId'
    if (!fields.split(',').includes('documentId')) {
      return `${fields},documentId`;
    }
  }

  // It's not an array, ignore it
  if (!fields || !Array.isArray(fields)) {
    // If fields is empty, return it as is
    return fields;
  }

  // Ensure we are always selecting the documentId
  // ['name', 'description'] => ['name', 'description', 'documentId']
  if (!fields.includes('documentId')) {
    fields.push('documentId');
  }

  return fields;
};
</file>

<file path="src/services/document-service/transform/id-map.ts">
import type { Core, Data, UID } from '@strapi/types';
import { async, contentTypes } from '@strapi/utils';

const hasDraftAndPublish = (uid: UID.CollectionType) => {
  const model = strapi.getModel(uid);
  return contentTypes.hasDraftAndPublish(model);
};

/**
 * TODO: Find a better way to encode keys than this
 * This converts an object into a string by joining its keys and values,
 * so it can be used as a key in a Map.
 *
 * @example
 * const obj = { a: 1, b: 2 };
 * const key = encodeKey(obj);
 *      ^ "a:::1&&b:::2"
 */
const encodeKey = (obj: any) => {
  // Ignore status field for models without draft and publish
  if (!hasDraftAndPublish(obj.uid)) {
    delete obj.status;
  }

  // Sort keys to always keep the same order when encoding
  const keys = Object.keys(obj).sort();
  return keys.map((key) => `${key}:::${obj[key]}`).join('&&');
};

interface KeyFields {
  uid: string;
  documentId: Data.ID;
  locale?: string | null;
  status?: 'draft' | 'published';
}

export interface IdMap {
  loadedIds: Map<string, string>;
  toLoadIds: Map<string, KeyFields>;
  // Make the Keys type to be the params of add
  add(keys: KeyFields): void;
  load(): Promise<void>;
  get(keys: KeyFields): string | undefined;
  clear(): void;
}

/**
 * Holds a registry of document ids and their corresponding entity ids.
 */
const createIdMap = ({ strapi }: { strapi: Core.Strapi }): IdMap => {
  const loadedIds = new Map();
  const toLoadIds = new Map();

  return {
    loadedIds,
    toLoadIds,
    /**
     * Register a new document id and its corresponding entity id.
     */
    add(keyFields: KeyFields) {
      const key = encodeKey({ status: 'published', locale: null, ...keyFields });

      // If the id is already loaded, do nothing
      if (loadedIds.has(key)) return;
      // If the id is already in the toLoadIds, do nothing
      if (toLoadIds.has(key)) return;

      // Add the id to the toLoadIds
      toLoadIds.set(key, keyFields);
    },

    /**
     * Load all ids from the registry.
     */
    async load() {
      // Document Id to Entry Id queries are batched by its uid and locale
      // TODO: Add publication state too
      const loadIdValues = Array.from(toLoadIds.values());

      // 1. Group ids to query together
      const idsByUidAndLocale = loadIdValues.reduce((acc, { documentId, ...rest }) => {
        const key = encodeKey(rest);
        const ids = acc[key] || { ...rest, documentIds: [] };
        ids.documentIds.push(documentId);
        return { ...acc, [key]: ids };
      }, {});

      // 2. Query ids
      await async.map(
        Object.values(idsByUidAndLocale),
        async ({ uid, locale, documentIds, status }: any) => {
          const findParams = {
            select: ['id', 'documentId', 'locale', 'publishedAt'],
            where: {
              documentId: { $in: documentIds },
              locale: locale || null,
            },
          } as any;

          if (hasDraftAndPublish(uid)) {
            findParams.where.publishedAt = status === 'draft' ? null : { $ne: null };
          }

          const result = await strapi?.db?.query(uid).findMany(findParams);

          // 3. Store result in loadedIds
          result?.forEach(({ documentId, id, locale, publishedAt }: any) => {
            const key = encodeKey({
              documentId,
              uid,
              locale,
              status: publishedAt ? 'published' : 'draft',
            });
            loadedIds.set(key, id);
          });
        }
      );

      // 4. Clear toLoadIds
      toLoadIds.clear();
    },

    /**
     * Get the entity id for a given document id.
     */
    get(keys: KeyFields) {
      const key = encodeKey({ status: 'published', locale: null, ...keys });
      return loadedIds.get(key);
    },

    /**
     * Clear the registry.
     */
    clear() {
      loadedIds.clear();
      toLoadIds.clear();
    },
  };
};

export { createIdMap };
</file>

<file path="src/services/document-service/transform/id-transform.ts">
import { curry } from 'lodash/fp';

import type { UID, Modules } from '@strapi/types';

import { transformData } from './data';
import { transformFields } from './fields';
import { transformPopulate } from './populate';

/**
 * Transform input of a query to map document ids to entity ids.
 */
async function transformParamsDocumentId(
  uid: UID.Schema,
  query: Modules.Documents.Params.All
): Promise<Modules.Documents.Params.All> {
  // Transform relational documentIds to entity ids
  let data = query.data;
  if (query.data) {
    data = await transformData(query.data, {
      locale: query.locale,
      status: query.status,
      uid,
    });
  }

  // Make sure documentId is always present in the response
  let fields = query.fields;
  if (query.fields) {
    fields = transformFields(query.fields) as typeof query.fields;
  }

  let populate = query.populate;
  if (query.populate) {
    populate = (await transformPopulate(query.populate, { uid })) as typeof query.populate;
  }

  return {
    ...query,
    data,
    fields,
    populate,
  };
}

const curriedTransformParamsDocumentId = curry(transformParamsDocumentId);

export { curriedTransformParamsDocumentId as transformParamsDocumentId };
</file>

<file path="src/services/document-service/transform/populate.ts">
import { traverse } from '@strapi/utils';
import type { UID } from '@strapi/types';

import { type Data } from './types';
import { transformFields } from './fields';

export const transformPopulate = async (data: Data, opts: { uid: UID.Schema }) => {
  return traverse.traverseQueryPopulate(
    async ({ attribute, key, value }, { set }) => {
      if (!value || typeof value !== 'object' || attribute?.type !== 'relation') {
        return;
      }

      /*
        If the attribute is a relation
        Look for fields in the value
        and apply the relevant transformation to these objects
      */
      if ('fields' in value && Array.isArray(value.fields)) {
        value.fields = transformFields(value.fields);
      }

      set(key, value);
    },
    { schema: strapi.getModel(opts.uid), getModel: strapi.getModel.bind(strapi) },
    data
  );
};
</file>

<file path="src/services/document-service/transform/query.ts">
import type { UID } from '@strapi/types';

import { curry, assoc } from 'lodash/fp';

const transformParamsToQuery = curry((uid: UID.Schema, params: any) => {
  const query = strapi.get('query-params').transform(uid, params);

  return assoc('where', { ...params?.lookup, ...query.where }, query);
});

export { transformParamsToQuery };
</file>

<file path="src/services/document-service/transform/types.ts">
import type { UID } from '@strapi/types';
import type { ID } from './relations/utils/types';

export type Data = {
  id?: ID | object;
  documentId?: ID | object;
  [key: string]: any;
};

export type Options = {
  uid: UID.Schema;
  locale?: string | null;
  status: 'draft' | 'published';
};
</file>

<file path="src/services/document-service/utils/populate.ts">
import type { UID } from '@strapi/types';
import { contentTypes } from '@strapi/utils';

interface Options {
  /**
   * Fields to select when populating relations
   */
  relationalFields?: string[];
}

const { CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE } = contentTypes.constants;

// We want to build a populate object based on the schema
export const getDeepPopulate = (uid: UID.Schema, opts: Options = {}) => {
  const model = strapi.getModel(uid);
  const attributes = Object.entries(model.attributes);

  return attributes.reduce((acc: any, [attributeName, attribute]) => {
    switch (attribute.type) {
      case 'relation': {
        // TODO: Support polymorphic relations
        const isMorphRelation = attribute.relation.toLowerCase().startsWith('morph');
        if (isMorphRelation) {
          break;
        }

        // Ignore not visible fields other than createdBy and updatedBy
        const isVisible = contentTypes.isVisibleAttribute(model, attributeName);
        const isCreatorField = [CREATED_BY_ATTRIBUTE, UPDATED_BY_ATTRIBUTE].includes(attributeName);

        if (isVisible || isCreatorField) {
          acc[attributeName] = { select: opts.relationalFields };
        }

        break;
      }

      case 'media': {
        // We populate all media fields for completeness of webhook responses
        // see https://github.com/strapi/strapi/issues/21546
        acc[attributeName] = { select: ['*'] };
        break;
      }

      case 'component': {
        const populate = getDeepPopulate(attribute.component, opts);
        acc[attributeName] = { populate };
        break;
      }

      case 'dynamiczone': {
        // Use fragments to populate the dynamic zone components
        const populatedComponents = (attribute.components || []).reduce(
          (acc: any, componentUID: UID.Component) => {
            acc[componentUID] = { populate: getDeepPopulate(componentUID, opts) };
            return acc;
          },
          {}
        );

        acc[attributeName] = { on: populatedComponents };
        break;
      }
      default:
        break;
    }

    return acc;
  }, {});
};
</file>

<file path="src/services/document-service/utils/unidirectional-relations.ts">
/* eslint-disable no-continue */
import { keyBy, omit } from 'lodash/fp';

import type { UID, Schema } from '@strapi/types';

interface LoadContext {
  oldVersions: { id: string; locale: string }[];
  newVersions: { id: string; locale: string }[];
}

/**
 * Loads lingering relations that need to be updated when overriding a published or draft entry.
 * This is necessary because the relations are uni-directional and the target entry is not aware of the source entry.
 * This is not the case for bi-directional relations, where the target entry is also linked to the source entry.
 */
const load = async (uid: UID.ContentType, { oldVersions, newVersions }: LoadContext) => {
  const updates = [] as any;

  // Iterate all components and content types to find relations that need to be updated
  await strapi.db.transaction(async ({ trx }) => {
    const contentTypes = Object.values(strapi.contentTypes) as Schema.ContentType[];
    const components = Object.values(strapi.components) as Schema.Component[];

    for (const model of [...contentTypes, ...components]) {
      const dbModel = strapi.db.metadata.get(model.uid);

      for (const attribute of Object.values(dbModel.attributes) as any) {
        /**
         * Only consider unidirectional relations
         */
        if (
          attribute.type !== 'relation' ||
          attribute.target !== uid ||
          attribute.inversedBy ||
          attribute.mappedBy
        ) {
          continue;
        }

        // TODO: joinColumn relations
        const joinTable = attribute.joinTable;
        if (!joinTable) {
          continue;
        }

        const { name: sourceColumnName } = joinTable.joinColumn;
        const { name: targetColumnName } = joinTable.inverseJoinColumn;

        /**
         * Load all relations that need to be updated
         */
        // NOTE: when the model has draft and publish, we can assume relation are only draft to draft & published to published
        const ids = oldVersions.map((entry) => entry.id);

        const oldVersionsRelations = await strapi.db
          .getConnection()
          .select('*')
          .from(joinTable.name)
          .whereIn(targetColumnName, ids)
          .transacting(trx);

        if (oldVersionsRelations.length > 0) {
          updates.push({ joinTable, relations: oldVersionsRelations });
        }

        /**
         * if publishing
         *  if published version exists
         *    updated published versions links
         *  else
         *    create link to newly published version
         *
         * if discarding
         *    if published version link exists & not draft version link
         *       create link to new draft version
         */

        if (!model.options?.draftAndPublish) {
          const ids = newVersions.map((entry) => entry.id);

          const newVersionsRelations = await strapi.db
            .getConnection()
            .select('*')
            .from(joinTable.name)
            .whereIn(targetColumnName, ids)
            .transacting(trx);

          if (newVersionsRelations.length > 0) {
            // when publishing a draft that doesn't have a published version yet,
            // copy the links to the draft over to the published version
            // when discarding a published version, if no drafts exists
            const discardToAdd = newVersionsRelations
              .filter((relation) => {
                const matchingOldVerion = oldVersionsRelations.find((oldRelation) => {
                  return oldRelation[sourceColumnName] === relation[sourceColumnName];
                });

                return !matchingOldVerion;
              })
              .map(omit('id'));

            updates.push({ joinTable, relations: discardToAdd });
          }
        }
      }
    }
  });

  return updates;
};

/**
 * Updates uni directional relations to target the right entries when overriding published or draft entries.
 *
 * @param oldEntries The old entries that are being overridden
 * @param newEntries The new entries that are overriding the old ones
 * @param oldRelations The relations that were previously loaded with `load` @see load
 */
const sync = async (
  oldEntries: { id: string; locale: string }[],
  newEntries: { id: string; locale: string }[],
  oldRelations: { joinTable: any; relations: any[] }[]
) => {
  /**
   * Create a map of old entry ids to new entry ids
   *
   * Will be used to update the relation target ids
   */
  const newEntryByLocale = keyBy('locale', newEntries);
  const oldEntriesMap = oldEntries.reduce(
    (acc, entry) => {
      const newEntry = newEntryByLocale[entry.locale];
      if (!newEntry) return acc;
      acc[entry.id] = newEntry.id;
      return acc;
    },
    {} as Record<string, string>
  );

  await strapi.db.transaction(async ({ trx }) => {
    // Iterate old relations that are deleted and insert the new ones
    for (const { joinTable, relations } of oldRelations) {
      // Update old ids with the new ones
      const column = joinTable.inverseJoinColumn.name;

      const newRelations = relations.map((relation) => {
        const newId = oldEntriesMap[relation[column]];
        return { ...relation, [column]: newId };
      });

      // Insert those relations into the join table
      await trx.batchInsert(joinTable.name, newRelations, 1000);
    }
  });
};

export { load, sync };
</file>

<file path="src/services/document-service/common.ts">
import type { UID, Modules } from '@strapi/types';

export type RepositoryFactoryMethod = <TContentTypeUID extends UID.ContentType>(
  uid: TContentTypeUID,
  entityValidator: Modules.EntityValidator.EntityValidator
) => Modules.Documents.ServiceInstance<TContentTypeUID>;

export const wrapInTransaction = (fn: (...args: any) => any) => {
  return (...args: any[]) => strapi.db.transaction?.(() => fn(...args));
};
</file>

<file path="src/services/document-service/components.ts">
import _ from 'lodash';
import { has, omit, pipe, assign, curry } from 'lodash/fp';
import type { Utils, UID, Schema, Data, Modules } from '@strapi/types';
import { contentTypes as contentTypesUtils, async, errors } from '@strapi/utils';

// type aliases for readability
type Input<T extends UID.Schema> = Modules.Documents.Params.Data.Input<T>;

type LoadedComponents<TUID extends UID.Schema> = Data.Entity<
  TUID,
  Schema.AttributeNamesByType<TUID, 'component' | 'dynamiczone'>
>;

type SingleComponentValue = Schema.Attribute.ComponentValue<UID.Component, false>;
type RepeatableComponentValue = Schema.Attribute.ComponentValue<UID.Component, true>;

type ComponentValue = SingleComponentValue | RepeatableComponentValue;

type DynamicZoneValue = Schema.Attribute.DynamicZoneValue<UID.Component[]>;

type ComponentBody = {
  [key: string]: ComponentValue | DynamicZoneValue;
};

const omitComponentData = curry(
  (schema: Schema.Schema, data: Input<UID.Schema>): Partial<Input<UID.Schema>> => {
    const { attributes } = schema;
    const componentAttributes = Object.keys(attributes).filter((attributeName) =>
      contentTypesUtils.isComponentAttribute(attributes[attributeName])
    );

    return omit(componentAttributes, data);
  }
);

// NOTE: we could generalize the logic to allow CRUD of relation directly in the DB layer
const createComponents = async <TUID extends UID.Schema, TData extends Input<TUID>>(
  uid: TUID,
  data: TData
) => {
  const { attributes = {} } = strapi.getModel(uid);

  const componentBody: ComponentBody = {};

  const attributeNames = Object.keys(attributes);

  for (const attributeName of attributeNames) {
    const attribute = attributes[attributeName];

    if (!has(attributeName, data) || !contentTypesUtils.isComponentAttribute(attribute)) {
      continue;
    }

    if (attribute.type === 'component') {
      const { component: componentUID, repeatable = false } = attribute;

      const componentValue = data[attributeName as keyof TData];

      if (componentValue === null) {
        continue;
      }

      if (repeatable === true) {
        if (!Array.isArray(componentValue)) {
          throw new Error('Expected an array to create repeatable component');
        }

        const components: RepeatableComponentValue = await async.map(componentValue, (value: any) =>
          createComponent(componentUID, value)
        );

        componentBody[attributeName] = components.map(({ id }) => {
          return {
            id,
            __pivot: {
              field: attributeName,
              component_type: componentUID,
            },
          };
        });
      } else {
        const component = await createComponent(
          componentUID,
          componentValue as Input<UID.Component>
        );

        componentBody[attributeName] = {
          id: component.id,
          __pivot: {
            field: attributeName,
            component_type: componentUID,
          },
        };
      }

      continue;
    }

    if (attribute.type === 'dynamiczone') {
      const dynamiczoneValues = data[
        attributeName as keyof TData
      ] as Modules.EntityService.Params.Attribute.GetValue<Schema.Attribute.DynamicZone>;

      if (!Array.isArray(dynamiczoneValues)) {
        throw new Error('Expected an array to create repeatable component');
      }

      const createDynamicZoneComponents = async (
        value: Utils.Array.Values<typeof dynamiczoneValues>
      ) => {
        const { id } = await createComponent(value.__component, value);
        return {
          id,
          __component: value.__component,
          __pivot: {
            field: attributeName,
          },
        };
      };

      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1
      componentBody[attributeName] = await async.map(
        dynamiczoneValues,
        createDynamicZoneComponents
      );

      continue;
    }
  }

  return componentBody;
};

const getComponents = async <TUID extends UID.Schema>(
  uid: TUID,
  entity: { id: Modules.EntityService.Params.Attribute.ID }
): Promise<LoadedComponents<TUID>> => {
  const componentAttributes = contentTypesUtils.getComponentAttributes(strapi.getModel(uid));

  if (_.isEmpty(componentAttributes)) {
    return {} as LoadedComponents<TUID>;
  }

  return strapi.db.query(uid).load(entity, componentAttributes) as Promise<LoadedComponents<TUID>>;
};

/*
  delete old components
  create or update
*/
const updateComponents = async <TUID extends UID.Schema, TData extends Partial<Input<TUID>>>(
  uid: TUID,
  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },
  data: TData
) => {
  const { attributes = {} } = strapi.getModel(uid);

  const componentBody: ComponentBody = {};

  for (const attributeName of Object.keys(attributes)) {
    const attribute = attributes[attributeName];

    if (!has(attributeName, data)) {
      continue;
    }

    if (attribute.type === 'component') {
      const { component: componentUID, repeatable = false } = attribute;

      const componentValue = data[attributeName as keyof TData] as ComponentValue;
      await deleteOldComponents(uid, componentUID, entityToUpdate, attributeName, componentValue);

      if (repeatable === true) {
        if (!Array.isArray(componentValue)) {
          throw new Error('Expected an array to create repeatable component');
        }

        // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1
        const components: RepeatableComponentValue = await async.map(componentValue, (value: any) =>
          updateOrCreateComponent(componentUID, value)
        );

        componentBody[attributeName] = components.filter(_.negate(_.isNil)).map(({ id }) => {
          return {
            id,
            __pivot: {
              field: attributeName,
              component_type: componentUID,
            },
          };
        });
      } else {
        const component = await updateOrCreateComponent(componentUID, componentValue);
        componentBody[attributeName] = component && {
          id: component.id,
          __pivot: {
            field: attributeName,
            component_type: componentUID,
          },
        };
      }
    } else if (attribute.type === 'dynamiczone') {
      const dynamiczoneValues = data[attributeName as keyof TData] as DynamicZoneValue;

      await deleteOldDZComponents(uid, entityToUpdate, attributeName, dynamiczoneValues);

      if (!Array.isArray(dynamiczoneValues)) {
        throw new Error('Expected an array to create repeatable component');
      }

      // MySQL/MariaDB can cause deadlocks here if concurrency higher than 1
      componentBody[attributeName] = await async.map(dynamiczoneValues, async (value: any) => {
        const { id } = await updateOrCreateComponent(value.__component, value);

        return {
          id,
          __component: value.__component,
          __pivot: {
            field: attributeName,
          },
        };
      });
    }
  }

  return componentBody;
};

const pickStringifiedId = ({
  id,
}: {
  id: Modules.EntityService.Params.Attribute.ID;
}): Modules.EntityService.Params.Attribute.ID & string => {
  if (typeof id === 'string') {
    return id;
  }

  return `${id}`;
};

const deleteOldComponents = async <TUID extends UID.Schema>(
  uid: TUID,
  componentUID: UID.Component,
  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },
  attributeName: string,
  componentValue: ComponentValue
) => {
  const previousValue = (await strapi.db
    .query(uid)
    .load(entityToUpdate, attributeName)) as ComponentValue;
  const idsToKeep = _.castArray(componentValue).filter(has('id')).map(pickStringifiedId);
  const allIds = _.castArray(previousValue).filter(has('id')).map(pickStringifiedId);

  idsToKeep.forEach((id) => {
    if (!allIds.includes(id)) {
      throw new errors.ApplicationError(
        `Some of the provided components in ${attributeName} are not related to the entity`
      );
    }
  });

  const idsToDelete = _.difference(allIds, idsToKeep);

  if (idsToDelete.length > 0) {
    for (const idToDelete of idsToDelete) {
      await deleteComponent(componentUID, { id: idToDelete });
    }
  }
};

const deleteOldDZComponents = async <TUID extends UID.Schema>(
  uid: TUID,
  entityToUpdate: { id: Modules.EntityService.Params.Attribute.ID },
  attributeName: string,
  dynamiczoneValues: DynamicZoneValue
) => {
  const previousValue = (await strapi.db
    .query(uid)
    .load(entityToUpdate, attributeName)) as DynamicZoneValue;

  const idsToKeep = _.castArray(dynamiczoneValues)
    .filter(has('id'))
    .map((v) => ({
      id: pickStringifiedId(v),
      __component: v.__component,
    }));

  const allIds = _.castArray(previousValue)
    .filter(has('id'))
    .map((v) => ({
      id: pickStringifiedId(v),
      __component: v.__component,
    }));

  idsToKeep.forEach(({ id, __component }) => {
    if (!allIds.find((el) => el.id === id && el.__component === __component)) {
      const err = new Error(
        `Some of the provided components in ${attributeName} are not related to the entity`
      );

      Object.assign(err, { status: 400 });
      throw err;
    }
  });

  type IdsToDelete = DynamicZoneValue;

  const idsToDelete = allIds.reduce((acc, { id, __component }) => {
    if (!idsToKeep.find((el) => el.id === id && el.__component === __component)) {
      acc.push({ id, __component });
    }

    return acc;
  }, [] as IdsToDelete);

  if (idsToDelete.length > 0) {
    for (const idToDelete of idsToDelete) {
      const { id, __component } = idToDelete;
      await deleteComponent(__component, { id });
    }
  }
};

const deleteComponents = async <TUID extends UID.Schema, TEntity extends Data.Entity<TUID>>(
  uid: TUID,
  entityToDelete: TEntity,
  { loadComponents = true } = {}
) => {
  const { attributes = {} } = strapi.getModel(uid);

  const attributeNames = Object.keys(attributes);

  for (const attributeName of attributeNames) {
    const attribute = attributes[attributeName];

    if (attribute.type === 'component' || attribute.type === 'dynamiczone') {
      let value;

      if (loadComponents) {
        value = await strapi.db.query(uid).load(entityToDelete, attributeName);
      } else {
        value = entityToDelete[attributeName as keyof TEntity];
      }

      if (!value) {
        continue;
      }

      if (attribute.type === 'component') {
        const { component: componentUID } = attribute;
        await async.map(_.castArray(value), (subValue: any) =>
          deleteComponent(componentUID, subValue)
        );
      } else {
        await async.map(_.castArray(value), (subValue: any) =>
          deleteComponent(subValue.__component, subValue)
        );
      }

      continue;
    }
  }
};

/** *************************
    Component queries
************************** */

// components can have nested compos so this must be recursive
const createComponent = async <TUID extends UID.Component>(uid: TUID, data: Input<TUID>) => {
  const schema = strapi.getModel(uid);

  const componentData = await createComponents(uid, data);

  const transform = pipe(
    // Make sure we don't save the component with a pre-defined ID
    omit('id'),
    assignComponentData(schema, componentData)
  );

  return strapi.db.query(uid).create({ data: transform(data) });
};

// components can have nested compos so this must be recursive
const updateComponent = async <TUID extends UID.Component>(
  uid: TUID,
  componentToUpdate: { id: Modules.EntityService.Params.Attribute.ID },
  data: Input<TUID>
) => {
  const schema = strapi.getModel(uid);

  const componentData = await updateComponents(uid, componentToUpdate, data);

  return strapi.db.query(uid).update({
    where: {
      id: componentToUpdate.id,
    },
    data: assignComponentData(schema, componentData, data),
  });
};

const updateOrCreateComponent = <TUID extends UID.Component>(
  componentUID: TUID,
  value: Input<TUID>
) => {
  if (value === null) {
    return null;
  }

  // update
  if ('id' in value && typeof value.id !== 'undefined') {
    // TODO: verify the compo is associated with the entity
    return updateComponent(componentUID, { id: value.id }, value);
  }

  // create
  return createComponent(componentUID, value);
};

const deleteComponent = async <TUID extends UID.Component>(
  uid: TUID,
  componentToDelete: Data.Component<TUID>
) => {
  await deleteComponents(uid, componentToDelete);
  await strapi.db.query(uid).delete({ where: { id: componentToDelete.id } });
};

const assignComponentData = curry(
  (schema: Schema.Schema, componentData: ComponentBody, data: Input<UID.Schema>) => {
    return pipe(omitComponentData(schema), assign(componentData))(data);
  }
);

export {
  omitComponentData,
  assignComponentData,
  getComponents,
  createComponents,
  updateComponents,
  deleteComponents,
  deleteComponent,
};
</file>

<file path="src/services/document-service/draft-and-publish.ts">
import { assoc, curry } from 'lodash/fp';

import type { Modules, Struct } from '@strapi/types';
import { contentTypes } from '@strapi/utils';

type ParamsTransform = (params: Modules.Documents.Params.All) => Modules.Documents.Params.All;

type TransformWithContentType = (
  contentType: Struct.SingleTypeSchema | Struct.CollectionTypeSchema,
  params: Modules.Documents.Params.All
) => Modules.Documents.Params.All;

/**
 * DP enabled -> set status to draft
 * DP disabled -> Used mostly for parsing relations, so there is not a need for a default.
 */
const setStatusToDraft: TransformWithContentType = (contentType, params) => {
  if (!contentTypes.hasDraftAndPublish(contentType) && params.status) {
    return params;
  }

  return assoc('status', 'draft', params);
};

/**
 * Adds a default status of `draft` to the params
 */
const defaultToDraft: ParamsTransform = (params) => {
  // Default to draft if no status is provided or it's invalid
  if (!params.status || params.status !== 'published') {
    return assoc('status', 'draft', params);
  }

  return params;
};

/**
 * DP disabled -> ignore status
 * DP enabled -> set status to draft if no status is provided or it's invalid
 */
const defaultStatus: TransformWithContentType = (contentType, params) => {
  if (!contentTypes.hasDraftAndPublish(contentType)) {
    return params;
  }

  // Default to draft if no status is provided or it's invalid
  if (!params.status || params.status !== 'published') {
    return defaultToDraft(params);
  }

  return params;
};

/**
 * In mutating actions we don't want user to set the publishedAt attribute.
 */
const filterDataPublishedAt: ParamsTransform = (params) => {
  if (params?.data?.publishedAt) {
    return assoc(['data', 'publishedAt'], null, params);
  }

  return params;
};

/**
 * Add status lookup query to the params
 */
const statusToLookup: TransformWithContentType = (contentType, params) => {
  if (!contentTypes.hasDraftAndPublish(contentType)) {
    return params;
  }

  const lookup = params.lookup || {};

  switch (params?.status) {
    case 'published':
      return assoc(['lookup', 'publishedAt'], { $notNull: true }, params);
    case 'draft':
      return assoc(['lookup', 'publishedAt'], { $null: true }, params);
    default:
      break;
  }

  return assoc('lookup', lookup, params);
};

/**
 * Translate publication status parameter into the data that will be saved
 */
const statusToData: TransformWithContentType = (contentType, params) => {
  if (!contentTypes.hasDraftAndPublish(contentType)) {
    return assoc(['data', 'publishedAt'], new Date(), params);
  }

  switch (params?.status) {
    case 'published':
      return assoc(['data', 'publishedAt'], new Date(), params);
    case 'draft':
      return assoc(['data', 'publishedAt'], null, params);
    default:
      break;
  }

  return params;
};

const setStatusToDraftCurry = curry(setStatusToDraft);
const defaultToDraftCurry = curry(defaultToDraft);
const defaultStatusCurry = curry(defaultStatus);
const filterDataPublishedAtCurry = curry(filterDataPublishedAt);
const statusToLookupCurry = curry(statusToLookup);
const statusToDataCurry = curry(statusToData);

export {
  setStatusToDraftCurry as setStatusToDraft,
  defaultToDraftCurry as defaultToDraft,
  defaultStatusCurry as defaultStatus,
  filterDataPublishedAtCurry as filterDataPublishedAt,
  statusToLookupCurry as statusToLookup,
  statusToDataCurry as statusToData,
};
</file>

<file path="src/services/document-service/entries.ts">
import type { UID, Modules } from '@strapi/types';
import { async } from '@strapi/utils';
import { assoc, omit } from 'lodash/fp';

import * as components from './components';

import { transformParamsDocumentId } from './transform/id-transform';
import { transformParamsToQuery } from './transform/query';
import { pickSelectionParams } from './params';
import { applyTransforms } from './attributes';
import { transformData } from './transform/data';

const createEntriesService = (
  uid: UID.ContentType,
  entityValidator: Modules.EntityValidator.EntityValidator
) => {
  const contentType = strapi.contentType(uid);

  async function createEntry(params = {} as any) {
    const { data, ...restParams } = await transformParamsDocumentId(uid, params);

    const query = transformParamsToQuery(uid, pickSelectionParams(restParams) as any); // select / populate

    // Validation
    if (!data) {
      throw new Error('Create requires data attribute');
    }

    const validData = await entityValidator.validateEntityCreation(contentType, data, {
      // Note: publishedAt value will always be set when DP is disabled
      isDraft: !params?.data?.publishedAt,
      locale: params?.locale,
    });

    // Component handling
    const componentData = await components.createComponents(uid, validData);
    const dataWithComponents = components.assignComponentData(
      contentType,
      componentData,
      validData
    );

    const entryData = applyTransforms(contentType, dataWithComponents);

    const doc = await strapi.db.query(uid).create({ ...query, data: entryData });

    return doc;
  }

  async function deleteEntry(id: number) {
    const componentsToDelete = await components.getComponents(uid, { id });

    const deletedEntry = await strapi.db.query(uid).delete({ where: { id } });

    await components.deleteComponents(uid, componentsToDelete as any, { loadComponents: false });

    return deletedEntry;
  }

  async function updateEntry(entryToUpdate: any, params = {} as any) {
    const { data, ...restParams } = await transformParamsDocumentId(uid, params);
    const query = transformParamsToQuery(uid, pickSelectionParams(restParams) as any); // select / populate

    const validData = await entityValidator.validateEntityUpdate(
      contentType,
      data,
      {
        isDraft: !params?.data?.publishedAt, // Always update the draft version
        locale: params?.locale,
      },
      entryToUpdate
    );
    // Component handling
    const componentData = await components.updateComponents(uid, entryToUpdate, validData as any);
    const dataWithComponents = components.assignComponentData(
      contentType,
      componentData,
      validData
    );

    const entryData = applyTransforms(contentType, dataWithComponents);

    return strapi.db
      .query(uid)
      .update({ ...query, where: { id: entryToUpdate.id }, data: entryData });
  }

  async function publishEntry(entry: any, params = {} as any) {
    return async.pipe(
      omit('id'),
      assoc('publishedAt', new Date()),
      (draft) => {
        const opts = { uid, locale: draft.locale, status: 'published', allowMissingId: true };
        return transformData(draft, opts);
      },
      // Create the published entry
      (draft) => createEntry({ ...params, data: draft, locale: draft.locale, status: 'published' })
    )(entry);
  }

  async function discardDraftEntry(entry: any, params = {} as any) {
    return async.pipe(
      omit('id'),
      assoc('publishedAt', null),
      (entry) => {
        const opts = { uid, locale: entry.locale, status: 'draft', allowMissingId: true };
        return transformData(entry, opts);
      },
      // Create the draft entry
      (data) => createEntry({ ...params, locale: data.locale, data, status: 'draft' })
    )(entry);
  }

  return {
    create: createEntry,
    delete: deleteEntry,
    update: updateEntry,
    publish: publishEntry,
    discardDraft: discardDraftEntry,
  };
};

export { createEntriesService };
</file>

<file path="src/services/document-service/events.ts">
import type { UID, Utils, Modules, Core } from '@strapi/types';
import { sanitize } from '@strapi/utils';

import { getDeepPopulate } from './utils/populate';

const EVENTS = {
  ENTRY_CREATE: 'entry.create',
  ENTRY_UPDATE: 'entry.update',
  ENTRY_DELETE: 'entry.delete',
  ENTRY_PUBLISH: 'entry.publish',
  ENTRY_UNPUBLISH: 'entry.unpublish',
  ENTRY_DRAFT_DISCARD: 'entry.draft-discard',
};

type EventName = Utils.Object.Values<typeof EVENTS>;

/**
 * Manager to trigger entry related events
 *
 * It will populate the entry if it is not a delete event.
 * So the event payload will contain the full entry.
 */
const createEventManager = (strapi: Core.Strapi, uid: UID.Schema) => {
  const populate = getDeepPopulate(uid, {});
  const model = strapi.getModel(uid);

  const emitEvent = async (eventName: EventName, entry: Modules.Documents.AnyDocument) => {
    // There is no need to populate the entry if it has been deleted
    let populatedEntry = entry;
    if (![EVENTS.ENTRY_DELETE, EVENTS.ENTRY_UNPUBLISH].includes(eventName)) {
      populatedEntry = await strapi.db.query(uid).findOne({ where: { id: entry.id }, populate });
    }

    const sanitizedEntry = await sanitize.sanitizers.defaultSanitizeOutput(
      {
        schema: model,
        getModel: (uid) => strapi.getModel(uid as UID.Schema),
      },
      populatedEntry
    );

    await strapi.eventHub.emit(eventName, {
      model: model.modelName,
      uid: model.uid,
      entry: sanitizedEntry,
    });
  };

  return {
    /**
     * strapi.db.query might reuse the transaction used in the doc service request,
     * so this is executed after that transaction is committed.
     */
    emitEvent(eventName: EventName, entry: Modules.Documents.AnyDocument) {
      strapi.db.transaction(({ onCommit }) => {
        onCommit(() => emitEvent(eventName, entry));
      });
    },
  };
};

export { createEventManager };
</file>

<file path="src/services/document-service/index.ts">
import type { Core, Modules, UID } from '@strapi/types';

import { createMiddlewareManager, databaseErrorsMiddleware } from './middlewares';
import { createContentTypeRepository } from './repository';
import { transformData } from './transform/data';

import entityValidator from '../entity-validator';

/**
 * Repository to :
 * - Access documents via actions (findMany, findOne, create, update, delete, ...)
 * - Execute middlewares on document actions
 * - Apply default parameters to document actions
 *
 * @param strapi
 * @param validator - validator for database entries
 * @returns DocumentService
 *
 * @example Access documents
 * const article = strapi.documents('api::article.article').create(params)
 * const allArticles = strapi.documents('api::article.article').findMany(params)
 *
 */
export const createDocumentService = (
  strapi: Core.Strapi,
  validator: Modules.EntityValidator.EntityValidator = entityValidator
): Modules.Documents.Service => {
  // Cache the repositories (one per content type)
  const repositories = new Map<string, Modules.Documents.ServiceInstance>();

  // Manager to handle document service middlewares
  const middlewares = createMiddlewareManager();
  middlewares.use(databaseErrorsMiddleware);

  const factory = function factory(uid: UID.ContentType) {
    if (repositories.has(uid)) {
      return repositories.get(uid)!;
    }

    const contentType = strapi.contentType(uid);
    const repository = createContentTypeRepository(uid, validator);

    const instance = middlewares.wrapObject(
      repository,
      { uid, contentType },
      {
        exclude: ['updateComponents', 'omitComponentData'],
      }
    );

    repositories.set(uid, instance);

    return instance;
  } as Modules.Documents.Service;

  return Object.assign(factory, {
    utils: {
      transformData,
    },
    use: middlewares.use.bind(middlewares),
  });
};
</file>

<file path="src/services/document-service/internationalization.ts">
import type { Struct, Modules } from '@strapi/types';
import { errors } from '@strapi/utils';
import { curry, assoc } from 'lodash/fp';

type Transform = (
  contentType: Struct.SingleTypeSchema | Struct.CollectionTypeSchema,
  params: Modules.Documents.Params.All
) => Modules.Documents.Params.All;

type AsyncTransform = (
  contentType: Struct.SingleTypeSchema | Struct.CollectionTypeSchema,
  params: Modules.Documents.Params.All
) => Promise<Modules.Documents.Params.All>;

const getDefaultLocale = async (): Promise<string> => {
  return strapi.plugin('i18n').service('locales').getDefaultLocale();
};

const defaultLocale: AsyncTransform = async (contentType, params) => {
  if (!strapi.plugin('i18n').service('content-types').isLocalizedContentType(contentType)) {
    return params;
  }

  if (!params.locale) {
    return assoc('locale', await getDefaultLocale(), params);
  }

  return params;
};

/**
 * Add locale lookup query to the params
 */
const localeToLookup: Transform = (contentType, params) => {
  if (
    !params.locale ||
    !strapi.plugin('i18n').service('content-types').isLocalizedContentType(contentType)
  ) {
    return params;
  }

  if (typeof params.locale !== 'string') {
    // localeToLookup accepts locales of '*'. This is because the document
    // service functions that use this transform work with the '*' locale
    // to return all locales.
    throw new errors.ValidationError(
      `Invalid locale param ${String(params.locale)} provided. Document locales must be strings.`
    );
  }

  return assoc(['lookup', 'locale'], params.locale, params);
};

/**
 * Add locale lookup query to the params
 */
const multiLocaleToLookup: Transform = (contentType, params) => {
  if (!strapi.plugin('i18n').service('content-types').isLocalizedContentType(contentType)) {
    return params;
  }

  if (params.locale) {
    if (params.locale === '*') {
      return params;
    }

    return assoc(['lookup', 'locale'], params.locale, params);
  }

  return params;
};

/**
 * Translate locale status parameter into the data that will be saved
 */
const localeToData: Transform = (contentType, params) => {
  if (!strapi.plugin('i18n').service('content-types').isLocalizedContentType(contentType)) {
    return params;
  }

  if (params.locale) {
    const isValidLocale = typeof params.locale === 'string' && params.locale !== '*';
    if (isValidLocale) {
      return assoc(['data', 'locale'], params.locale, params);
    }

    throw new errors.ValidationError(
      `Invalid locale param ${params.locale} provided. Document locales must be strings.`
    );
  }

  return params;
};

const defaultLocaleCurry = curry(defaultLocale);
const localeToLookupCurry = curry(localeToLookup);
const multiLocaleToLookupCurry = curry(multiLocaleToLookup);
const localeToDataCurry = curry(localeToData);

export {
  defaultLocaleCurry as defaultLocale,
  localeToLookupCurry as localeToLookup,
  localeToDataCurry as localeToData,
  multiLocaleToLookupCurry as multiLocaleToLookup,
};
</file>

<file path="src/services/document-service/params.ts">
import { pick } from 'lodash/fp';
import type { UID, Modules } from '@strapi/types';

const pickSelectionParams = <TUID extends UID.ContentType>(
  data: unknown
): Modules.Documents.Params.Pick<TUID, 'fields' | 'populate' | 'status'> => {
  return pick(['fields', 'populate', 'status'], data);
};

export { pickSelectionParams };
</file>

<file path="src/services/document-service/repository.ts">
import { omit, assoc, merge, curry } from 'lodash/fp';

import { async, contentTypes as contentTypesUtils, validate, errors } from '@strapi/utils';

import type { UID } from '@strapi/types';
import { wrapInTransaction, type RepositoryFactoryMethod } from './common';
import * as DP from './draft-and-publish';
import * as i18n from './internationalization';
import * as components from './components';

import { createEntriesService } from './entries';
import { pickSelectionParams } from './params';
import { createDocumentId } from '../../utils/transform-content-types-to-models';
import { getDeepPopulate } from './utils/populate';
import { transformParamsToQuery } from './transform/query';
import { transformParamsDocumentId } from './transform/id-transform';
import { createEventManager } from './events';
import * as unidirectionalRelations from './utils/unidirectional-relations';
import entityValidator from '../entity-validator';

const { validators } = validate;

// we have to typecast to reconcile the differences between validator and database getModel
const getModel = ((schema: UID.Schema) => strapi.getModel(schema)) as (schema: string) => any;

export const createContentTypeRepository: RepositoryFactoryMethod = (
  uid,
  validator = entityValidator
) => {
  const contentType = strapi.contentType(uid);
  const hasDraftAndPublish = contentTypesUtils.hasDraftAndPublish(contentType);

  // Define the validations that should be performed
  const sortValidations = ['nonAttributesOperators', 'dynamicZones', 'morphRelations'];
  const fieldValidations = ['scalarAttributes'];
  const filtersValidations = ['nonAttributesOperators', 'dynamicZones', 'morphRelations'];
  const populateValidations = {
    sort: sortValidations,
    field: fieldValidations,
    filters: filtersValidations,
    populate: ['nonAttributesOperators'],
  };

  const validateParams = async (params: any) => {
    const ctx = { schema: contentType, getModel };
    await validators.validateFilters(ctx, params.filters, filtersValidations);
    await validators.validateSort(ctx, params.sort, sortValidations);
    await validators.validateFields(ctx, params.fields, fieldValidations);
    await validators.validatePopulate(ctx, params.populate, populateValidations);

    // Strip lookup from params, it's only used internally
    if (params.lookup) {
      throw new errors.ValidationError("Invalid params: 'lookup'");
    }

    // TODO: add validate status, locale, pagination

    return params;
  };

  const entries = createEntriesService(uid, validator);

  const eventManager = createEventManager(strapi, uid);
  const emitEvent = curry(eventManager.emitEvent);

  async function findMany(params = {} as any) {
    const query = await async.pipe(
      validateParams,
      DP.defaultToDraft,
      DP.statusToLookup(contentType),
      i18n.defaultLocale(contentType),
      i18n.multiLocaleToLookup(contentType),
      transformParamsDocumentId(uid),
      transformParamsToQuery(uid)
    )(params || {});

    return strapi.db.query(uid).findMany(query);
  }

  async function findFirst(params = {} as any) {
    const query = await async.pipe(
      validateParams,
      DP.defaultToDraft,
      DP.statusToLookup(contentType),
      i18n.defaultLocale(contentType),
      i18n.localeToLookup(contentType),
      transformParamsDocumentId(uid),
      transformParamsToQuery(uid)
    )(params);

    return strapi.db.query(uid).findOne(query);
  }

  // TODO: do we really want to add filters on the findOne now that we have findFirst ?
  async function findOne(opts = {} as any) {
    const { documentId, ...params } = opts;

    const query = await async.pipe(
      validateParams,
      DP.defaultToDraft,
      DP.statusToLookup(contentType),
      i18n.defaultLocale(contentType),
      i18n.localeToLookup(contentType),
      transformParamsDocumentId(uid),
      transformParamsToQuery(uid),
      (query) => assoc('where', { ...query.where, documentId }, query)
    )(params);

    return strapi.db.query(uid).findOne(query);
  }

  async function deleteDocument(opts = {} as any) {
    const { documentId, ...params } = opts;

    const query = await async.pipe(
      validateParams,
      omit('status'),
      i18n.defaultLocale(contentType),
      i18n.multiLocaleToLookup(contentType),
      transformParamsToQuery(uid),
      (query) => assoc('where', { ...query.where, documentId }, query)
    )(params);

    if (params.status === 'draft') {
      throw new Error('Cannot delete a draft document');
    }

    const entriesToDelete = await strapi.db.query(uid).findMany(query);

    // Delete all matched entries and its components
    const deletedEntries = await async.map(entriesToDelete, (entryToDelete: any) =>
      entries.delete(entryToDelete.id)
    );

    entriesToDelete.forEach(emitEvent('entry.delete'));

    return { documentId, entries: deletedEntries };
  }

  async function create(opts = {} as any) {
    const { documentId, ...params } = opts;

    const queryParams = await async.pipe(
      validateParams,
      DP.filterDataPublishedAt,
      DP.setStatusToDraft(contentType),
      DP.statusToData(contentType),
      i18n.defaultLocale(contentType),
      i18n.localeToData(contentType)
    )(params);

    const doc = await entries.create(queryParams);

    emitEvent('entry.create', doc);

    if (hasDraftAndPublish && params.status === 'published') {
      return publish({
        ...params,
        documentId: doc.documentId,
      }).then((doc) => doc.entries[0]);
    }

    return doc;
  }

  async function clone(opts = {} as any) {
    const { documentId, ...params } = opts;

    const queryParams = await async.pipe(
      validateParams,
      DP.filterDataPublishedAt,
      i18n.defaultLocale(contentType),
      i18n.multiLocaleToLookup(contentType)
    )(params);

    // Get deep populate
    const entriesToClone = await strapi.db.query(uid).findMany({
      where: {
        ...queryParams?.lookup,
        documentId,
        // DP Enabled: Clone drafts
        // DP Disabled: Clone only the existing version (published)
        publishedAt: { $null: hasDraftAndPublish },
      },
      populate: getDeepPopulate(uid, { relationalFields: ['id'] }),
    });

    const clonedEntries = await async.map(
      entriesToClone,
      async.pipe(
        validateParams,
        omit(['id', 'createdAt', 'updatedAt']),
        // assign new documentId
        assoc('documentId', createDocumentId()),
        // Merge new data into it
        (data) => merge(data, queryParams.data),
        (data) => entries.create({ ...queryParams, data, status: 'draft' })
      )
    );

    clonedEntries.forEach(emitEvent('entry.create'));

    return { documentId: clonedEntries.at(0)?.documentId, entries: clonedEntries };
  }

  async function update(opts = {} as any) {
    const { documentId, ...params } = opts;

    const queryParams = await async.pipe(
      validateParams,
      DP.filterDataPublishedAt,
      DP.setStatusToDraft(contentType),
      DP.statusToLookup(contentType),
      DP.statusToData(contentType),
      // Default locale will be set if not provided
      i18n.defaultLocale(contentType),
      i18n.localeToLookup(contentType),
      i18n.localeToData(contentType)
    )(params);

    const { data, ...restParams } = await transformParamsDocumentId(uid, queryParams || {});
    const query = transformParamsToQuery(uid, pickSelectionParams(restParams || {}) as any);

    // Validation
    // Find if document exists
    const entryToUpdate = await strapi.db
      .query(uid)
      .findOne({ ...query, where: { ...queryParams?.lookup, ...query?.where, documentId } });

    let updatedDraft = null;
    if (entryToUpdate) {
      updatedDraft = await entries.update(entryToUpdate, queryParams);
      emitEvent('entry.update', updatedDraft);
    }

    if (!updatedDraft) {
      const documentExists = await strapi.db
        .query(contentType.uid)
        .findOne({ where: { documentId } });

      if (documentExists) {
        updatedDraft = await entries.create({
          ...queryParams,
          data: { ...queryParams.data, documentId },
        });
        emitEvent('entry.create', updatedDraft);
      }
    }

    if (hasDraftAndPublish && updatedDraft && params.status === 'published') {
      return publish({
        ...params,
        documentId,
      }).then((doc) => doc.entries[0]);
    }

    return updatedDraft;
  }

  async function count(params = {} as any) {
    const query = await async.pipe(
      validateParams,
      DP.defaultStatus(contentType),
      DP.statusToLookup(contentType),
      i18n.defaultLocale(contentType),
      i18n.localeToLookup(contentType),
      transformParamsToQuery(uid)
    )(params);

    return strapi.db.query(uid).count(query);
  }

  async function publish(opts = {} as any) {
    const { documentId, ...params } = opts;

    const queryParams = await async.pipe(
      validateParams,
      i18n.defaultLocale(contentType),
      i18n.multiLocaleToLookup(contentType)
    )(params);

    const [draftsToPublish, oldPublishedVersions] = await Promise.all([
      strapi.db.query(uid).findMany({
        where: {
          ...queryParams?.lookup,
          documentId,
          publishedAt: null, // Ignore lookup
        },
        // Populate relations, media, compos and dz
        populate: getDeepPopulate(uid, { relationalFields: ['documentId', 'locale'] }),
      }),
      strapi.db.query(uid).findMany({
        where: {
          ...queryParams?.lookup,
          documentId,
          publishedAt: { $ne: null },
        },
        select: ['id', 'locale'],
      }),
    ]);

    // Load any unidirectional relation targetting the old published entries
    const relationsToSync = await unidirectionalRelations.load(uid, {
      newVersions: draftsToPublish,
      oldVersions: oldPublishedVersions,
    });

    // Delete old published versions
    await async.map(oldPublishedVersions, (entry: any) => entries.delete(entry.id));

    // Transform draft entry data and create published versions
    const publishedEntries = await async.map(draftsToPublish, (draft: any) =>
      entries.publish(draft, queryParams)
    );

    // Sync unidirectional relations with the new published entries
    await unidirectionalRelations.sync(
      [...oldPublishedVersions, ...draftsToPublish],
      publishedEntries,
      relationsToSync
    );

    publishedEntries.forEach(emitEvent('entry.publish'));

    return { documentId, entries: publishedEntries };
  }

  async function unpublish(opts = {} as any) {
    const { documentId, ...params } = opts;

    const query = await async.pipe(
      validateParams,
      i18n.defaultLocale(contentType),
      i18n.multiLocaleToLookup(contentType),
      transformParamsToQuery(uid),
      (query) => assoc('where', { ...query.where, documentId, publishedAt: { $ne: null } }, query)
    )(params);

    // Delete all published versions
    const versionsToDelete = await strapi.db.query(uid).findMany(query);
    await async.map(versionsToDelete, (entry: any) => entries.delete(entry.id));

    versionsToDelete.forEach(emitEvent('entry.unpublish'));
    return { documentId, entries: versionsToDelete };
  }

  async function discardDraft(opts = {} as any) {
    const { documentId, ...params } = opts;

    const queryParams = await async.pipe(
      validateParams,
      i18n.defaultLocale(contentType),
      i18n.multiLocaleToLookup(contentType)
    )(params);

    const [versionsToDraft, oldDrafts] = await Promise.all([
      strapi.db.query(uid).findMany({
        where: {
          ...queryParams?.lookup,
          documentId,
          publishedAt: { $ne: null },
        },
        // Populate relations, media, compos and dz
        populate: getDeepPopulate(uid, { relationalFields: ['documentId', 'locale'] }),
      }),
      strapi.db.query(uid).findMany({
        where: {
          ...queryParams?.lookup,
          documentId,
          publishedAt: null,
        },
        select: ['id', 'locale'],
      }),
    ]);

    // Load any unidirectional relation targeting the old drafts
    const relationsToSync = await unidirectionalRelations.load(uid, {
      newVersions: versionsToDraft,
      oldVersions: oldDrafts,
    });

    // Delete old drafts
    await async.map(oldDrafts, (entry: any) => entries.delete(entry.id));

    // Transform published entry data and create draft versions
    const draftEntries = await async.map(versionsToDraft, (entry: any) =>
      entries.discardDraft(entry, queryParams)
    );

    // Sync unidirectional relations with the new draft entries
    await unidirectionalRelations.sync(
      [...oldDrafts, ...versionsToDraft],
      draftEntries,
      relationsToSync
    );

    draftEntries.forEach(emitEvent('entry.draft-discard'));
    return { documentId, entries: draftEntries };
  }

  async function updateComponents(entry: any, data: any) {
    return components.updateComponents(uid, entry, data);
  }

  function omitComponentData(data: any) {
    return components.omitComponentData(contentType, data);
  }

  return {
    findMany: wrapInTransaction(findMany),
    findFirst: wrapInTransaction(findFirst),
    findOne: wrapInTransaction(findOne),
    delete: wrapInTransaction(deleteDocument),
    create: wrapInTransaction(create),
    clone: wrapInTransaction(clone),
    update: wrapInTransaction(update),
    count: wrapInTransaction(count),
    publish: hasDraftAndPublish ? wrapInTransaction(publish) : (undefined as any),
    unpublish: hasDraftAndPublish ? wrapInTransaction(unpublish) : (undefined as any),
    discardDraft: hasDraftAndPublish ? wrapInTransaction(discardDraft) : (undefined as any),

    updateComponents,
    omitComponentData,
  };
};
</file>

<file path="src/services/entity-service/__tests__/entity-service.test.ts">
import type { Utils } from '@strapi/types';
import createEntityService from '../index';

jest.mock('bcryptjs', () => ({ hashSync: () => 'secret-password' }));

describe('Entity service', () => {
  global.strapi = {
    getModel: jest.fn(() => ({})),
    config: {
      get() {
        return [];
      },
    },
    query: jest.fn(() => ({})),
    webhookStore: {
      allowedEvents: new Map([['ENTRY_CREATE', 'entry.create']]),
      addAllowedEvent: jest.fn(),
    },
  } as any;

  describe('Decorator', () => {
    test.each(['create', 'update', 'findMany', 'findOne', 'delete', 'count'] as const)(
      'Can decorate',
      async (method) => {
        const instance = createEntityService({
          strapi: global.strapi,
          db: {} as any,
        });

        const methodFn = jest.fn();

        instance.decorate((old) => ({
          ...old,
          [method]: methodFn,
        }));

        const args = [{}, {}];
        await (instance[method] as Utils.Function.Any)(...args);
        expect(methodFn).toHaveBeenCalled();
      }
    );
  });

  describe('Find', () => {
    test('Returns first element for single types', async () => {
      const data = {
        id: 1,
        title: 'Test',
      };

      const fakeDocumentService = {
        findFirst: jest.fn(() => Promise.resolve(data)),
      };

      const fakeStrapi = {
        ...global.strapi,
        documents: jest.fn(() => fakeDocumentService),
        getModel: jest.fn(() => {
          return { kind: 'singleType' };
        }),
      };

      const instance = createEntityService({
        strapi: fakeStrapi as any,
        db: {} as any,
      });

      const result = await instance.findMany('api::test.test-model');

      expect(fakeStrapi.getModel).toHaveBeenCalledTimes(1);
      expect(fakeStrapi.getModel).toHaveBeenCalledWith('api::test.test-model');

      expect(fakeStrapi.documents).toHaveBeenCalledWith('api::test.test-model');
      expect(fakeDocumentService.findFirst).toHaveBeenCalledWith({});
      expect(result).toEqual(data);
    });
  });
});
</file>

<file path="src/services/entity-service/index.ts">
import _ from 'lodash';
import delegate from 'delegates';
import { errors as databaseErrors } from '@strapi/database';
import {
  contentTypes as contentTypesUtils,
  errors,
  relations as relationUtils,
} from '@strapi/utils';
import type { Database } from '@strapi/database';
import type { Core, Modules, Utils } from '@strapi/types';

type Decoratable<T> = T & {
  decorate(
    decorator: (old: Modules.EntityService.EntityService) => Modules.EntityService.EntityService & {
      [key: string]: unknown;
    }
  ): void;
};

const transformLoadParamsToQuery = (
  uid: string,
  field: string,
  params: Record<string, unknown>,
  pagination = {}
) => {
  const query = strapi
    .get('query-params')
    .transform(uid, { populate: { [field]: params } as any }) as any;

  const res = {
    ...query.populate[field],
    ...pagination,
  };

  return res;
};

const databaseErrorsToTransform = [
  databaseErrors.InvalidTimeError,
  databaseErrors.InvalidDateTimeError,
  databaseErrors.InvalidDateError,
  databaseErrors.InvalidRelationError,
];

const createDefaultImplementation = ({
  strapi,
  db,
}: {
  strapi: Core.Strapi;
  db: Database;
}): Modules.EntityService.EntityService => ({
  async wrapParams(options: any = {}) {
    return options;
  },

  async wrapResult(result: any = {}) {
    return result;
  },

  async findMany(uid, opts) {
    const { kind } = strapi.getModel(uid);

    const wrappedParams = await this.wrapParams(opts, { uid, action: 'findMany' });

    if (kind === 'singleType') {
      const entity = strapi.documents!(uid).findFirst(wrappedParams);
      return this.wrapResult(entity, { uid, action: 'findOne' });
    }

    const entities = await strapi.documents!(uid).findMany(wrappedParams);
    return this.wrapResult(entities, { uid, action: 'findMany' });
  },

  async findPage(uid, opts) {
    const wrappedParams = await this.wrapParams(opts, { uid, action: 'findPage' });

    const query = strapi.get('query-params').transform(uid, wrappedParams);

    const entities = await db.query(uid).findPage(query);
    return this.wrapResult(entities, { uid, action: 'findMany' });
  },

  async findOne(uid, entityId, opts) {
    const wrappedParams = await this.wrapParams(opts, { uid, action: 'findOne' });

    const res = await db.query(uid).findOne({ where: { id: entityId } });

    if (!res) {
      return this.wrapResult(null, { uid, action: 'findOne' });
    }

    const entity = await strapi.documents!(uid).findOne({
      ...wrappedParams,
      documentId: res.documentId,
    });
    return this.wrapResult(entity, { uid, action: 'findOne' });
  },

  async count(uid, opts) {
    const wrappedParams = await this.wrapParams(opts, { uid, action: 'count' });

    return strapi.documents!(uid).count(wrappedParams);
  },

  async create(uid, params) {
    const wrappedParams = await this.wrapParams<
      Modules.EntityService.Params.Pick<typeof uid, 'data' | 'fields' | 'populate'>
    >(params, { uid, action: 'create' });
    const { data } = wrappedParams;

    if (!data) {
      throw new Error('cannot create');
    }

    const shouldPublish = !contentTypesUtils.isDraft(data, strapi.getModel(uid));

    const entity = await strapi.documents!(uid).create({
      ...(wrappedParams as any),
      status: shouldPublish ? 'published' : 'draft',
    });

    return this.wrapResult(entity, { uid, action: 'create' });
  },

  async update(uid, entityId, opts) {
    const wrappedParams = await this.wrapParams<
      Modules.EntityService.Params.Pick<typeof uid, 'data:partial' | 'fields' | 'populate'>
    >(opts, {
      uid,
      action: 'update',
    });
    const entityToUpdate = await db.query(uid).findOne({ where: { id: entityId } });

    if (!entityToUpdate) {
      return this.wrapResult(null, { uid, action: 'update' });
    }

    const shouldPublish = !contentTypesUtils.isDraft(entityToUpdate, strapi.getModel(uid));

    const entity = strapi.documents!(uid).update({
      ...(wrappedParams as any),
      status: shouldPublish ? 'published' : 'draft',
      documentId: entityToUpdate.documentId,
    });

    return this.wrapResult(entity, { uid, action: 'update' });
  },

  async delete(uid, entityId, opts) {
    const wrappedParams = await this.wrapParams(opts, { uid, action: 'delete' });

    const entityToDelete = await db.query(uid).findOne({ where: { id: entityId } });

    if (!entityToDelete) {
      return this.wrapResult(null, { uid, action: 'delete' });
    }

    await strapi.documents!(uid).delete({
      ...wrappedParams,
      documentId: entityToDelete.documentId,
    });

    return this.wrapResult(entityToDelete, { uid, action: 'delete' });
  },

  async load(uid, entity, field, params) {
    if (!_.isString(field)) {
      throw new Error(`Invalid load. Expected "${field}" to be a string`);
    }

    const loadedEntity = await db
      .query(uid)
      .load(entity, field, transformLoadParamsToQuery(uid, field, params ?? {}));

    return this.wrapResult(loadedEntity, { uid, field, action: 'load' });
  },

  async loadPages(uid, entity, field, params, pagination = {}) {
    if (!_.isString(field)) {
      throw new Error(`Invalid load. Expected "${field}" to be a string`);
    }

    const { attributes } = strapi.getModel(uid);
    const attribute = attributes[field];

    if (!relationUtils.isAnyToMany(attribute)) {
      throw new Error(`Invalid load. Expected "${field}" to be an anyToMany relational attribute`);
    }

    const query = transformLoadParamsToQuery(uid, field, params ?? {}, pagination);

    const loadedPage = await db.query(uid).loadPages(entity, field, query);

    return {
      ...loadedPage,
      results: await this.wrapResult(loadedPage.results, { uid, field, action: 'load' }),
    };
  },
});

export default (ctx: {
  strapi: Core.Strapi;
  db: Database;
}): Decoratable<Modules.EntityService.EntityService> => {
  const implementation = createDefaultImplementation(ctx);

  const service = {
    implementation,
    decorate<T extends object>(decorator: (current: typeof implementation) => T) {
      if (typeof decorator !== 'function') {
        throw new Error(`Decorator must be a function, received ${typeof decorator}`);
      }

      this.implementation = { ...this.implementation, ...decorator(this.implementation) };
      return this;
    },
  };

  const delegator = delegate(service, 'implementation');

  // delegate every method in implementation
  Object.keys(service.implementation).forEach((key) => delegator.method(key));

  // wrap methods to handle Database Errors
  service.decorate((oldService: Modules.EntityService.EntityService) => {
    const newService = _.mapValues(
      oldService,
      (method, methodName: keyof Modules.EntityService.EntityService) =>
        async function (this: Modules.EntityService.EntityService, ...args: []) {
          try {
            return await (oldService[methodName] as Utils.Function.AnyPromise).call(this, ...args);
          } catch (error) {
            if (
              databaseErrorsToTransform.some(
                (errorToTransform) => error instanceof errorToTransform
              )
            ) {
              if (error instanceof Error) {
                throw new errors.ValidationError(error.message);
              }

              throw error;
            }
            throw error;
          }
        }
    );

    return newService;
  });

  return service as unknown as Decoratable<Modules.EntityService.EntityService>;
};
</file>

<file path="src/services/entity-validator/__tests__/relations/utils/relations.testdata.ts">
export const models = new Map();

models.set('api::dev.dev', {
  kind: 'collectionType',
  collectionName: 'devs',
  modelType: 'contentType',
  modelName: 'dev',
  uid: 'api::dev.dev',
  apiName: 'dev',
  globalId: 'Dev',
  info: {
    singularName: 'dev',
    pluralName: 'devs',
    displayName: 'Dev',
    description: '',
  },
  attributes: {
    categories: {
      type: 'relation',
      relation: 'manyToMany',
      target: 'api::category.category',
      inversedBy: 'devs',
    },
    sCom: {
      type: 'component',
      repeatable: false,
      component: 'basic.dev-compo',
    },
    rCom: {
      type: 'component',
      repeatable: true,
      component: 'basic.dev-compo',
    },
    DZ: {
      type: 'dynamiczone',
      components: ['basic.dev-compo'],
    },
    media: {
      allowedTypes: ['images', 'files', 'videos', 'audios'],
      type: 'media',
      multiple: true,
    },
    createdAt: {
      type: 'datetime',
    },
    updatedAt: {
      type: 'datetime',
    },
    publishedAt: {
      type: 'datetime',
      configurable: false,
      writable: true,
      visible: false,
    },
    createdBy: {
      type: 'relation',
      relation: 'oneToOne',
      target: 'admin::user',
      configurable: false,
      writable: false,
      visible: false,
      useJoinTable: false,
      private: true,
    },
    updatedBy: {
      type: 'relation',
      relation: 'oneToOne',
      target: 'admin::user',
      configurable: false,
      writable: false,
      visible: false,
      useJoinTable: false,
      private: true,
    },
  },
});
models.set('api::category.category', {
  kind: 'collectionType',
  collectionName: 'categories',
  modelType: 'contentType',
  modelName: 'category',
  uid: 'api::category.category',
  apiName: 'category',
  globalId: 'Category',
  info: {
    displayName: 'Category',
    singularName: 'category',
    pluralName: 'categories',
    description: '',
    name: 'Category',
  },
  attributes: {
    name: {
      type: 'string',
      pluginOptions: {
        i18n: {
          localized: true,
        },
      },
    },
  },
});
models.set('basic.dev-compo', {
  collectionName: 'components_basic_dev_compos',
  uid: 'basic.dev-compo',
  category: 'basic',
  modelType: 'component',
  modelName: 'dev-compo',
  globalId: 'ComponentBasicDevCompo',
  info: {
    displayName: 'DevCompo',
    icon: 'allergies',
  },
  attributes: {
    categories: {
      type: 'relation',
      relation: 'oneToMany',
      target: 'api::category.category',
    },
  },
});
models.set('plugin::upload.file', {
  collectionName: 'files',
  info: {
    singularName: 'file',
    pluralName: 'files',
    displayName: 'File',
    description: '',
  },
  attributes: {
    name: {
      type: 'string',
      configurable: false,
      required: true,
    },
  },
  kind: 'collectionType',
  modelType: 'contentType',
  modelName: 'file',
  uid: 'plugin::upload.file',
  plugin: 'upload',
  globalId: 'UploadFile',
});

export const existentIDs = [1, 2, 3, 4, 5, 6];
export const nonExistentIds = [10, 11, 12, 13, 14, 15, 16];
</file>

<file path="src/services/entity-validator/__tests__/relations/attribute-level.test.ts">
import { errors } from '@strapi/utils';
import type { Common, EntityService } from '@strapi/types';

import entityValidator from '../..';
import { models, existentIDs, nonExistentIds } from './utils/relations.testdata';

/**
 * Test that relations can be successfully validated and non existent relations
 * can be detected at the Attribute level.
 */
describe('Entity validator | Relations | Attribute', () => {
  global.strapi = {
    components: {
      'basic.dev-compo': {},
    },
    db: {
      query() {
        return {
          count: ({
            where: {
              id: { $in },
            },
          }: any) => existentIDs.filter((value) => $in.includes(value)).length,
        };
      },
    },
    errors: {
      badRequest: jest.fn(),
    },
    getModel: (uid: string) => models.get(uid),
  } as any;

  describe('Success', () => {
    const testData: Array<[string, EntityService.Params.Data.Input<Common.UID.ContentType>]> = [
      [
        'Connect',
        {
          categories: {
            disconnect: [],
            connect: [
              {
                id: existentIDs[0],
              },
            ],
          },
        },
      ],
      [
        'Set',
        {
          categories: {
            set: [
              {
                id: existentIDs[0],
              },
            ],
          },
        },
      ],
      [
        'Number',
        {
          categories: existentIDs[0],
        },
      ],
      [
        'Array',
        {
          categories: existentIDs.slice(-Math.floor(existentIDs.length / 2)),
        },
      ],
    ];

    test.each(testData)('%s', async (__, input = {}) => {
      const res = entityValidator.validateEntityCreation(models.get('api::dev.dev'), input, {
        isDraft: true,
      });
      await expect(res).resolves.not.toThrowError();
    });
  });

  describe('Error', () => {
    const expectError = new errors.ValidationError(
      `2 relation(s) of type api::category.category associated with this entity do not exist`
    );
    const testData: Array<[string, EntityService.Params.Data.Input<Common.UID.ContentType>]> = [
      [
        'Connect',
        {
          categories: {
            disconnect: [],
            connect: [existentIDs[0], ...nonExistentIds.slice(-2)].map((id) => ({
              id,
            })),
          },
        },
      ],
      [
        'Set',
        {
          categories: {
            set: [existentIDs[0], ...nonExistentIds.slice(-2)].map((id) => ({ id })),
          },
        },
      ],
      [
        'Number',
        {
          categories: nonExistentIds.slice(-2),
        },
      ],
    ];

    test.each(testData)('%s', async (__, input = {}) => {
      const res = entityValidator.validateEntityCreation(models.get('api::dev.dev'), input, {
        isDraft: true,
      });
      await expect(res).rejects.toThrowError(expectError);
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/relations/component-level.test.ts">
import { errors } from '@strapi/utils';

import entityValidator from '../..';
import { models, existentIDs, nonExistentIds } from './utils/relations.testdata';

/**
 * Test that relations can be successfully validated and non existent relations
 * can be detected at the Component level.
 */
describe('Entity validator | Relations | Component Level', () => {
  global.strapi = {
    components: {
      'basic.dev-compo': {},
    },

    db: {
      query() {
        return {
          count: ({
            where: {
              id: { $in },
            },
          }: any) => existentIDs.filter((value) => $in.includes(value)).length,
        };
      },
    },

    errors: {
      badRequest: jest.fn(),
    },
    getModel: (uid: string) => models.get(uid),
  } as any;

  describe('Single Component', () => {
    describe('Success', () => {
      const testData = [
        [
          'Connect',
          {
            sCom: {
              categories: {
                disconnect: [],
                connect: [
                  {
                    id: existentIDs[0],
                  },
                ],
              },
            },
          },
        ],
        [
          'Set',
          {
            sCom: {
              categories: {
                set: [
                  {
                    id: existentIDs[0],
                  },
                ],
              },
            },
          },
        ],
        [
          'Number',
          {
            sCom: {
              categories: existentIDs[0],
            },
          },
        ],
        [
          'Array',
          {
            sCom: {
              categories: existentIDs.slice(-3),
            },
          },
        ],
      ];

      test.each(testData)('%s', async (__, input = {}) => {
        const res = entityValidator.validateEntityCreation(models.get('api::dev.dev'), input, {
          isDraft: true,
        });
        await expect(res).resolves.not.toThrowError();
      });
    });

    describe('Error', () => {
      const expectedError = new errors.ValidationError(
        `1 relation(s) of type api::category.category associated with this entity do not exist`
      );
      const testData = [
        [
          'Connect',
          {
            sCom: {
              categories: {
                disconnect: [],
                connect: [
                  {
                    id: nonExistentIds[0],
                  },
                ],
              },
            },
          },
        ],
        [
          'Set',
          {
            sCom: {
              categories: {
                set: [
                  {
                    id: nonExistentIds[0],
                  },
                ],
              },
            },
          },
        ],
        [
          'Number',
          {
            sCom: {
              categories: nonExistentIds[0],
            },
          },
        ],
        [
          'Array',
          {
            sCom: {
              categories: [nonExistentIds[0]],
            },
          },
        ],
      ];

      test.each(testData)('%s', async (__, input = {}) => {
        global.strapi = strapi;
        const res = entityValidator.validateEntityCreation(models.get('api::dev.dev'), input, {
          isDraft: true,
        });
        await expect(res).rejects.toThrowError(expectedError);
      });
    });
  });

  describe('Repeatable Component', () => {
    describe('Success', () => {
      const testData = [
        [
          'Connect',
          {
            rCom: [
              {
                categories: {
                  disconnect: [],
                  connect: [
                    {
                      id: existentIDs[0],
                    },
                  ],
                },
              },
            ],
          },
        ],
        [
          'Set',
          {
            rCom: [
              {
                categories: {
                  set: existentIDs.slice(-Math.floor(existentIDs.length / 2)).map((id) => ({
                    id,
                  })),
                },
              },
            ],
          },
        ],
        [
          'Number',
          {
            rCom: [
              {
                categories: existentIDs[0],
              },
            ],
          },
        ],
        [
          'Array',
          {
            rCom: [
              {
                categories: existentIDs.slice(-Math.floor(existentIDs.length / 2)),
              },
            ],
          },
        ],
      ];

      test.each(testData)('%s', async (__, input = {}) => {
        global.strapi = strapi;
        const res = entityValidator.validateEntityCreation(models.get('api::dev.dev'), input, {
          isDraft: true,
        });
        await expect(res).resolves.not.toThrowError();
      });
    });

    describe('Error', () => {
      const expectedError = new errors.ValidationError(
        `4 relation(s) of type api::category.category associated with this entity do not exist`
      );
      const testData = [
        [
          'Connect',
          {
            rCom: [
              {
                categories: {
                  disconnect: [],
                  connect: [existentIDs[0], ...nonExistentIds.slice(-4)].map((id) => ({
                    id,
                  })),
                },
              },
            ],
          },
        ],
        [
          'Set',
          {
            rCom: [
              {
                categories: {
                  set: [existentIDs[0], ...nonExistentIds.slice(-4)].map((id) => ({
                    id,
                  })),
                },
              },
            ],
          },
        ],
        [
          'Array',
          {
            rCom: [
              {
                categories: nonExistentIds.slice(-4),
              },
            ],
          },
        ],
      ];

      test.each(testData)('%s', async (__, input = {}) => {
        const res = entityValidator.validateEntityCreation(models.get('api::dev.dev'), input, {
          isDraft: true,
        });
        await expect(res).rejects.toThrowError(expectedError);
      });
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/relations/dynamic-zone-level.test.ts">
import { errors } from '@strapi/utils';

import entityValidator from '../..';
import { models, existentIDs, nonExistentIds } from './utils/relations.testdata';

/**
 * Test that relations can be successfully validated and non existent relations
 * can be detected at the Dynamic Zone level.
 */
describe('Entity validator | Relations | Dynamic Zone', () => {
  global.strapi = {
    components: {
      'basic.dev-compo': {},
    },
    db: {
      query() {
        return {
          count: ({
            where: {
              id: { $in },
            },
          }: any) => existentIDs.filter((value) => $in.includes(value)).length,
        };
      },
    },
    errors: { badRequest: jest.fn() },
    getModel: (uid: string) => models.get(uid),
  } as any;

  describe('Success', () => {
    const testData = [
      [
        'Connect',
        {
          DZ: [
            {
              __component: 'basic.dev-compo',
              categories: {
                disconnect: [],
                connect: existentIDs.slice(-3).map((id) => ({
                  id,
                })),
              },
            },
          ],
        },
      ],
      [
        'Set',
        {
          DZ: [
            {
              __component: 'basic.dev-compo',
              categories: {
                set: existentIDs.slice(-3).map((id) => ({
                  id,
                })),
              },
            },
          ],
        },
      ],
      [
        'Number',
        {
          DZ: [
            {
              __component: 'basic.dev-compo',
              categories: existentIDs[0],
            },
          ],
        },
      ],
      [
        'Array',
        {
          DZ: [
            {
              __component: 'basic.dev-compo',
              categories: existentIDs.slice(-3),
            },
          ],
        },
      ],
    ];

    test.each(testData)('%s', async (__, input = {}) => {
      const res = entityValidator.validateEntityCreation(models.get('api::dev.dev'), input, {
        isDraft: true,
      });
      await expect(res).resolves.not.toThrowError();
    });
  });

  describe('Error', () => {
    const expectedError = new errors.ValidationError(
      `2 relation(s) of type api::category.category associated with this entity do not exist`
    );
    const testData = [
      [
        'Connect',
        {
          DZ: [
            {
              __component: 'basic.dev-compo',
              categories: {
                disconnect: [],
                connect: [existentIDs[0], ...nonExistentIds.slice(-2)].map((id) => ({
                  id,
                })),
              },
            },
          ],
        },
      ],
      [
        'Set',
        {
          DZ: [
            {
              __component: 'basic.dev-compo',
              categories: {
                set: [existentIDs[0], ...nonExistentIds.slice(-2)].map((id) => ({
                  id,
                })),
              },
            },
          ],
        },
      ],
      [
        'Array',
        {
          DZ: [
            {
              __component: 'basic.dev-compo',
              categories: [existentIDs[0], ...nonExistentIds.slice(-2)].map((id) => ({
                id,
              })),
            },
          ],
        },
      ],
    ];

    test.each(testData)('%s', async (__, input = {}) => {
      const res = entityValidator.validateEntityCreation(models.get('api::dev.dev'), input, {
        isDraft: true,
      });
      await expect(res).rejects.toThrowError(expectedError);
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/relations/media-level.test.ts">
import { errors } from '@strapi/utils';

import entityValidator from '../..';
import { models, existentIDs, nonExistentIds } from './utils/relations.testdata';

/**
 * Test that relations can be successfully validated and non existent relations
 * can be detected at the Media level.
 */
describe('Entity validator | Relations | Media', () => {
  global.strapi = {
    components: {
      'basic.dev-compo': {},
    },
    db: {
      query() {
        return {
          count: ({
            where: {
              id: { $in },
            },
          }: any) => existentIDs.filter((value) => $in.includes(value)).length,
        };
      },
    },
    errors: {
      badRequest: jest.fn(),
    },
    getModel: (uid: string) => models.get(uid),
  } as any;

  it('Success', async () => {
    const input = {
      media: [
        {
          id: existentIDs[0],
          name: 'img.jpeg',
        },
      ],
    };

    const res = entityValidator.validateEntityCreation(models.get('api::dev.dev'), input, {
      isDraft: true,
    });
    await expect(res).resolves.not.toThrowError();
  });

  it('Error', async () => {
    const expectedError = new errors.ValidationError(
      `1 relation(s) of type plugin::upload.file associated with this entity do not exist`
    );
    const input = {
      media: [
        {
          id: nonExistentIds[0],
          name: 'img.jpeg',
        },
        {
          id: existentIDs[0],
          name: 'img.jpeg',
        },
      ],
    };

    const res = entityValidator.validateEntityCreation(models.get('api::dev.dev'), input, {
      isDraft: true,
    });
    await expect(res).rejects.toThrowError(expectedError);
  });
});
</file>

<file path="src/services/entity-validator/__tests__/utils/index.ts">
export const mockOptions = {
  locale: 'en',
  isDraft: true,
};
</file>

<file path="src/services/entity-validator/__tests__/biginteger-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';
import { Validators } from '../validators';
import { mockOptions } from './utils';

describe('BigInteger validator', () => {
  const fakeModel: Schema.ContentType = {
    modelType: 'contentType',
    kind: 'collectionType',
    modelName: 'test-model',
    globalId: 'test-model',
    uid: 'api::test.test-uid',
    info: {
      displayName: 'Test model',
      singularName: 'test-model',
      pluralName: 'test-models',
    },
    options: {},
    attributes: {
      attrBigIntegerUnique: { type: 'biginteger', unique: true },
    },
  };

  describe('unique', () => {
    const fakeFindOne = jest.fn();

    global.strapi = {
      db: {
        query: () => ({
          findOne: fakeFindOne,
        }),
      },
    } as any;

    afterEach(() => {
      jest.clearAllMocks();
      fakeFindOne.mockReset();
    });

    // iterate on mockOptions.isDraft from false to true
    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('it does not validate unique constraints', async () => {
        fakeFindOne.mockResolvedValueOnce({ attrBigIntegerUnique: 2 });

        const validator = strapiUtils.validateYupSchema(
          Validators.biginteger(
            {
              attr: { type: 'biginteger', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrBigIntegerUnique',
                value: 1,
              },
              entity: null,
            },
            options
          )
        );

        expect(await validator(1)).toBe(1);
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it does not validate the unique constraint if the attribute is not set as unique', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.biginteger(
            {
              attr: { type: 'biginteger' },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrBigIntegerUnique',
                value: 1,
              },
              entity: null,
            },
            options
          )
        );

        await validator(1);

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it does not validate the unique constraint if the attribute value is `null`', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.biginteger(
            {
              attr: { type: 'biginteger', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrBigIntegerUnique',
                value: null,
              },
              entity: null,
            },
            options
          ).nullable()
        );

        await validator(null);

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it validates the unique constraint if there is no other record in the database', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.biginteger(
            {
              attr: { type: 'biginteger', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrBigIntegerUnique',
                value: 1,
              },
              entity: null,
            },
            options
          )
        );

        expect(await validator(1)).toBe(1);
      });

      test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {
        expect.assertions(1);
        fakeFindOne.mockResolvedValueOnce({ attrBigIntegerUnique: 2 });

        const validator = strapiUtils.validateYupSchema(
          Validators.biginteger(
            {
              attr: { type: 'biginteger', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrBigIntegerUnique',
                value: 2,
              },
              entity: null,
            },
            options
          )
        );

        try {
          await validator(2);
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it validates the unique constraint if the attribute data has not changed even if there is a record in the database with the same attribute value', async () => {
        fakeFindOne.mockResolvedValueOnce({ attrBigIntegerUnique: 3 });

        const validator = strapiUtils.validateYupSchema(
          Validators.biginteger(
            {
              attr: { type: 'biginteger', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrBigIntegerUnique',
                value: 3,
              },
              entity: { id: 1, attrBigIntegerUnique: 3 },
            },
            mockOptions
          )
        );

        expect(await validator(3)).toBe(3);
      });

      test('it checks the database for records with the same value for the checked attribute', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.biginteger(
            {
              attr: { type: 'biginteger', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrBigIntegerUnique',
                value: 4,
              },
              entity: null,
            },
            options
          )
        );

        await validator(4);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            publishedAt: { $notNull: true },
            locale: 'en',
            attrBigIntegerUnique: 4,
          },
          select: ['id'],
        });
      });

      test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.biginteger(
            {
              attr: { type: 'biginteger', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrBigIntegerUnique',
                value: 5,
              },
              entity: { id: 1, attrBigIntegerUnique: 42 },
            },
            options
          )
        );

        await validator(5);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            attrBigIntegerUnique: 5,
            id: {
              $ne: 1,
            },
            locale: 'en',
            publishedAt: { $notNull: true },
          },
          select: ['id'],
        });
      });
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/blocks-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import { Validators } from '../validators';

const validParagraph = [
  {
    type: 'paragraph',
    children: [
      { type: 'text', text: 'test' },
      { type: 'text', text: '' },
      {
        type: 'text',
        text: 'plop',
        bold: true,
        italic: false,
        underline: true,
        strikethrough: false,
        code: true,
      },
      {
        type: 'link',
        url: 'https://strapi.io',
        children: [{ type: 'text', text: 'Strapi' }],
      },
      {
        type: 'link',
        url: '/strapi',
        children: [{ type: 'text', text: 'Strapi relative link' }],
      },
      {
        type: 'link',
        url: 'mailto:info@strapi.io',
        children: [{ type: 'text', text: 'Strapi Email' }],
      },
    ],
  },
];
const validImage = [
  {
    type: 'image',
    children: [{ type: 'text', text: '' }],
    image: {
      name: 'Screenshot 2023-08-22 at 10.33.50.png',
      alternativeText: null,
      url: '/uploads/Screenshot_2023_08_22_at_10_33_50_ac7d5fd5b1.png',
      caption: null,
      width: 665,
      height: 692,
      formats: {},
      hash: 'Screenshot_2023_08_22_at_10_33_50_ac7d5fd5b1',
      ext: '.png',
      mime: 'image/png',
      size: 17.95,
      previewUrl: null,
      provider: 'local',
      provider_metadata: null,
      createdAt: '2023-08-24T09:43:30.065Z',
      updatedAt: '2023-08-24T09:43:30.065Z',
    },
  },
];
const validQuote = [
  {
    type: 'quote',
    children: [
      {
        type: 'text',
        text: 'This is a quote',
      },
      {
        type: 'link',
        url: 'https://strapi.io',
        children: [
          {
            type: 'text',
            text: 'Strapi',
          },
        ],
      },
    ],
  },
];
const validHeadings = [
  {
    type: 'heading',
    level: 1,
    children: [{ type: 'text', text: 'Heading 1' }],
  },
  {
    type: 'heading',
    level: 6,
    children: [
      {
        type: 'link',
        url: 'https://strapi.io',
        children: [{ type: 'text', text: 'Heading 2' }],
      },
    ],
  },
  {
    type: 'heading',
    level: 3,
    children: [
      {
        type: 'text',
        text: 'My cool',
      },
      {
        type: 'link',
        url: 'https://strapi.io',
        children: [
          {
            type: 'text',
            text: 'RFC',
          },
        ],
      },
    ],
  },
];
const validLists = [
  {
    type: 'list',
    format: 'ordered',
    children: [
      {
        type: 'list-item',
        children: [
          {
            type: 'text',
            text: 'First item',
          },
        ],
      },
      {
        type: 'list-item',
        children: [
          {
            type: 'link',
            url: 'https://strapi.io',
            children: [
              {
                type: 'text',
                text: 'Second item',
              },
            ],
          },
        ],
      },
    ],
  },
  {
    type: 'list',
    format: 'unordered',
    children: [
      {
        type: 'list-item',
        children: [
          {
            type: 'text',
            text: 'First item',
          },
        ],
      },
      {
        type: 'list-item',
        children: [
          {
            type: 'link',
            url: 'https://strapi.io',
            children: [
              {
                type: 'text',
                text: 'Second item',
              },
            ],
          },
        ],
      },
    ],
  },
];
const validCodeBlock = [
  {
    type: 'code',
    syntax: 'javascript',
    children: [{ type: 'text', text: 'const test = "whatever"' }],
  },
];
describe('Blocks validator', () => {
  describe('Paragraph', () => {
    it('Should accept a valid paragraph schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      expect(await validator(validParagraph)).toEqual(validParagraph);
    });
    it('Should throw an error given an invalid paragraph schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      // Bad children
      await expect(validator([{ type: 'paragraph' }])).rejects.toThrow(errors.YupValidationError);
      // Bad modifier
      await expect(validator([{ type: 'paragraph', text: 'hi', break: true }])).rejects.toThrow(
        errors.YupValidationError
      );
      // Bad url
      await expect(
        validator([{ type: 'link', url: 'kaboom', children: [{ type: 'text', text: 'fail' }] }])
      ).rejects.toThrow(errors.YupValidationError);
    });
  });
  describe('Heading', () => {
    it('Should accept a valid paragraph schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      expect(await validator(validHeadings)).toEqual(validHeadings);
    });
    it('Should throw an error given an invalid heading schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      // Bad level
      await expect(
        validator([{ type: 'heading', level: 8, children: [{ type: 'text', text: 'Heading 8' }] }])
      ).rejects.toThrow(errors.YupValidationError);
      // Bad children
      await expect(
        validator([{ type: 'heading', level: 1, children: [{ type: 'image', text: 'Heading 8' }] }])
      ).rejects.toThrow(errors.YupValidationError);
    });
  });
  describe('Quote', () => {
    it('Should accept a valid quote schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      expect(await validator(validQuote)).toEqual(validQuote);
    });
    it('Should throw an error given an invalid quote schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      // Bad children
      await expect(
        validator([{ type: 'quote', children: [{ type: 'heading', text: 'Heading 8' }] }])
      ).rejects.toThrow(errors.YupValidationError);
    });
  });
  describe('List', () => {
    it('Should accept a valid list schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      expect(await validator(validLists)).toEqual(validLists);
    });
    it('Should throw an error given an invalid list schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      // Bad format
      await expect(
        validator([
          {
            type: 'list',
            format: 'bad',
            children: [
              {
                type: 'list-item',
                children: [
                  {
                    type: 'text',
                    text: 'First item',
                  },
                ],
              },
            ],
          },
        ])
      ).rejects.toThrow(errors.YupValidationError);
      // Bad children
      await expect(
        validator([
          {
            type: 'list',
            format: 'ordered',
            children: [
              {
                type: 'heading',
                children: [
                  {
                    type: 'text',
                    level: 1,
                    children: [{ type: 'text', text: 'First item' }],
                  },
                ],
              },
            ],
          },
        ])
      ).rejects.toThrow(errors.YupValidationError);
    });
  });
  describe('Image', () => {
    it('Should accept a valid image schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      expect(await validator(validImage)).toEqual(validImage);
    });
    it('Should throw an error given an invalid image schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      // Bad image object
      await expect(
        validator([
          {
            type: 'image',
            children: [{ type: 'text', text: '' }],
            image: {
              name: null,
              url: null,
            },
          },
        ])
      ).rejects.toThrow(errors.YupValidationError);
    });
  });
  describe('Code', () => {
    it('Should accept a valid code schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'code' },
          },
          { isDraft: false }
        )
      );
      expect(await validator(validCodeBlock)).toEqual(validCodeBlock);
    });
    it('Should throw an error given an invalid code schema', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'code' },
          },
          { isDraft: false }
        )
      );
      // Bad children
      await expect(
        validator([
          {
            type: 'code',
            syntax: 'javascript',
            children: [{ type: 'link', text: 'const test = "whatever"' }],
          },
        ])
      ).rejects.toThrow(errors.YupValidationError);
    });
  });
  describe('Mixed', () => {
    it('Should accept a valid schema of mixed blocks', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      const mixed = [
        ...validParagraph,
        ...validImage,
        ...validQuote,
        ...validHeadings,
        ...validLists,
      ];
      expect(await validator(mixed)).toEqual(mixed);
    });
    it('Should throw an error given mixed valid and invalid blocks', () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.blocks(
          {
            attr: { type: 'blocks' },
          },
          { isDraft: false }
        )
      );
      const mixed = [
        ...validParagraph,
        ...validImage,
        ...validQuote,
        ...validHeadings,
        {
          type: 'list',
          format: 'ordered',
          children: [
            {
              type: 'heading',
              children: [
                {
                  type: 'text',
                  level: 1,
                  children: [{ type: 'text', text: 'First item' }],
                },
              ],
            },
          ],
        },
        {
          type: 'image',
          children: [{ type: 'text', text: '' }],
          image: {
            name: null,
            url: null,
          },
        },
      ];
      // Bad blocks
      expect(validator(mixed)).rejects.toThrow(errors.YupValidationError);
      // Bad version
      expect(validator(mixed)).rejects.toThrow(errors.YupValidationError);
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/date-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';
import { Validators } from '../validators';
import { mockOptions } from './utils';

describe('Date validator', () => {
  const fakeModel: Schema.ContentType = {
    modelType: 'contentType',
    kind: 'collectionType',
    modelName: 'test-model',
    globalId: 'test-model',
    uid: 'api::test.test-uid',
    info: {
      displayName: 'Test model',
      singularName: 'test-model',
      pluralName: 'test-models',
    },
    options: {},
    attributes: {
      attrDateUnique: { type: 'date', unique: true },
    },
  };

  describe('unique', () => {
    const fakeFindOne = jest.fn();

    global.strapi = {
      db: {
        query: () => ({
          findOne: fakeFindOne,
        }),
      },
    } as any;

    afterEach(() => {
      jest.clearAllMocks();
      fakeFindOne.mockReset();
    });

    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('it does not validate unique constraints', async () => {
        fakeFindOne.mockResolvedValueOnce({ attrDateUnique: '2021-11-29' });

        const validator = strapiUtils.validateYupSchema(
          Validators.date(
            {
              attr: { type: 'date', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },
              entity: null,
            },
            options
          )
        );

        expect(await validator('2021-11-29')).toBe('2021-11-29');
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it does not validates the unique constraint if the attribute is not set as unique', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.date(
            {
              attr: { type: 'date' },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },
              entity: null,
            },
            options
          )
        );

        await validator('2021-11-29');

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it does not validates the unique constraint if the attribute value is `null`', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.date(
            {
              attr: { type: 'date', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateUnique', value: null },
              entity: null,
            },
            options
          ).nullable()
        );

        await validator(null);
        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it validates the unique constraint if there is no other record in the database', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.date(
            {
              attr: { type: 'date', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },
              entity: null,
            },
            options
          )
        );

        expect(await validator('2021-11-29')).toBe('2021-11-29');
      });

      test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {
        expect.assertions(1);
        fakeFindOne.mockResolvedValueOnce({ attrDateUnique: '2021-11-29' });

        const validator = strapiUtils.validateYupSchema(
          Validators.date(
            {
              attr: { type: 'date', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },
              entity: null,
            },
            options
          )
        );

        try {
          await validator('2021-11-29');
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it checks the database for records with the same value for the checked attribute', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.date(
            {
              attr: { type: 'date', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },
              entity: null,
            },
            options
          )
        );

        await validator('2021-11-29');

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            locale: 'en',
            publishedAt: { $notNull: true },
            attrDateUnique: '2021-11-29',
          },
          select: ['id'],
        });
      });

      test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.date(
            {
              attr: { type: 'date', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateUnique', value: '2021-11-29' },
              entity: { id: 1, attrDateUnique: '2021-12-15' },
            },
            options
          )
        );

        await validator('2021-11-29');

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            attrDateUnique: '2021-11-29',
            id: {
              $ne: 1,
            },
            locale: 'en',
            publishedAt: { $notNull: true },
          },
          select: ['id'],
        });
      });
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/datetime-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';
import { Validators } from '../validators';
import { mockOptions } from './utils';

describe('Datetime validator', () => {
  const fakeModel: Schema.ContentType = {
    modelType: 'contentType',
    kind: 'collectionType',
    modelName: 'test-model',
    globalId: 'test-model',
    uid: 'api::test.test-uid',
    info: {
      displayName: 'Test model',
      singularName: 'test-model',
      pluralName: 'test-models',
    },
    options: {},
    attributes: {
      attrDateTimeUnique: { type: 'datetime', unique: true },
    },
  };

  describe('unique', () => {
    const fakeFindOne = jest.fn();

    global.strapi = {
      db: {
        query: () => ({
          findOne: fakeFindOne,
        }),
      },
    } as any;

    afterEach(() => {
      jest.clearAllMocks();
      fakeFindOne.mockReset();
    });

    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('it does not validate unique constraints', async () => {
        fakeFindOne.mockResolvedValueOnce({ attrDateTimeUnique: '2021-11-29T00:00:00.000Z' });

        const validator = strapiUtils.validateYupSchema(
          Validators.datetime(
            {
              attr: { type: 'datetime', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },
              entity: null,
            },
            options
          )
        );

        expect(await validator('2021-11-29T00:00:00.000Z')).toBe('2021-11-29T00:00:00.000Z');
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it does not validates the unique constraint if the attribute is not set as unique', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.datetime(
            {
              attr: { type: 'datetime' },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },
              entity: { id: 1, attrDateTimeUnique: '2021-11-29T00:00:00.000Z' },
            },
            options
          )
        );

        await validator('2021-11-29T00:00:00.000Z');

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it does not validates the unique constraint if the attribute value is `null`', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.datetime(
            {
              attr: { type: 'datetime', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateTimeUnique', value: null },
              entity: null,
            },
            options
          ).nullable()
        );

        await validator(null);
        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it validates the unique constraint if there is no other record in the database', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.datetime(
            {
              attr: { type: 'datetime', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },
              entity: null,
            },
            options
          )
        );

        expect(await validator('2021-11-29T00:00:00.000Z')).toBe('2021-11-29T00:00:00.000Z');
      });

      test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {
        expect.assertions(1);
        fakeFindOne.mockResolvedValueOnce({ attrDateTimeUnique: '2021-11-29T00:00:00.000Z' });

        const validator = strapiUtils.validateYupSchema(
          Validators.datetime(
            {
              attr: { type: 'datetime', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },
              entity: null,
            },
            options
          )
        );

        try {
          await validator('2021-11-29T00:00:00.000Z');
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it checks the database for records with the same value for the checked attribute', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.datetime(
            {
              attr: { type: 'datetime', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },
              entity: null,
            },
            options
          )
        );

        await validator('2021-11-29T00:00:00.000Z');

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            locale: 'en',
            publishedAt: { $notNull: true },
            attrDateTimeUnique: '2021-11-29T00:00:00.000Z',
          },
          select: ['id'],
        });
      });

      test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.datetime(
            {
              attr: { type: 'datetime', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrDateTimeUnique', value: '2021-11-29T00:00:00.000Z' },
              entity: { id: 1, attrDateTimeUnique: '2021-12-25T00:00:00.000Z' },
            },
            options
          )
        );

        await validator('2021-11-29T00:00:00.000Z');

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            attrDateTimeUnique: '2021-11-29T00:00:00.000Z',
            id: {
              $ne: 1,
            },
            locale: 'en',
            publishedAt: { $notNull: true },
          },
          select: ['id'],
        });
      });
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/email-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';
import { Validators } from '../validators';

describe('Email validator', () => {
  const fakeModel: Schema.ContentType = {
    modelType: 'contentType',
    kind: 'collectionType',
    modelName: 'test-model',
    globalId: 'test-model',
    uid: 'api::test.test-uid',
    info: {
      displayName: 'Test model',
      singularName: 'test-model',
      pluralName: 'test-models',
    },
    options: {},
    attributes: {
      attrEmail: { type: 'email' },
    },
  };

  describe('email', () => {
    describe('draft', () => {
      test('validation does not fail if the string is not a valid email', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.email(
            {
              attr: { type: 'email' },
              model: fakeModel,
              updatedAttribute: { name: 'attrEmail', value: 1 },
              entity: null,
            },
            { isDraft: true }
          )
        );

        await validator('invalid-email');
      });

      test('validation does not fail if the string is empty', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.email(
            {
              attr: { type: 'email' },
              model: fakeModel,
              updatedAttribute: { name: 'attrEmail', value: 1 },
              entity: null,
            },
            { isDraft: true }
          )
        );

        await validator('');
      });

      test('validation fails if not a valid string', async () => {
        expect.assertions(1);

        const validator = strapiUtils.validateYupSchema(
          Validators.email(
            {
              attr: { type: 'email' },
              model: fakeModel,
              updatedAttribute: { name: 'attrEmail', value: 1 },
              entity: null,
            },
            { isDraft: true }
          )
        );

        try {
          await validator(1);
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });
    });

    describe('published', () => {
      test('it fails the validation if the string is not a valid email', async () => {
        expect.assertions(1);

        const validator = strapiUtils.validateYupSchema(
          Validators.email(
            {
              attr: { type: 'email' },
              model: fakeModel,
              updatedAttribute: { name: 'attrEmail', value: 1 },
              entity: null,
            },
            { isDraft: false }
          )
        );

        try {
          await validator('invalid-email');
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it validates the email if it is valid', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.email(
            {
              attr: { type: 'email' },
              model: fakeModel,
              updatedAttribute: { name: 'attrEmail', value: 1 },
              entity: null,
            },
            { isDraft: false }
          )
        );

        expect(await validator('valid@email.com')).toBe('valid@email.com');
      });

      test('it validates non-empty email required field', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.email(
            {
              attr: { type: 'email' },
              model: fakeModel,
              updatedAttribute: { name: 'attrEmail', value: 1 },
              entity: null,
            },
            { isDraft: false }
          )
        );

        expect.hasAssertions();

        try {
          await validator('');
        } catch (err) {
          if (err instanceof Error) {
            expect(err).toBeInstanceOf(errors.YupValidationError);
            expect(err.message).toBe('this cannot be empty');
          }
        }
      });
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/enumeration-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';
import { Validators } from '../validators';

describe('Enumeration validator', () => {
  const fakeModel: Schema.ContentType = {
    modelType: 'contentType',
    kind: 'collectionType',
    modelName: 'test-model',
    globalId: 'test-model',
    uid: 'api::test.test-uid',
    info: {
      displayName: 'Test model',
      singularName: 'test-model',
      pluralName: 'test-models',
    },
    options: {},
    attributes: {
      attrEnumUnique: { type: 'float', unique: true },
    },
  };

  describe('oneOf', () => {
    test('it fails the validation if the value is not part of the allowed values', async () => {
      expect.assertions(1);

      const validator = strapiUtils.validateYupSchema(
        Validators.enumeration({
          attr: { type: 'enumeration', enum: ['strapi', 'headless'] },
          model: fakeModel,
          updatedAttribute: { name: 'attrFloatUnique', value: 1 },
          entity: null,
        })
      );

      try {
        await validator('invalid-vlue');
      } catch (err) {
        expect(err).toBeInstanceOf(errors.YupValidationError);
      }
    });

    test('it validates the value if it is part of the allowed values', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.enumeration({
          attr: { type: 'enumeration', enum: ['strapi', 'headless'] },
          model: fakeModel,
          updatedAttribute: { name: 'attrEnumUnique', value: 1 },
          entity: null,
        })
      );

      expect(await validator('strapi')).toBe('strapi');
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/float-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';
import { Validators } from '../validators';
import { mockOptions } from './utils';

describe('Float validator', () => {
  const fakeModel: Schema.ContentType = {
    modelType: 'contentType',
    kind: 'collectionType',
    modelName: 'test-model',
    globalId: 'test-model',
    uid: 'api::test.test-uid',
    info: {
      displayName: 'Test model',
      singularName: 'test-model',
      pluralName: 'test-models',
    },
    options: {},
    attributes: {
      attrFloatUnique: { type: 'float', unique: true },
    },
  };

  describe('unique', () => {
    const fakeFindOne = jest.fn();

    global.strapi = {
      db: {
        query: () => ({
          findOne: fakeFindOne,
        }),
      },
    } as any;

    afterEach(() => {
      jest.clearAllMocks();
      fakeFindOne.mockReset();
    });

    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('it does not validate unique constraints', async () => {
        fakeFindOne.mockResolvedValueOnce({ attrFloatUnique: 2 });

        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 2 },
              entity: null,
            },
            options
          )
        );

        expect(await validator(2)).toBe(2);
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it does not validates the unique constraint if the attribute is not set as unique', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float' },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 1 },
              entity: null,
            },
            options
          )
        );

        await validator(1);

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it does not validates the unique constraint if the attribute value is `null`', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: null },
              entity: null,
            },
            options
          ).nullable()
        );

        await validator(null);

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it validates the unique constraint if there is no other record in the database', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 2 },
              entity: null,
            },
            options
          )
        );

        expect(await validator(1)).toBe(1);
      });

      test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {
        expect.assertions(1);
        fakeFindOne.mockResolvedValueOnce({ attrFloatUnique: 2 });

        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 2 },
              entity: null,
            },
            options
          )
        );

        try {
          await validator(2);
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it checks the database for records with the same value for the checked attribute', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 4 },
              entity: null,
            },
            options
          )
        );

        await validator(4);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            locale: 'en',
            publishedAt: { $notNull: true },
            attrFloatUnique: 4,
          },
          select: ['id'],
        });
      });

      test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 5 },
              entity: { id: 1, attrFloatUnique: 42 },
            },
            options
          )
        );

        await validator(5);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            attrFloatUnique: 5,
            id: {
              $ne: 1,
            },
            locale: 'en',
            publishedAt: { $notNull: true },
          },
          select: ['id'],
        });
      });
    });
  });

  describe('min', () => {
    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('it does not fail if the float is lower than the defined min', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', min: 3 },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 5 },
              entity: { id: 1, attrFloatUnique: 42 },
            },
            options
          )
        );

        await validator(1);
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it fails the validation if the float is lower than the define min', async () => {
        expect.assertions(1);

        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', min: 3 },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 5 },
              entity: { id: 1, attrFloatUnique: 42 },
            },
            options
          )
        );

        try {
          await validator(1);
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it validates the min constraint if the float is higher than the define min', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', min: 3 },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 5 },
              entity: { id: 1, attrFloatUnique: 42 },
            },
            options
          )
        );

        expect(await validator(4)).toBe(4);
      });
    });
  });

  describe.each([{ isDraft: true }, { isDraft: false }])(
    `max - $isDraft`,
    ({ isDraft }: { isDraft: boolean }) => {
      const options = { ...mockOptions, isDraft };

      test('it fails the validation if the number is float than the define max', async () => {
        expect.assertions(1);

        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', max: 3 },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 5 },
              entity: { id: 1, attrFloatUnique: 42 },
            },
            options
          )
        );

        try {
          await validator(4);
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it validates the max constraint if the float is lower than the define max', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.float(
            {
              attr: { type: 'float', max: 3 },
              model: fakeModel,
              updatedAttribute: { name: 'attrFloatUnique', value: 5 },
              entity: { id: 1, attrFloatUnique: 42 },
            },
            options
          )
        );

        expect(await validator(2)).toBe(2);
      });
    }
  );
});
</file>

<file path="src/services/entity-validator/__tests__/index.test.ts">
import type { Schema } from '@strapi/types';
import entityValidator from '..';

describe('Entity validator', () => {
  const modelBase: Schema.ContentType = {
    modelType: 'contentType',
    uid: 'api::test.test',
    kind: 'collectionType',
    modelName: 'test',
    globalId: 'test',
    info: {
      displayName: 'Test',
      singularName: 'test',
      pluralName: 'tests',
    },
    options: {},
    attributes: {},
  };

  describe('Published input', () => {
    describe('General Errors', () => {
      let model: Schema.ContentType;
      global.strapi = {
        errors: {
          badRequest: jest.fn(),
        },
        getModel: () => model,
      } as any;

      it('Throws a badRequest error on invalid input', async () => {
        model = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
            },
          },
        };

        const input = { title: 1234 };

        expect.hasAssertions();

        try {
          await entityValidator.validateEntityCreation(model, input);
        } catch (e) {
          expect(e).toMatchObject({
            name: 'ValidationError',
            message: 'title must be a `string` type, but the final value was: `1234`.',
            details: {
              errors: [
                {
                  path: ['title'],
                  message: 'title must be a `string` type, but the final value was: `1234`.',
                  name: 'ValidationError',
                },
              ],
            },
          });
        }
      });

      it('Returns data on valid input', async () => {
        model = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
            },
          },
        };

        const input = { title: 'test Title' };

        expect.hasAssertions();

        const data = await entityValidator.validateEntityCreation(model, input);
        expect(data).toEqual(input);
      });

      it('Returns casted data when possible', async () => {
        model = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
            },
            number: {
              type: 'integer',
            },
          },
        };

        const input = { title: 'Test', number: '123' };

        expect.hasAssertions();

        const data = await entityValidator.validateEntityCreation(model, input);
        expect(data).toEqual({
          title: 'Test',
          number: 123,
        });
      });

      test('Throws on required not respected', async () => {
        model = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              required: true,
            },
          },
        };

        expect.hasAssertions();

        try {
          await entityValidator.validateEntityCreation(model, {});
        } catch (e) {
          expect(e).toMatchObject({
            name: 'ValidationError',
            message: 'title must be defined.',
            details: {
              errors: [
                {
                  path: ['title'],
                  message: 'title must be defined.',
                  name: 'ValidationError',
                },
              ],
            },
          });
        }

        try {
          await entityValidator.validateEntityCreation(model, { title: null });
        } catch (e) {
          expect(e).toMatchObject({
            name: 'ValidationError',
            message: 'title must be a `string` type, but the final value was: `null`.',
            details: {
              errors: [
                {
                  path: ['title'],
                  message: 'title must be a `string` type, but the final value was: `null`.',
                  name: 'ValidationError',
                },
              ],
            },
          });
        }
      });

      it('Supports custom field types', async () => {
        model = {
          ...modelBase,
          attributes: {
            uuid: {
              // @ts-ignore
              type: 'uuid',
            },
          },
        };

        const input = { uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7' };

        expect.hasAssertions();

        const data = await entityValidator.validateEntityCreation(model, input);
        expect(data).toEqual({
          uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7',
        });
      });
    });

    describe('String validator', () => {
      test('Throws on min length not respected', async () => {
        global.strapi = {
          errors: {
            badRequest: jest.fn(),
          },
          getModel: () => model,
        } as any;

        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              minLength: 10,
            },
          },
        };

        const input = { title: 'tooSmall' };

        expect.hasAssertions();

        try {
          await entityValidator.validateEntityCreation(model, input);
        } catch (e) {
          expect(e).toMatchObject({
            name: 'ValidationError',
            message: 'title must be at least 10 characters',
            details: {
              errors: [
                {
                  path: ['title'],
                  message: 'title must be at least 10 characters',
                  name: 'ValidationError',
                },
              ],
            },
          });
        }
      });

      test('Throws on max length not respected', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              maxLength: 2,
            },
          },
        };

        const input = { title: 'tooLong' };

        expect.hasAssertions();

        try {
          await entityValidator.validateEntityCreation(model, input);
        } catch (e) {
          expect(e).toMatchObject({
            name: 'ValidationError',
            message: 'title must be at most 2 characters',
            details: {
              errors: [
                {
                  path: ['title'],
                  message: 'title must be at most 2 characters',
                  name: 'ValidationError',
                },
              ],
            },
          });
        }
      });

      test('Allows empty strings even when required', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              required: true,
            },
          },
        };

        const input = { title: '' };

        expect.hasAssertions();

        const data = await entityValidator.validateEntityCreation(model, input);
        expect(data).toEqual(input);
      });

      test('Assign default values', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              required: true,
              default: 'New',
            },
            type: {
              type: 'string',
              default: 'test',
            },
            testDate: {
              type: 'date',
              required: true,
              default: '2020-04-01T04:00:00.000Z',
            },
            testJSON: {
              type: 'json',
              required: true,
              default: {
                foo: 1,
                bar: 2,
              },
            },
          },
        };

        await expect(entityValidator.validateEntityCreation(model, {})).resolves.toMatchObject({
          title: 'New',
          type: 'test',
          testDate: '2020-04-01T04:00:00.000Z',
          testJSON: {
            foo: 1,
            bar: 2,
          },
        });
      });

      test("Don't assign default value if empty string", async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              required: true,
              default: 'default',
            },
            content: {
              type: 'string',
              default: 'default',
            },
          },
        };

        await expect(
          entityValidator.validateEntityCreation(model, {
            title: '',
            content: '',
          })
        ).resolves.toMatchObject({
          title: '',
          content: '',
        });
      });
    });
  });

  describe('Draft input', () => {
    describe('General Errors', () => {
      it('Throws a badRequest error on invalid input', async () => {
        global.strapi = {
          errors: {
            badRequest: jest.fn(),
          },
          getModel: () => model,
        } as any;

        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
            },
          },
        };

        const input = { title: 1234 };

        expect.hasAssertions();

        try {
          await entityValidator.validateEntityCreation(model, input, { isDraft: true });
        } catch (e) {
          expect(e).toMatchObject({
            name: 'ValidationError',
            message: 'title must be a `string` type, but the final value was: `1234`.',
            details: {
              errors: [
                {
                  path: ['title'],
                  message: 'title must be a `string` type, but the final value was: `1234`.',
                  name: 'ValidationError',
                },
              ],
            },
          });
        }
      });

      it('Returns data on valid input', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
            },
          },
        };

        const input = { title: 'test Title' };

        expect.hasAssertions();

        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });
        expect(data).toEqual(input);
      });

      it('Returns casted data when possible', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
            },
            number: {
              type: 'integer',
            },
          },
        };

        const input = { title: 'Test', number: '123' };

        expect.hasAssertions();

        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });
        expect(data).toEqual({
          title: 'Test',
          number: 123,
        });
      });

      test('Does not throws on required not respected', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              required: true,
            },
          },
        };

        expect.hasAssertions();

        let data = await entityValidator.validateEntityCreation(model, {}, { isDraft: true });
        expect(data).toEqual({});

        data = await entityValidator.validateEntityCreation(
          model,
          { title: null },
          { isDraft: true }
        );
        expect(data).toEqual({ title: null });
      });

      it('Supports custom field types', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            uuid: {
              // @ts-ignore
              type: 'uuid',
            },
          },
        };

        const input = { uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7' };

        expect.hasAssertions();

        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });
        expect(data).toEqual({
          uuid: '2479d6d7-2497-478d-8a34-a9e8ce45f8a7',
        });
      });
    });

    describe('String validator', () => {
      test('Does not throws on min length not respected', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              minLength: 10,
            },
          },
        };

        global.strapi = {
          errors: {
            badRequest: jest.fn(),
          },
          getModel: () => model,
        } as any;

        const input = { title: 'tooSmall' };

        expect.hasAssertions();

        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });
        expect(data).toEqual(input);
      });

      test('Throws on max length not respected', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              maxLength: 2,
            },
          },
        };

        const input = { title: 'tooLong' };

        expect.hasAssertions();

        try {
          await entityValidator.validateEntityCreation(model, input, { isDraft: true });
        } catch (e) {
          expect(e).toMatchObject({
            name: 'ValidationError',
            message: 'title must be at most 2 characters',
            details: {
              errors: [
                {
                  path: ['title'],
                  message: 'title must be at most 2 characters',
                  name: 'ValidationError',
                },
              ],
            },
          });
        }
      });

      test('Allows empty strings even when required', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
            },
          },
        };

        const input = { title: '' };

        expect.hasAssertions();

        const data = await entityValidator.validateEntityCreation(model, input, { isDraft: true });
        expect(data).toEqual(input);
      });

      test('Assign default values', async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              required: true,
              default: 'New',
            },
            type: {
              type: 'string',
              default: 'test',
            },
            testDate: {
              type: 'date',
              required: true,
              default: '2020-04-01T04:00:00.000Z',
            },
            testJSON: {
              type: 'json',
              required: true,
              default: {
                foo: 1,
                bar: 2,
              },
            },
          },
        };

        await expect(
          entityValidator.validateEntityCreation(model, {}, { isDraft: true })
        ).resolves.toMatchObject({
          title: 'New',
          type: 'test',
          testDate: '2020-04-01T04:00:00.000Z',
          testJSON: {
            foo: 1,
            bar: 2,
          },
        });
      });

      test("Don't assign default value if empty string", async () => {
        const model: Schema.ContentType = {
          ...modelBase,
          attributes: {
            title: {
              type: 'string',
              required: true,
              default: 'default',
            },
            content: {
              type: 'string',
              default: 'default',
            },
          },
        };

        await expect(
          entityValidator.validateEntityCreation(
            model,
            {
              title: '',
              content: '',
            },
            { isDraft: true }
          )
        ).resolves.toMatchObject({
          title: '',
          content: '',
        });
      });
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/integer-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';
import { Validators } from '../validators';
import { mockOptions } from './utils';

describe('Integer validator', () => {
  const fakeModel: Schema.ContentType = {
    modelType: 'contentType',
    kind: 'collectionType',
    modelName: 'test-model',
    globalId: 'test-model',
    uid: 'api::test.test-uid',
    info: {
      displayName: 'Test model',
      singularName: 'test-model',
      pluralName: 'test-models',
    },
    options: {},
    attributes: {
      attrIntegerUnique: { type: 'integer', unique: true },
    },
  };

  describe('unique', () => {
    const fakeFindOne = jest.fn();

    global.strapi = {
      db: {
        query: () => ({
          findOne: fakeFindOne,
        }),
      },
    } as any;

    afterEach(() => {
      jest.clearAllMocks();
      fakeFindOne.mockReset();
    });

    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('it does not validate unique constraints', async () => {
        fakeFindOne.mockResolvedValueOnce({ attrIntegerUnique: 2 });

        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 2 },
              entity: null,
            },
            options
          )
        );

        expect(await validator(2)).toBe(2);
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it does not validates the unique constraint if the attribute is not set as unique', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer' },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 1 },
              entity: null,
            },
            options
          )
        );

        await validator(1);

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it does not validates the unique constraint if the attribute value is `null`', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: null },
              entity: null,
            },
            options
          ).nullable()
        );

        await validator(null);

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it validates the unique constraint if there is no other record in the database', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 2 },
              entity: null,
            },
            options
          )
        );

        expect(await validator(1)).toBe(1);
      });

      test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {
        expect.assertions(1);
        fakeFindOne.mockResolvedValueOnce({ attrIntegerUnique: 2 });

        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 2 },
              entity: null,
            },
            options
          )
        );

        try {
          await validator(2);
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it checks the database for records with the same value for the checked attribute', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 4 },
              entity: null,
            },
            options
          )
        );

        await validator(4);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            locale: 'en',
            publishedAt: { $notNull: true },
            attrIntegerUnique: 4,
          },
          select: ['id'],
        });
      });

      test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 5 },
              entity: { id: 1, attrIntegerUnique: 42 },
            },
            options
          )
        );

        await validator(5);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            attrIntegerUnique: 5,
            id: {
              $ne: 1,
            },
            locale: 'en',
            publishedAt: { $notNull: true },
          },
          select: ['id'],
        });
      });
    });
  });

  describe('min', () => {
    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('it does not fail if the integer is lower than the defined min', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', min: 3 },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 5 },
              entity: { id: 1, attrIntegerUnique: 42 },
            },
            options
          )
        );

        await validator(1);
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it fails the validation if the integer is lower than the define min', async () => {
        expect.assertions(1);

        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', min: 3 },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 5 },
              entity: { id: 1, attrIntegerUnique: 42 },
            },
            options
          )
        );

        try {
          await validator(1);
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it validates the min constraint if the integer is higher than the define min', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', min: 3 },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 5 },
              entity: { id: 1, attrIntegerUnique: 42 },
            },
            options
          )
        );

        expect(await validator(4)).toBe(4);
      });
    });
  });

  describe.each([{ isDraft: true }, { isDraft: false }])(
    `max - $isDraft`,
    ({ isDraft }: { isDraft: boolean }) => {
      const options = { ...mockOptions, isDraft };

      test('it fails the validation if the number is integer than the define max', async () => {
        expect.assertions(1);

        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', max: 3 },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 5 },
              entity: { id: 1, attrIntegerUnique: 42 },
            },
            options
          )
        );

        try {
          await validator(4);
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it validates the max constraint if the integer is lower than the define max', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.integer(
            {
              attr: { type: 'integer', max: 3 },
              model: fakeModel,
              updatedAttribute: { name: 'attrIntegerUnique', value: 5 },
              entity: { id: 1, attrIntegerUnique: 42 },
            },
            options
          )
        );

        expect(await validator(2)).toBe(2);
      });
    }
  );
});
</file>

<file path="src/services/entity-validator/__tests__/string-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';
import { Validators } from '../validators';
import { mockOptions } from './utils';

describe('String validator', () => {
  const fakeModel: Schema.ContentType = {
    modelType: 'contentType',
    kind: 'collectionType',
    modelName: 'test-model',
    globalId: 'test-model',
    uid: 'api::test.test-uid',
    info: {
      displayName: 'Test model',
      singularName: 'test-model',
      pluralName: 'test-models',
    },
    options: {},
    attributes: {
      attrStringUnique: { type: 'string', unique: true },
    },
  };

  describe('unique', () => {
    const fakeFindOne = jest.fn();

    global.strapi = {
      db: {
        query: () => ({
          findOne: fakeFindOne,
        }),
      },
    } as any;

    afterEach(() => {
      jest.clearAllMocks();
      fakeFindOne.mockReset();
    });

    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('it does not validate unique constraints', async () => {
        fakeFindOne.mockResolvedValueOnce({ attrStringUnique: 'test-data' });

        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: 'non-unique-test-data',
              },
              entity: null,
            },
            options
          )
        );

        expect(await validator('non-unique-test-data')).toBe('non-unique-test-data');
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it does not validates the unique constraint if the attribute is not set as unique', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string' },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: 'non-unique-test-data',
              },
              entity: null,
            },
            options
          )
        );

        await validator('non-unique-test-data');

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it does not validates the unique constraint if the attribute value is `null`', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: null,
              },
              entity: null,
            },
            options
          ).nullable()
        );

        await validator(null);

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it validates the unique constraint if there is no other record in the database', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: 'non-unique-test-data',
              },
              entity: null,
            },
            options
          )
        );

        expect(await validator('non-unique-test-data')).toBe('non-unique-test-data');
      });

      test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {
        expect.assertions(1);
        fakeFindOne.mockResolvedValueOnce({ attrStringUnique: 'unique-test-data' });

        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: 'unique-test-data',
              },
              entity: null,
            },
            options
          )
        );

        try {
          await validator('unique-test-data');
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it checks the database for records with the same value for the checked attribute', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const valueToCheck = 'test-data';
        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: valueToCheck,
              },
              entity: null,
            },
            options
          )
        );

        await validator(valueToCheck);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            locale: 'en',
            attrStringUnique: valueToCheck,
            publishedAt: { $notNull: true },
          },
          select: ['id'],
        });
      });

      test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const valueToCheck = 'test-data';
        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: valueToCheck,
              },
              entity: { id: 1, attrStringUnique: 'other-data' },
            },
            options
          )
        );

        await validator(valueToCheck);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            attrStringUnique: valueToCheck,
            id: {
              $ne: 1,
            },
            locale: 'en',
            publishedAt: { $notNull: true },
          },
          select: ['id'],
        });
      });
    });
  });

  describe('minLength', () => {
    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('ignores the minLength constraint', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', minLength: 3 },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: 'a',
              },
              entity: { id: 1, attrStringUnique: 'other-data' },
            },
            options
          )
        );

        expect(await validator('a')).toBe('a');
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it fails the validation if the string is shorter than the define minLength', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', minLength: 3 },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: 'test-data',
              },
              entity: { id: 1, attrStringUnique: 'other-data' },
            },
            options
          )
        );

        try {
          await validator('a');
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it validates the minLength constraint if the string is longer than the define minLength', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', minLength: 3 },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: 'test-data',
              },
              entity: { id: 1, attrStringUnique: 'other-data' },
            },
            options
          )
        );

        expect(await validator('this string is longer than the minLenght')).toBe(
          'this string is longer than the minLenght'
        );
      });
    });
  });

  describe.each([{ isDraft: true }, { isDraft: false }])(
    'maxLength - $isDraft',
    ({ isDraft }: { isDraft: boolean }) => {
      const options = { ...mockOptions, isDraft };

      test('it does not validates the maxLength constraint if the attribute maxLength is not an integer', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', maxLength: 123 },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: 'test-data',
              },
              entity: { id: 1, attrStringUnique: 'other-data' },
            },
            options
          )
        );

        expect(await validator('a')).toBe('a');
      });

      test('it fails the validation if the string is longer than the define maxLength', async () => {
        expect.assertions(1);

        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', maxLength: 3 },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: 'test-data',
              },
              entity: { id: 1, attrStringUnique: 'other-data' },
            },
            options
          )
        );

        try {
          await validator('this string is too long');
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      test('it validates the maxLength constraint if the string is shorter than the define maxLength', async () => {
        const validator = strapiUtils.validateYupSchema(
          Validators.string(
            {
              attr: { type: 'string', maxLength: 3 },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrStringUnique',
                value: 'test-data',
              },
              entity: { id: 1, attrStringUnique: 'other-data' },
            },
            options
          )
        );

        expect(await validator('a')).toBe('a');
      });
    }
  );

  describe('regExp', () => {
    const options = { ...mockOptions, isDraft: false };

    test('it fails the validation of an empty string for a required field', async () => {
      expect.assertions(1);

      const validator = strapiUtils.validateYupSchema(
        Validators.string(
          {
            attr: { type: 'string', required: true, regex: /^\w+$/ },
            model: fakeModel,
            updatedAttribute: {
              name: 'attrStringUnique',
              value: 'test-data',
            },
            entity: { id: 1, attrStringUnique: 'other-data' },
          },
          options
        )
      );

      try {
        await validator('');
      } catch (err) {
        expect(err).toBeInstanceOf(errors.YupValidationError);
      }
    });

    test('it validates a string for required field according to the regex constraint', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.string(
          {
            attr: { type: 'string', required: true, regex: /^\w+$/ },
            model: fakeModel,
            updatedAttribute: {
              name: 'attrStringUnique',
              value: 'test-data',
            },
            entity: { id: 1, attrStringUnique: 'other-data' },
          },
          options
        )
      );

      expect(await validator('Strapi')).toBe('Strapi');
    });

    test('it validates an empty string for non-required field with a regex constraint', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.string(
          {
            attr: { type: 'string', required: false, regex: /^\w+$/ },
            model: fakeModel,
            updatedAttribute: {
              name: 'attrStringUnique',
              value: 'test-data',
            },
            entity: { id: 1, attrStringUnique: 'other-data' },
          },
          options
        )
      );

      expect(await validator('')).toBe('');
    });

    test('it validates a string for non-required field according to the regex constraint', async () => {
      const validator = strapiUtils.validateYupSchema(
        Validators.string(
          {
            attr: { type: 'string', required: false, regex: /^\w+$/ },
            model: fakeModel,
            updatedAttribute: {
              name: 'attrStringUnique',
              value: 'test-data',
            },
            entity: { id: 1, attrStringUnique: 'other-data' },
          },
          options
        )
      );

      expect(await validator('Strapi')).toBe('Strapi');
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/time-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';
import { Validators } from '../validators';
import { mockOptions } from './utils';

describe('Time validator', () => {
  describe('unique', () => {
    const fakeFindOne = jest.fn();

    global.strapi = {
      db: {
        query: () => ({
          findOne: fakeFindOne,
        }),
      },
    } as any;

    afterEach(() => {
      jest.clearAllMocks();
      fakeFindOne.mockReset();
    });

    const fakeModel: Schema.ContentType = {
      modelType: 'contentType',
      kind: 'collectionType',
      modelName: 'test-model',
      globalId: 'test-model',
      uid: 'api::test.test-uid',
      info: {
        displayName: 'Test model',
        singularName: 'test-model',
        pluralName: 'test-models',
      },
      options: {},
      attributes: {
        attrTimeUnique: { type: 'time', unique: true },
      },
    };

    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('it ignores the unique constraint', async () => {
        fakeFindOne.mockResolvedValueOnce({ attrTimeUnique: '00:00:00.000Z' });

        const validator = strapiUtils.validateYupSchema(
          Validators.time(
            {
              attr: { type: 'time', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },
              entity: null,
            },
            options
          )
        );

        expect(await validator('00:00:00.000Z')).toBe('00:00:00.000Z');
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it does not validates the unique constraint if the attribute is not set as unique', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.time(
            {
              attr: { type: 'time' },
              model: fakeModel,
              updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },
              entity: null,
            },
            options
          )
        );

        await validator('00:00:00.000Z');

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it does not validates the unique constraint if the attribute value is `null`', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.time(
            {
              attr: { type: 'time', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrTimeUnique', value: null },
              entity: { id: 1, attrTimeUnique: '00:00:00.000Z' },
            },
            options
          ).nullable()
        );

        await validator(null);
        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it validates the unique constraint if there is no other record in the database', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.time(
            {
              attr: { type: 'time', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },
              entity: null,
            },
            options
          )
        );

        expect(await validator('00:00:00.000Z')).toBe('00:00:00.000Z');
      });

      test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {
        expect.assertions(1);
        fakeFindOne.mockResolvedValueOnce({ attrTimeUnique: '00:00:00.000Z' });

        const validator = strapiUtils.validateYupSchema(
          Validators.time(
            {
              attr: { type: 'time', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrTimeUnique', value: '00:00:00.000Z' },
              entity: null,
            },
            options
          )
        );

        try {
          await validator('00:00:00.000Z');
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      const valueToCheck = '00:00:00.000Z';

      test('it checks the database for records with the same value for the checked attribute', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.time(
            {
              attr: { type: 'time', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrTimeUnique', value: valueToCheck },
              entity: null,
            },
            options
          )
        );

        await validator(valueToCheck);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            locale: 'en',
            publishedAt: { $notNull: true },
            attrTimeUnique: '00:00:00.000Z',
          },
          select: ['id'],
        });
      });

      test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.time(
            {
              attr: { type: 'time', unique: true },
              model: fakeModel,
              updatedAttribute: { name: 'attrTimeUnique', value: valueToCheck },
              entity: { id: 1, attrTimeUnique: '01:00:00.000Z' },
            },
            options
          )
        );

        await validator(valueToCheck);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            attrTimeUnique: valueToCheck,
            id: {
              $ne: 1,
            },
            locale: 'en',
            publishedAt: { $notNull: true },
          },
          select: ['id'],
        });
      });
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/timestamp-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';

import { Validators } from '../validators';
import { mockOptions } from './utils';

describe('Time validator', () => {
  describe('unique', () => {
    const fakeFindOne = jest.fn();

    global.strapi = {
      db: {
        query: () => ({
          findOne: fakeFindOne,
        }),
      },
    } as any;

    afterEach(() => {
      jest.clearAllMocks();
      fakeFindOne.mockReset();
    });

    const fakeModel: Schema.ContentType = {
      modelType: 'contentType',
      kind: 'collectionType',
      modelName: 'test-model',
      globalId: 'test-model',
      uid: 'api::test.test-uid',
      info: {
        displayName: 'Test model',
        singularName: 'test-model',
        pluralName: 'test-models',
      },
      options: {},
      attributes: {
        attrTimestampUnique: { type: 'timestamp', unique: true },
      },
    };

    describe('draft', () => {
      const options = { ...mockOptions, isDraft: true };

      test('it ignores the unique validation ', async () => {
        fakeFindOne.mockResolvedValueOnce({ attrTimestampUnique: '1638140400' });

        const validator = strapiUtils.validateYupSchema(
          Validators.timestamp(
            {
              attr: { type: 'timestamp', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrTimestampUnique',
                value: '1638140400',
              },
              entity: null,
            },
            options
          )
        );

        expect(await validator('1638140400')).toBe('1638140400');
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it does not validates the unique constraint if the attribute is not set as unique', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.timestamp(
            {
              attr: { type: 'timestamp' },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrTimestampUnique',
                value: '1638140400',
              },
              entity: null,
            },
            options
          )
        );

        await validator('1638140400');

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it does not validates the unique constraint if the attribute value is `null`', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.timestamp(
            {
              attr: { type: 'timestamp', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrTimestampUnique',
                value: null,
              },
              entity: null,
            },
            options
          ).nullable()
        );

        await validator(null);
        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it validates the unique constraint if there is no other record in the database', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.timestamp(
            {
              attr: { type: 'timestamp', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrTimestampUnique',
                value: '1638140400',
              },
              entity: null,
            },
            options
          )
        );

        expect(await validator('1638140400')).toBe('1638140400');
      });

      test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {
        expect.assertions(1);
        fakeFindOne.mockResolvedValueOnce({ attrTimestampUnique: '1638140400' });

        const validator = strapiUtils.validateYupSchema(
          Validators.timestamp(
            {
              attr: { type: 'timestamp', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrTimestampUnique',
                value: '1638140400',
              },
              entity: null,
            },
            options
          )
        );

        try {
          await validator('1638140400');
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      const valueToCheck = '1638140400';
      test('it checks the database for records with the same value for the checked attribute', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.timestamp(
            {
              attr: { type: 'timestamp', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrTimestampUnique',
                value: valueToCheck,
              },
              entity: null,
            },
            options
          )
        );

        await validator(valueToCheck);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            locale: 'en',
            publishedAt: { $notNull: true },
            attrTimestampUnique: valueToCheck,
          },
          select: ['id'],
        });
      });

      test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.timestamp(
            {
              attr: { type: 'timestamp', unique: true },
              model: fakeModel,
              updatedAttribute: {
                name: 'attrTimestampUnique',
                value: valueToCheck,
              },
              entity: { id: 1, attrTimestampUnique: '1000000000' },
            },
            options
          )
        );

        await validator(valueToCheck);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            attrTimestampUnique: valueToCheck,
            id: {
              $ne: 1,
            },
            locale: 'en',
            publishedAt: { $notNull: true },
          },
          select: ['id'],
        });
      });
    });
  });
});
</file>

<file path="src/services/entity-validator/__tests__/uid-validators.test.ts">
import strapiUtils, { errors } from '@strapi/utils';
import type { Schema } from '@strapi/types';

import { Validators } from '../validators';
import { mockOptions } from './utils';

describe('UID validator', () => {
  const fakeFindOne = jest.fn();

  global.strapi = {
    db: {
      query: () => ({
        findOne: fakeFindOne,
      }),
    },
  } as any;

  afterEach(() => {
    jest.clearAllMocks();
    fakeFindOne.mockReset();
  });

  const fakeModel: Schema.ContentType = {
    modelType: 'contentType',
    kind: 'collectionType',
    globalId: 'test-model',
    modelName: 'test-model',
    uid: 'api::test.test-uid',
    info: {
      displayName: 'Test model',
      singularName: 'test-model',
      pluralName: 'test-models',
    },
    options: {},
    attributes: {
      attrUidUnique: { type: 'uid' },
    },
  };

  describe('unique', () => {
    describe('draft', () => {
      test('ignores unique validation', async () => {
        fakeFindOne.mockResolvedValueOnce({ attrUidUnique: 'unique-uid' });
        const valueToCheck = 'non-unique-uid';

        const validator = strapiUtils.validateYupSchema(
          Validators.uid(
            {
              attr: { type: 'uid' },
              model: fakeModel,
              updatedAttribute: { name: 'attrUidUnique', value: valueToCheck },
              entity: null,
            },
            mockOptions
          )
        );

        expect(await validator(valueToCheck)).toBe(valueToCheck);
      });
    });

    describe('published', () => {
      const options = { ...mockOptions, isDraft: false };

      test('it validates the unique constraint if there is no other record in the database', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.uid(
            {
              attr: { type: 'uid' },
              model: fakeModel,
              updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },
              entity: null,
            },
            options
          )
        );

        expect(await validator('non-unique-uid')).toBe('non-unique-uid');
        expect(fakeFindOne).toHaveBeenCalled();
      });

      test('it does not validates the unique constraint if the attribute value is `null`', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.uid(
            {
              attr: { type: 'uid' },
              model: fakeModel,
              updatedAttribute: { name: 'attrUidUnique', value: null },
              entity: null,
            },
            options
          ).nullable()
        );

        await validator(null);

        expect(fakeFindOne).not.toHaveBeenCalled();
      });

      test('it always validates the unique constraint even if the attribute is not set as unique', async () => {
        fakeFindOne.mockResolvedValueOnce(null);
        const valueToCheck = 'non-unique-uid';

        const validator = strapiUtils.validateYupSchema(
          Validators.uid(
            {
              attr: { type: 'uid' },
              model: fakeModel,
              updatedAttribute: { name: 'attrUidUnique', value: valueToCheck },
              entity: null,
            },
            options
          )
        );

        expect(await validator(valueToCheck)).toBe(valueToCheck);
        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            locale: 'en',
            publishedAt: { $notNull: true },
            attrUidUnique: valueToCheck,
          },
          select: ['id'],
        });
      });

      test('it fails the validation of the unique constraint if the database contains a record with the same attribute value', async () => {
        expect.assertions(1);
        fakeFindOne.mockResolvedValueOnce({ attrUidUnique: 'unique-uid' });

        const validator = strapiUtils.validateYupSchema(
          Validators.uid(
            {
              attr: { type: 'uid' },
              model: fakeModel,
              updatedAttribute: { name: 'attrUidUnique', value: 'unique-uid' },
              entity: null,
            },
            options
          )
        );

        try {
          await validator('unique-uid');
        } catch (err) {
          expect(err).toBeInstanceOf(errors.YupValidationError);
        }
      });

      const valueToCheck = 'unique-uid';
      test('it checks the database for records with the same value for the checked attribute', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.uid(
            {
              attr: { type: 'uid' },
              model: fakeModel,
              updatedAttribute: { name: 'attrUidUnique', value: valueToCheck },
              entity: null,
            },
            options
          )
        );

        await validator(valueToCheck);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            locale: 'en',
            publishedAt: { $notNull: true },
            attrUidUnique: valueToCheck,
          },
          select: ['id'],
        });
      });

      test('it checks the database for records with the same value but not the same id for the checked attribute if an entity is passed', async () => {
        fakeFindOne.mockResolvedValueOnce(null);

        const validator = strapiUtils.validateYupSchema(
          Validators.uid(
            {
              attr: { type: 'uid' },
              model: fakeModel,
              updatedAttribute: { name: 'attrUidUnique', value: valueToCheck },
              entity: { id: 1, attrUidUnique: 'other-uid' },
            },
            options
          )
        );

        await validator(valueToCheck);

        expect(fakeFindOne).toHaveBeenCalledWith({
          where: {
            locale: 'en',
            id: { $ne: 1 },
            publishedAt: { $notNull: true },
            attrUidUnique: valueToCheck,
          },
          select: ['id'],
        });
      });
    });
  });

  describe('regExp', () => {
    const options = { ...mockOptions, isDraft: false };

    test('it fails to validate the uid if it does not fit the requried format', async () => {
      expect.assertions(1);
      fakeFindOne.mockResolvedValueOnce(null);

      const validator = strapiUtils.validateYupSchema(
        Validators.uid(
          {
            attr: { type: 'uid' },
            model: fakeModel,
            updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },
            entity: null,
          },
          options
        )
      );

      try {
        await validator('wrongly\\formated||UID');
      } catch (err) {
        expect(err).toBeInstanceOf(errors.YupValidationError);
      }
    });

    test('it validate the uid if it fit the required format', async () => {
      fakeFindOne.mockResolvedValueOnce(null);

      const validator = strapiUtils.validateYupSchema(
        Validators.uid(
          {
            attr: { type: 'uid' },
            model: fakeModel,
            updatedAttribute: { name: 'attrUidUnique', value: 'non-unique-uid' },
            entity: null,
          },
          options
        )
      );

      expect(await validator('properly.formated-uid')).toBe('properly.formated-uid');
    });
  });
});
</file>

<file path="src/services/entity-validator/blocks-validator.ts">
import { yup } from '@strapi/utils';

const textNodeValidator = yup.object().shape({
  type: yup.string().equals(['text']).required(),
  text: yup
    .string()
    .test(
      'is-valid-text',
      'Text must be defined with at least an empty string',
      (text: unknown) => {
        return typeof text === 'string' || text === '';
      }
    ),
  bold: yup.boolean(),
  italic: yup.boolean(),
  underline: yup.boolean(),
  strikethrough: yup.boolean(),
  code: yup.boolean(),
});

const checkValidLink = (link: string) => {
  try {
    // eslint-disable-next-line no-new
    new URL(link.startsWith('/') ? `https://strapi.io${link}` : link);
  } catch (error) {
    return false;
  }
  return true;
};

const linkNodeValidator = yup.object().shape({
  type: yup.string().equals(['link']).required(),
  url: yup
    .string()
    .test('invalid-url', 'Please specify a valid link.', (value) => checkValidLink(value ?? '')),
  children: yup.array().of(textNodeValidator).required(),
});

// TODO: remove any with a correct Type
const inlineNodeValidator: any = yup.lazy((value: { type: string }) => {
  switch (value.type) {
    case 'text':
      return textNodeValidator;
    case 'link':
      return linkNodeValidator;
    default:
      return yup.mixed().test('invalid-type', 'Inline node must be Text or Link', () => {
        return false;
      });
  }
});

const paragraphNodeValidator = yup.object().shape({
  type: yup.string().equals(['paragraph']).required(),
  children: yup
    .array()
    .of(inlineNodeValidator)
    .min(1, 'Paragraph node children must have at least one Text or Link node')
    .required(),
});

const headingNodeValidator = yup.object().shape({
  type: yup.string().equals(['heading']).required(),
  level: yup.number().oneOf([1, 2, 3, 4, 5, 6]).required(),
  children: yup
    .array()
    .of(inlineNodeValidator)
    .min(1, 'Heading node children must have at least one Text or Link node')
    .required(),
});

const quoteNodeValidator = yup.object().shape({
  type: yup.string().equals(['quote']).required(),
  children: yup
    .array()
    .of(inlineNodeValidator)
    .min(1, 'Quote node children must have at least one Text or Link node')
    .required(),
});

const codeBlockValidator = yup.object().shape({
  type: yup.string().equals(['code']).required(),
  syntax: yup.string().nullable(),
  children: yup
    .array()
    .of(textNodeValidator)
    .min(1, 'Quote node children must have at least one Text or Link node')
    .required(),
});

const listItemNode = yup.object().shape({
  type: yup.string().equals(['list-item']).required(),
  children: yup.array().of(inlineNodeValidator).required(),
});

// Allow children to be either a listItemNode or a listNode itself
// @ts-expect-error - listChildrenValidator needs a type
const listChildrenValidator = yup.lazy((value: { type: string }) => {
  switch (value.type) {
    case 'list':
      return listNodeValidator;
    case 'list-item':
      return listItemNode;
    default:
      return yup.mixed().test('invalid-type', 'Inline node must be list-item or list', () => {
        return false;
      });
  }
});

// @ts-expect-error - listNodeValidator needs a type
const listNodeValidator = yup.object().shape({
  type: yup.string().equals(['list']).required(),
  format: yup.string().equals(['ordered', 'unordered']).required(),
  children: yup
    .array()
    .of(listChildrenValidator)
    .min(1, 'List node children must have at least one ListItem or ListNode')
    .required(),
});

const imageNodeValidator = yup.object().shape({
  type: yup.string().equals(['image']).required(),
  image: yup.object().shape({
    name: yup.string().required(),
    alternativeText: yup.string().nullable(),
    url: yup.string().required(),
    caption: yup.string().nullable(),
    width: yup.number().required(),
    height: yup.number().required(),
    formats: yup.object().required(),
    hash: yup.string().required(),
    ext: yup.string().required(),
    mime: yup.string().required(),
    size: yup.number().required(),
    previewUrl: yup.string().nullable(),
    provider: yup.string().required(),
    provider_metadata: yup.mixed().nullable(),
    createdAt: yup.string().required(),
    updatedAt: yup.string().required(),
  }),
  children: yup.array().of(inlineNodeValidator).required(),
});

// TODO: remove the any and replace with a correct Type
const blockNodeValidator: any = yup.lazy((value: { type: string }) => {
  switch (value.type) {
    case 'paragraph':
      return paragraphNodeValidator;
    case 'heading':
      return headingNodeValidator;
    case 'quote':
      return quoteNodeValidator;
    case 'list':
      return listNodeValidator;
    case 'image':
      return imageNodeValidator;
    case 'code':
      return codeBlockValidator;
    default:
      return yup.mixed().test('invalid-type', 'Block node is of invalid type', () => {
        return false;
      });
  }
});

const blocksValidatorSchema = yup.array().of(blockNodeValidator);

export const blocksValidator = () => blocksValidatorSchema;
</file>

<file path="src/services/entity-validator/index.ts">
/**
 * Entity validator
 * Module that will validate input data for entity creation or edition
 */

import { uniqBy, castArray, isNil, isArray, mergeWith } from 'lodash';
import { has, prop, isObject, isEmpty } from 'lodash/fp';
import strapiUtils from '@strapi/utils';
import type { Modules, UID, Struct, Schema } from '@strapi/types';
import { Validators, ValidatorMetas } from './validators';

type CreateOrUpdate = 'creation' | 'update';

const { yup, validateYupSchema } = strapiUtils;
const { isMediaAttribute, isScalarAttribute, getWritableAttributes } = strapiUtils.contentTypes;
const { ValidationError } = strapiUtils.errors;

type ID = { id: string | number };

type RelationSource = string | number | ID;

export type ComponentContext = {
  parentContent: {
    // The model of the parent content type that contains the current component.
    model: Struct.Schema;
    // The numeric id of the parent entity that contains the component.
    id?: number;
    // The options passed to the entity validator. From which we can extract
    // entity dimensions such as locale and publication state.
    options?: ValidatorContext;
  };
  // The path to the component within the parent content type schema.
  pathToComponent: string[];
  // If working with a repeatable component this contains the
  // full data of the repeatable component in the current entity.
  repeatableData: Modules.EntityValidator.Entity[];
  fullDynamicZoneContent?: Schema.Attribute.Value<Schema.Attribute.DynamicZone>;
};

interface WithComponentContext {
  componentContext?: ComponentContext;
}

interface ValidatorMeta<TAttribute = Schema.Attribute.AnyAttribute> extends WithComponentContext {
  attr: TAttribute;
  updatedAttribute: { name: string; value: any };
}

interface ValidatorContext {
  isDraft?: boolean;
  locale?: string | null;
}

interface ModelValidatorMetas extends WithComponentContext {
  model: Struct.Schema;
  data: Record<string, unknown>;
  entity?: Modules.EntityValidator.Entity;
}

const isInteger = (value: unknown): value is number => Number.isInteger(value);

const addMinMax = <
  T extends {
    min(value: number): T;
    max(value: number): T;
  },
>(
  validator: T,
  {
    attr,
    updatedAttribute,
  }: ValidatorMeta<Schema.Attribute.AnyAttribute & Schema.Attribute.MinMaxOption<string | number>>
): T => {
  let nextValidator: T = validator;

  if (
    isInteger(attr.min) &&
    (('required' in attr && attr.required) ||
      (Array.isArray(updatedAttribute.value) && updatedAttribute.value.length > 0))
  ) {
    nextValidator = nextValidator.min(attr.min);
  }
  if (isInteger(attr.max)) {
    nextValidator = nextValidator.max(attr.max);
  }
  return nextValidator;
};

const addRequiredValidation = (createOrUpdate: CreateOrUpdate) => {
  return <T extends strapiUtils.yup.AnySchema>(
    validator: T,
    {
      attr: { required },
    }: ValidatorMeta<Partial<Schema.Attribute.AnyAttribute & Schema.Attribute.RequiredOption>>
  ): T => {
    let nextValidator = validator;

    if (required) {
      if (createOrUpdate === 'creation') {
        nextValidator = nextValidator.notNil();
      } else if (createOrUpdate === 'update') {
        nextValidator = nextValidator.notNull();
      }
    } else {
      nextValidator = nextValidator.nullable();
    }
    return nextValidator;
  };
};

const addDefault = (createOrUpdate: CreateOrUpdate) => {
  return (
    validator: strapiUtils.yup.BaseSchema,
    { attr }: ValidatorMeta<Schema.Attribute.AnyAttribute & Schema.Attribute.DefaultOption<unknown>>
  ) => {
    let nextValidator = validator;

    if (createOrUpdate === 'creation') {
      if (
        ((attr.type === 'component' && attr.repeatable) || attr.type === 'dynamiczone') &&
        !attr.required
      ) {
        nextValidator = nextValidator.default([]);
      } else {
        nextValidator = nextValidator.default(attr.default);
      }
    } else {
      nextValidator = nextValidator.default(undefined);
    }

    return nextValidator;
  };
};

const preventCast = (validator: strapiUtils.yup.AnySchema) =>
  validator.transform((val, originalVal) => originalVal);

const createComponentValidator =
  (createOrUpdate: CreateOrUpdate) =>
  (
    {
      attr,
      updatedAttribute,
      componentContext,
    }: ValidatorMeta<Schema.Attribute.Component<UID.Component, boolean>>,
    { isDraft }: ValidatorContext
  ) => {
    const model = strapi.getModel(attr.component);
    if (!model) {
      throw new Error('Validation failed: Model not found');
    }

    if (attr?.repeatable) {
      // FIXME: yup v1

      let validator = yup
        .array()
        .of(
          yup.lazy((item) =>
            createModelValidator(createOrUpdate)(
              { componentContext, model, data: item },
              { isDraft }
            ).notNull()
          ) as any
        );

      validator = addRequiredValidation(createOrUpdate)(validator, {
        attr: { required: true },
        updatedAttribute,
      });

      if (!isDraft) {
        validator = addMinMax(validator, { attr, updatedAttribute });
      }

      return validator;
    }

    let validator = createModelValidator(createOrUpdate)(
      {
        model,
        data: updatedAttribute.value,
        componentContext,
      },
      { isDraft }
    );

    validator = addRequiredValidation(createOrUpdate)(validator, {
      attr: { required: !isDraft && attr.required },
      updatedAttribute,
    });

    return validator;
  };

const createDzValidator =
  (createOrUpdate: CreateOrUpdate) =>
  ({ attr, updatedAttribute, componentContext }: ValidatorMeta, { isDraft }: ValidatorContext) => {
    let validator;

    validator = yup.array().of(
      yup.lazy((item) => {
        const model = strapi.getModel(prop('__component', item));
        const schema = yup
          .object()
          .shape({
            __component: yup.string().required().oneOf(Object.keys(strapi.components)),
          })
          .notNull();

        return model
          ? schema.concat(
              createModelValidator(createOrUpdate)(
                { model, data: item, componentContext },
                { isDraft }
              )
            )
          : schema;
      }) as any // FIXME: yup v1
    );

    validator = addRequiredValidation(createOrUpdate)(validator, {
      attr: { required: true },
      updatedAttribute,
    });

    if (!isDraft) {
      validator = addMinMax(validator, { attr, updatedAttribute });
    }

    return validator;
  };

const createRelationValidator = ({
  updatedAttribute,
}: ValidatorMeta<Schema.Attribute.Relation>) => {
  let validator;

  if (Array.isArray(updatedAttribute.value)) {
    validator = yup.array().of(yup.mixed());
  } else {
    validator = yup.mixed();
  }

  return validator;
};

const createScalarAttributeValidator =
  (createOrUpdate: CreateOrUpdate) => (metas: ValidatorMeta, options: ValidatorContext) => {
    let validator;

    if (has(metas.attr.type, Validators)) {
      validator = (Validators as any)[metas.attr.type](metas, options);
    } else {
      // No validators specified - fall back to mixed
      validator = yup.mixed();
    }

    validator = addRequiredValidation(createOrUpdate)(validator, {
      attr: { required: !options.isDraft && metas.attr.required },
      updatedAttribute: metas.updatedAttribute,
    });

    return validator;
  };

const createAttributeValidator =
  (createOrUpdate: CreateOrUpdate) => (metas: ValidatorMetas, options: ValidatorContext) => {
    let validator = yup.mixed();

    if (isMediaAttribute(metas.attr)) {
      validator = yup.mixed();
    } else if (isScalarAttribute(metas.attr)) {
      validator = createScalarAttributeValidator(createOrUpdate)(metas, options);
    } else {
      if (metas.attr.type === 'component' && metas.componentContext) {
        // Build the path to the component within the parent content type schema.
        const pathToComponent = [
          ...(metas?.componentContext?.pathToComponent ?? []),
          metas.updatedAttribute.name,
        ];

        // If working with a repeatable component, determine the repeatable data
        // based on the component's path.

        // In order to validate the repeatable within this entity we need
        // access to the full repeatable data. In case we are validating a
        // nested component within a repeatable.
        // Hence why we set this up when the path to the component is only one level deep.
        const repeatableData = (
          metas.attr.repeatable && pathToComponent.length === 1
            ? metas.updatedAttribute.value
            : metas.componentContext?.repeatableData
        ) as Modules.EntityValidator.Entity[];

        const newComponentContext: ComponentContext = {
          ...metas.componentContext,
          pathToComponent,
          repeatableData,
        };

        validator = createComponentValidator(createOrUpdate)(
          {
            componentContext: newComponentContext,
            attr: metas.attr,
            updatedAttribute: metas.updatedAttribute,
          },
          options
        );
      } else if (metas.attr.type === 'dynamiczone' && metas.componentContext) {
        const newComponentContext: ComponentContext = {
          ...metas.componentContext,
          fullDynamicZoneContent: metas.updatedAttribute.value,
          pathToComponent: [...metas.componentContext.pathToComponent, metas.updatedAttribute.name],
        };

        Object.assign(metas, { componentContext: newComponentContext });

        validator = createDzValidator(createOrUpdate)(metas, options);
      } else if (metas.attr.type === 'relation') {
        validator = createRelationValidator({
          attr: metas.attr,
          updatedAttribute: metas.updatedAttribute,
        });
      }

      validator = preventCast(validator);
    }

    validator = addDefault(createOrUpdate)(validator, metas);

    return validator;
  };

const createModelValidator =
  (createOrUpdate: CreateOrUpdate) =>
  ({ componentContext, model, data, entity }: ModelValidatorMetas, options: ValidatorContext) => {
    const writableAttributes = model ? getWritableAttributes(model as any) : [];

    const schema = writableAttributes.reduce(
      (validators, attributeName) => {
        const metas = {
          attr: model.attributes[attributeName],
          updatedAttribute: { name: attributeName, value: prop(attributeName, data) },
          model,
          entity,
          componentContext,
        };

        const validator = createAttributeValidator(createOrUpdate)(metas, options);

        validators[attributeName] = validator;

        return validators;
      },
      {} as Record<string, strapiUtils.yup.BaseSchema>
    );

    return yup.object().shape(schema);
  };

const createValidateEntity = (createOrUpdate: CreateOrUpdate) => {
  return async <
    TUID extends UID.ContentType,
    TData extends Modules.EntityService.Params.Data.Input<TUID>,
  >(
    model: Schema.ContentType<TUID>,
    data: TData | Partial<TData> | undefined,
    options?: ValidatorContext,
    entity?: Modules.EntityValidator.Entity
  ): Promise<TData> => {
    if (!isObject(data)) {
      const { displayName } = model.info;

      throw new ValidationError(
        `Invalid payload submitted for the ${createOrUpdate} of an entity of type ${displayName}. Expected an object, but got ${typeof data}`
      );
    }

    const validator = createModelValidator(createOrUpdate)(
      {
        model,
        data,
        entity,
        componentContext: {
          // Set up the initial component context.
          // Keeping track of parent content type context in which a component will be used.
          // This is necessary to validate component field constraints such as uniqueness.
          parentContent: {
            id: entity?.id,
            model,
            options,
          },
          pathToComponent: [],
          repeatableData: [],
        },
      },
      {
        isDraft: options?.isDraft ?? false,
        locale: options?.locale ?? null,
      }
    )
      .test(
        'relations-test',
        'check that all relations exist',
        async function relationsValidation(data) {
          try {
            await checkRelationsExist(buildRelationsStore({ uid: model.uid, data }));
          } catch (e) {
            return this.createError({
              path: this.path,
              message: (e instanceof ValidationError && e.message) || 'Invalid relations',
            });
          }
          return true;
        }
      )
      .required();

    return validateYupSchema(validator, {
      strict: false,
      abortEarly: false,
    })(data);
  };
};

/**
 * Builds an object containing all the media and relations being associated with an entity
 */
const buildRelationsStore = <TUID extends UID.Schema>({
  uid,
  data,
}: {
  uid: TUID;
  data: Record<string, unknown> | null;
}): Record<string, ID[]> => {
  if (!uid) {
    throw new ValidationError(`Cannot build relations store: "uid" is undefined`);
  }

  if (isEmpty(data)) {
    return {};
  }

  const currentModel = strapi.getModel(uid);

  return Object.keys(currentModel.attributes).reduce(
    (result, attributeName: string) => {
      const attribute = currentModel.attributes[attributeName];
      const value = data[attributeName];

      if (isNil(value)) {
        return result;
      }

      switch (attribute.type) {
        case 'relation':
        case 'media': {
          if (
            attribute.type === 'relation' &&
            (attribute.relation === 'morphToMany' || attribute.relation === 'morphToOne')
          ) {
            // TODO: handle polymorphic relations
            break;
          }

          const target =
            // eslint-disable-next-line no-nested-ternary
            attribute.type === 'media' ? 'plugin::upload.file' : attribute.target;
          // As there are multiple formats supported for associating relations
          // with an entity, the value here can be an: array, object or number.
          let source: RelationSource[];
          if (Array.isArray(value)) {
            source = value;
          } else if (isObject(value)) {
            if ('connect' in value && !isNil(value.connect)) {
              source = value.connect as RelationSource[];
            } else if ('set' in value && !isNil(value.set)) {
              source = value.set as RelationSource[];
            } else {
              source = [];
            }
          } else {
            source = castArray(value as RelationSource);
          }
          const idArray = source.map((v) => ({
            id: typeof v === 'object' ? v.id : v,
          }));

          // Update the relationStore to keep track of all associations being made
          // with relations and media.
          result[target] = result[target] || [];
          result[target].push(...idArray);
          break;
        }
        case 'component': {
          return castArray(value).reduce((relationsStore, componentValue) => {
            if (!attribute.component) {
              throw new ValidationError(
                `Cannot build relations store from component, component identifier is undefined`
              );
            }

            return mergeWith(
              relationsStore,
              buildRelationsStore({
                uid: attribute.component,
                data: componentValue as Record<string, unknown>,
              }),
              (objValue, srcValue) => {
                if (isArray(objValue)) {
                  return objValue.concat(srcValue);
                }
              }
            );
          }, result) as Record<string, ID[]>;
        }
        case 'dynamiczone': {
          return castArray(value).reduce((relationsStore, dzValue) => {
            const value = dzValue as Record<string, unknown>;
            if (!value.__component) {
              throw new ValidationError(
                `Cannot build relations store from dynamiczone, component identifier is undefined`
              );
            }

            return mergeWith(
              relationsStore,
              buildRelationsStore({
                uid: value.__component as UID.Component,
                data: value,
              }),
              (objValue, srcValue) => {
                if (isArray(objValue)) {
                  return objValue.concat(srcValue);
                }
              }
            );
          }, result) as Record<string, ID[]>;
        }
        default:
          break;
      }

      return result;
    },
    {} as Record<string, ID[]>
  );
};

/**
 * Iterate through the relations store and validates that every relation or media
 * mentioned exists
 */
const checkRelationsExist = async (relationsStore: Record<string, ID[]> = {}) => {
  const promises: Promise<void>[] = [];

  for (const [key, value] of Object.entries(relationsStore)) {
    const evaluate = async () => {
      const uniqueValues = uniqBy(value, `id`);
      const count = await strapi.db.query(key as UID.Schema).count({
        where: {
          id: {
            $in: uniqueValues.map((v) => v.id),
          },
        },
      });

      if (count !== uniqueValues.length) {
        throw new ValidationError(
          `${
            uniqueValues.length - count
          } relation(s) of type ${key} associated with this entity do not exist`
        );
      }
    };
    promises.push(evaluate());
  }

  return Promise.all(promises);
};

const entityValidator: Modules.EntityValidator.EntityValidator = {
  validateEntityCreation: createValidateEntity('creation'),
  validateEntityUpdate: createValidateEntity('update'),
};

export default entityValidator;
</file>

<file path="src/services/entity-validator/validators.ts">
/**
 * Validators check if the entry data meets specific criteria before saving or publishing.
 * (e.g., length, range, format).
 *
 * Drafts have limited validations (mainly max constraints),
 * while published content undergoes full validation.
 *
 * The system also takes locales into account when validating data.
 * E.g, unique fields must be unique within the same locale.
 */
import _ from 'lodash';
import { yup } from '@strapi/utils';
import type { Schema, Struct, Modules } from '@strapi/types';
import { blocksValidator } from './blocks-validator';

import type { ComponentContext } from '.';

export interface ValidatorMetas<
  TAttribute extends Schema.Attribute.AnyAttribute = Schema.Attribute.AnyAttribute,
  TValue extends Schema.Attribute.Value<TAttribute> = Schema.Attribute.Value<TAttribute>,
> {
  attr: TAttribute;
  model: Struct.Schema;
  updatedAttribute: {
    name: string;
    value: TValue;
  };
  componentContext?: ComponentContext;
  entity?: Modules.EntityValidator.Entity;
}

interface ValidatorOptions {
  isDraft: boolean;
  locale?: string;
}

/* Validator utils */

/**
 * Adds minLength validator
 */
const addMinLengthValidator = (
  validator: yup.StringSchema,
  {
    attr,
  }: {
    attr:
      | Schema.Attribute.String
      | Schema.Attribute.Text
      | Schema.Attribute.RichText
      | Schema.Attribute.Password
      | Schema.Attribute.Email
      | Schema.Attribute.UID;
  },
  { isDraft }: ValidatorOptions
) => {
  return attr.minLength && _.isInteger(attr.minLength) && !isDraft
    ? validator.min(attr.minLength)
    : validator;
};

/**
 * Adds maxLength validator
 * @returns {StringSchema}
 */
const addMaxLengthValidator = (
  validator: yup.StringSchema,
  {
    attr,
  }: {
    attr:
      | Schema.Attribute.String
      | Schema.Attribute.Text
      | Schema.Attribute.RichText
      | Schema.Attribute.Password
      | Schema.Attribute.Email
      | Schema.Attribute.UID;
  }
) => {
  return attr.maxLength && _.isInteger(attr.maxLength) ? validator.max(attr.maxLength) : validator;
};

/**
 * Adds min integer validator
 * @returns {NumberSchema}
 */
const addMinIntegerValidator = (
  validator: yup.NumberSchema,
  {
    attr,
  }: {
    attr: Schema.Attribute.Integer | Schema.Attribute.BigInteger;
  },
  { isDraft }: ValidatorOptions
) => (_.isNumber(attr.min) && !isDraft ? validator.min(_.toInteger(attr.min)) : validator);

/**
 * Adds max integer validator
 */
const addMaxIntegerValidator = (
  validator: yup.NumberSchema,
  {
    attr,
  }: {
    attr: Schema.Attribute.Integer | Schema.Attribute.BigInteger;
  }
) => (_.isNumber(attr.max) ? validator.max(_.toInteger(attr.max)) : validator);

/**
 * Adds min float/decimal validator
 */
const addMinFloatValidator = (
  validator: yup.NumberSchema,
  {
    attr,
  }: {
    attr: Schema.Attribute.Decimal | Schema.Attribute.Float;
  },
  { isDraft }: ValidatorOptions
) => (_.isNumber(attr.min) && !isDraft ? validator.min(attr.min) : validator);

/**
 * Adds max float/decimal validator
 */
const addMaxFloatValidator = (
  validator: yup.NumberSchema,
  {
    attr,
  }: {
    attr: Schema.Attribute.Decimal | Schema.Attribute.Float;
  }
) => (_.isNumber(attr.max) ? validator.max(attr.max) : validator);

/**
 * Adds regex validator
 */
const addStringRegexValidator = (
  validator: yup.StringSchema,
  {
    attr,
  }: {
    attr:
      | Schema.Attribute.String
      | Schema.Attribute.Text
      | Schema.Attribute.RichText
      | Schema.Attribute.Password
      | Schema.Attribute.Email
      | Schema.Attribute.UID;
  },
  { isDraft }: ValidatorOptions
) => {
  return 'regex' in attr && !_.isUndefined(attr.regex) && !isDraft
    ? validator.matches(new RegExp(attr.regex), { excludeEmptyString: !attr.required })
    : validator;
};

const addUniqueValidator = <T extends yup.AnySchema>(
  validator: T,
  {
    attr,
    model,
    updatedAttribute,
    entity,
    componentContext,
  }: ValidatorMetas<Schema.Attribute.AnyAttribute & Schema.Attribute.UniqueOption>,
  options: ValidatorOptions
): T => {
  if (attr.type !== 'uid' && !attr.unique) {
    return validator;
  }

  const validateUniqueFieldWithinComponent = async (value: any): Promise<boolean> => {
    if (!componentContext) {
      return false;
    }

    // If we are validating a unique field within a repeatable component,
    // we first need to ensure that the repeatable in the current entity is
    // valid against itself.
    const hasRepeatableData = componentContext.repeatableData.length > 0;
    if (hasRepeatableData) {
      const { name: updatedName, value: updatedValue } = updatedAttribute;
      // Construct the full path to the unique field within the component.
      const pathToCheck = [...componentContext.pathToComponent.slice(1), updatedName].join('.');

      // Extract the values from the repeatable data using the constructed path
      const values = componentContext.repeatableData.map((item) => {
        return pathToCheck.split('.').reduce((acc, key) => acc[key], item as any);
      });

      // Check if the value is repeated in the current entity
      const isUpdatedAttributeRepeatedInThisEntity =
        values.filter((value) => value === updatedValue).length > 1;

      if (isUpdatedAttributeRepeatedInThisEntity) {
        return false;
      }
    }

    /**
     * When `componentContext` is present it means we are dealing with a unique
     * field within a component.
     *
     * The unique validation must consider the specific context of the
     * component, which will always be contained within a parent content type
     * and may also be nested within another component.
     *
     * We construct a query that takes into account the parent's model UID,
     * dimensions (such as draft and publish state/locale) and excludes the current
     * content type entity by its ID if provided.
     */
    const {
      model: parentModel,
      options: parentOptions,
      id: excludeId,
    } = componentContext.parentContent;

    const whereConditions: Record<string, any> = {};
    const isParentDraft = parentOptions && parentOptions.isDraft;

    whereConditions.publishedAt = isParentDraft ? null : { $notNull: true };

    if (parentOptions?.locale) {
      whereConditions.locale = parentOptions.locale;
    }

    if (excludeId && !Number.isNaN(excludeId)) {
      whereConditions.id = { $ne: excludeId };
    }

    const queryUid = parentModel.uid;
    const queryWhere = {
      ...componentContext.pathToComponent.reduceRight((acc, key) => ({ [key]: acc }), {
        [updatedAttribute.name]: value,
      }),

      ...whereConditions,
    };

    // The validation should pass if there is no other record found from the query
    return !(await strapi.db.query(queryUid).findOne({ where: queryWhere }));
  };

  const validateUniqueFieldWithinDynamicZoneComponent = async (
    startOfPath: string
  ): Promise<boolean> => {
    if (!componentContext) {
      return false;
    }

    const targetComponentUID = model.uid;
    // Ensure that the value is unique within the dynamic zone in this entity.
    const countOfValueInThisEntity = (componentContext?.fullDynamicZoneContent ?? []).reduce(
      (acc, component) => {
        if (component.__component !== targetComponentUID) {
          return acc;
        }

        const updatedValue = component[updatedAttribute.name];
        return updatedValue === updatedAttribute.value ? acc + 1 : acc;
      },
      0
    );

    if (countOfValueInThisEntity > 1) {
      // If the value is repeated in the current entity, the validation fails.
      return false;
    }

    // Build a query for the parent content type to find all entities in the
    // same locale and publication state
    type QueryType = {
      select: string[];
      where: {
        published_at?: { $eq: null } | { $ne: null };
        id?: { $ne: number };
        locale?: string;
      };
      populate: {
        [key: string]: {
          on: {
            [key: string]: {
              select: string[];
              where: { [key: string]: string | number | boolean };
            };
          };
        };
      };
    };

    // Populate the dynamic zone for any components that share the same value
    // as the updated attribute.
    const query: QueryType = {
      select: ['id'],
      where: {},
      populate: {
        [startOfPath]: {
          on: {
            [targetComponentUID]: {
              select: ['id'],
              where: { [updatedAttribute.name]: updatedAttribute.value },
            },
          },
        },
      },
    };

    const { options, id } = componentContext.parentContent;

    if (options?.isDraft !== undefined) {
      query.where.published_at = options.isDraft ? { $eq: null } : { $ne: null };
    }

    if (id) {
      query.where.id = { $ne: id };
    }

    if (options?.locale) {
      query.where.locale = options.locale;
    }

    const parentModelQueryResult = await strapi.db
      .query(componentContext.parentContent.model.uid)
      .findMany(query);

    // Filter the results to only include results that have components in the
    // dynamic zone that match the target component type.
    const filteredResults = parentModelQueryResult
      .filter((result) => Array.isArray(result[startOfPath]) && result[startOfPath].length)
      .flatMap((result) => result[startOfPath])
      .filter((dynamicZoneComponent) => dynamicZoneComponent.__component === targetComponentUID);

    if (filteredResults.length >= 1) {
      return false;
    }

    return true;
  };

  return validator.test('unique', 'This attribute must be unique', async (value) => {
    /**
     * If the attribute value is `null` or an empty string we want to skip the unique validation.
     * Otherwise it'll only accept a single entry with that value in the database.
     */
    if (_.isNil(value) || value === '') {
      return true;
    }

    /**
     * We don't validate any unique constraint for draft entries.
     */
    if (options.isDraft) {
      return true;
    }

    const hasPathToComponent = componentContext && componentContext.pathToComponent.length > 0;
    if (hasPathToComponent) {
      // Detect if we are validating within a dynamiczone by checking if the first
      // path is a dynamiczone attribute in the parent content type.
      const startOfPath = componentContext.pathToComponent[0];
      const testingDZ =
        componentContext.parentContent.model.attributes[startOfPath].type === 'dynamiczone';

      if (testingDZ) {
        return validateUniqueFieldWithinDynamicZoneComponent(startOfPath);
      }

      return validateUniqueFieldWithinComponent(value);
    }

    /**
     * Here we are validating a scalar unique field from the content type's schema.
     * We construct a query to check if the value is unique
     * considering dimensions (e.g. locale, publication state) and excluding the current entity by its ID if available.
     */
    const scalarAttributeWhere: Record<string, any> = {
      [updatedAttribute.name]: value,
      publishedAt: { $notNull: true },
    };

    if (options?.locale) {
      scalarAttributeWhere.locale = options.locale;
    }

    if (entity?.id) {
      scalarAttributeWhere.id = { $ne: entity.id };
    }

    // The validation should pass if there is no other record found from the query
    return !(await strapi.db
      .query(model.uid)
      .findOne({ where: scalarAttributeWhere, select: ['id'] }));
  });
};

/* Type validators */

const stringValidator = (
  metas: ValidatorMetas<
    | Schema.Attribute.String
    | Schema.Attribute.Text
    | Schema.Attribute.RichText
    | Schema.Attribute.Password
    | Schema.Attribute.Email
    | Schema.Attribute.UID
  >,
  options: ValidatorOptions
) => {
  let schema = yup.string().transform((val, originalVal) => originalVal);

  schema = addMinLengthValidator(schema, metas, options);
  schema = addMaxLengthValidator(schema, metas);
  schema = addStringRegexValidator(schema, metas, options);
  schema = addUniqueValidator(schema, metas, options);

  return schema;
};

export const emailValidator = (
  metas: ValidatorMetas<Schema.Attribute.Email>,
  options: ValidatorOptions
) => {
  const schema = stringValidator(metas, options);

  if (options.isDraft) {
    return schema;
  }

  return schema.email().min(
    1,
    // eslint-disable-next-line no-template-curly-in-string
    '${path} cannot be empty'
  );
};

export const uidValidator = (
  metas: ValidatorMetas<Schema.Attribute.UID>,
  options: ValidatorOptions
) => {
  const schema = stringValidator(metas, options);

  if (options.isDraft) {
    return schema;
  }

  return schema.matches(/^[A-Za-z0-9-_.~]*$/);
};

export const enumerationValidator = ({ attr }: { attr: Schema.Attribute.Enumeration }) => {
  return yup
    .string()
    .oneOf((Array.isArray(attr.enum) ? attr.enum : [attr.enum]).concat(null as any));
};

export const integerValidator = (
  metas: ValidatorMetas<Schema.Attribute.Integer | Schema.Attribute.BigInteger>,
  options: ValidatorOptions
) => {
  let schema = yup.number().integer();

  schema = addMinIntegerValidator(schema, metas, options);
  schema = addMaxIntegerValidator(schema, metas);
  schema = addUniqueValidator(schema, metas, options);

  return schema;
};

export const floatValidator = (
  metas: ValidatorMetas<Schema.Attribute.Decimal | Schema.Attribute.Float>,
  options: ValidatorOptions
) => {
  let schema = yup.number();

  schema = addMinFloatValidator(schema, metas, options);
  schema = addMaxFloatValidator(schema, metas);
  schema = addUniqueValidator(schema, metas, options);

  return schema;
};

export const bigintegerValidator = (
  metas: ValidatorMetas<Schema.Attribute.BigInteger>,
  options: ValidatorOptions
) => {
  const schema = yup.mixed();
  return addUniqueValidator(schema, metas, options);
};

export const datesValidator = (
  metas: ValidatorMetas<
    | Schema.Attribute.Date
    | Schema.Attribute.DateTime
    | Schema.Attribute.Time
    | Schema.Attribute.Timestamp
  >,
  options: ValidatorOptions
) => {
  const schema = yup.mixed();
  return addUniqueValidator(schema, metas, options);
};

export const Validators = {
  string: stringValidator,
  text: stringValidator,
  richtext: stringValidator,
  password: stringValidator,
  email: emailValidator,
  enumeration: enumerationValidator,
  boolean: () => yup.boolean(),
  uid: uidValidator,
  json: () => yup.mixed(),
  integer: integerValidator,
  biginteger: bigintegerValidator,
  float: floatValidator,
  decimal: floatValidator,
  date: datesValidator,
  time: datesValidator,
  datetime: datesValidator,
  timestamp: datesValidator,
  blocks: blocksValidator,
};
</file>

<file path="src/services/metrics/__tests__/admin-user-hash.test.ts">
import crypto from 'crypto';
// eslint-disable-next-line import/no-relative-packages
import createContext from '../../../../../../../tests/helpers/create-context';
import { generateAdminUserHash } from '../admin-user-hash';

describe('user email hash', () => {
  test('should create a hash from admin user email', () => {
    const state = {
      user: {
        email: 'testemail@strapi.io',
      },
    };

    const ctx = createContext({}, { state });

    const strapi = {
      requestContext: {
        get: jest.fn(() => ctx),
      },
    };

    const hash = crypto.createHash('sha256').update('testemail@strapi.io').digest('hex');

    const userId = generateAdminUserHash(strapi as any);
    expect(userId).toBe(hash);
  });

  test('should return empty string if user is not available on ctx', () => {
    const ctx = createContext({}, {});

    const strapi = {
      requestContext: {
        get: jest.fn(() => ctx),
      },
    };

    const userId = generateAdminUserHash(strapi as any);
    expect(userId).toBe('');
  });
});
</file>

<file path="src/services/metrics/__tests__/index.test.ts">
import { get } from 'lodash/fp';
import metrics from '../index';

const fetch = jest.fn(() => Promise.resolve());

describe('metrics', () => {
  beforeEach(() => {
    fetch.mockClear();
  });
  test('Initializes a middleware', () => {
    const use = jest.fn();

    const metricsInstance = metrics({
      config: {
        get(path: string | string[]) {
          return get(path, this);
        },
        uuid: 'test',
        environment: 'dev',
        info: {
          strapi: '0.0.0',
        },
      },
      server: {
        use,
      },
      dirs: {
        app: {
          root: process.cwd(),
        },
      },
      requestContext: {
        get: jest.fn(() => ({})),
      },
      fetch,
    } as any);

    metricsInstance.register();

    expect(use).toHaveBeenCalled();

    metricsInstance.destroy();
  });

  test('Does not init middleware if disabled', () => {
    const use = jest.fn();

    const metricsInstance = metrics({
      config: {
        get(path: string | string[]) {
          return get(path, this);
        },
        uuid: false,
        environment: 'dev',
        info: {
          strapi: '0.0.0',
        },
      },
      server: {
        use,
      },
      dirs: {
        app: {
          root: process.cwd(),
        },
      },
      requestContext: {
        get: jest.fn(() => ({})),
      },
      fetch,
    } as any);

    metricsInstance.register();

    expect(use).not.toHaveBeenCalled();

    metricsInstance.destroy();
  });

  test('Send payload with meta', () => {
    const { send } = metrics({
      config: {
        get(path: string | string[]) {
          return get(path, this);
        },
        uuid: 'test',
        environment: 'dev',
        info: {
          strapi: '0.0.0',
        },
      },
      server: {
        use() {},
      },
      dirs: {
        app: {
          root: process.cwd(),
        },
      },
      requestContext: {
        get: jest.fn(() => ({})),
      },
      fetch,
    } as any);

    send('someEvent');

    expect(fetch).toHaveBeenCalled();

    const callParameters = fetch.mock.calls[0] as any[];
    expect(callParameters[0]).toBe('https://analytics.strapi.io/api/v2/track');

    expect(callParameters[1].method).toBe('POST');
    expect(JSON.parse(callParameters[1].body)).toMatchObject({
      event: 'someEvent',
      groupProperties: {
        projectType: 'Community',
        projectId: 'test',
      },
    });
    expect(callParameters[1].headers).toMatchObject({
      'Content-Type': 'application/json',
      'X-Strapi-Event': 'someEvent',
    });

    fetch.mockClear();
  });

  test('Does not send payload when disabled', () => {
    const { send } = metrics({
      config: {
        get(path: string | string[]) {
          return get(path, this);
        },
        uuid: false,
        packageJsonStrapi: {},
        environment: 'dev',
        info: {
          strapi: '0.0.0',
        },
      },
      server: {
        use() {},
      },
      dirs: {
        app: {
          root: process.cwd(),
        },
      },
      requestContext: {
        get: jest.fn(() => ({})),
      },
      fetch,
    } as any);

    send('someEvent');

    expect(fetch).not.toHaveBeenCalled();
  });
});
</file>

<file path="src/services/metrics/__tests__/is-truthy.test.ts">
import isTruthyEnvVar from '../is-truthy';

describe('isTruthyEnvVar', () => {
  test('Handles boolean strings', () => {
    expect(isTruthyEnvVar('true')).toBe(true);

    expect(isTruthyEnvVar('false')).toBe(false);
  });

  test('Handle numbers', () => {
    expect(isTruthyEnvVar(1)).toBe(true);

    expect(isTruthyEnvVar(-1)).toBe(false);
    expect(isTruthyEnvVar(0)).toBe(false);
    expect(isTruthyEnvVar(2)).toBe(false);
  });

  test('Handles default booleans', () => {
    expect(isTruthyEnvVar(true)).toBe(true);
    expect(isTruthyEnvVar(false)).toBe(false);
  });

  test('Handles all the other values', () => {
    expect(isTruthyEnvVar(null)).toBe(false);
    expect(isTruthyEnvVar(undefined)).toBe(false);
    expect(isTruthyEnvVar({})).toBe(false);
    expect(isTruthyEnvVar([])).toBe(false);
    expect(isTruthyEnvVar(new Date())).toBe(false);
    expect(isTruthyEnvVar('some text')).toBe(false);
  });
});
</file>

<file path="src/services/metrics/__tests__/middleware.test.ts">
import createMiddleware from '../middleware';

describe('Metrics middleware', () => {
  const originalDateNow = Date.now;

  afterEach(() => {
    Date.now = originalDateNow;
  });

  test('Ignores request with extension in them', async () => {
    const sendEvent = jest.fn();

    const middleware = createMiddleware({ sendEvent });

    await middleware(
      {
        request: {
          method: 'GET',
          url: '/uploads/image.png',
        },
      } as any,
      jest.fn()
    );

    expect(sendEvent).not.toHaveBeenCalled();
  });

  test.each(['OPTIONS', 'HEAD'])('Ignores %s method', async (method) => {
    const sendEvent = jest.fn();

    const middleware = createMiddleware({ sendEvent });

    await middleware(
      {
        request: {
          method,
          url: '/some-api',
        },
      } as any,
      jest.fn()
    );

    expect(sendEvent).not.toHaveBeenCalled();
  });

  test('Stops sending after 1000 events', async () => {
    const sendEvent = jest.fn();
    const middleware = createMiddleware({ sendEvent });

    for (let i = 0; i < 2000; i += 1) {
      await middleware(
        {
          request: {
            method: 'GET',
            url: '/some-api',
          },
        } as any,
        jest.fn()
      );
    }

    expect(sendEvent).toHaveBeenCalledTimes(1000);
  });

  test('Resets counter after 24 hours', async () => {
    const sendEvent = jest.fn();
    Date.now = () => new Date('2021-01-01T00:00:00Z').getTime();

    const middleware = createMiddleware({ sendEvent });

    for (let i = 0; i < 2000; i += 1) {
      await middleware(
        {
          request: {
            method: 'GET',
            url: '/some-api',
          },
        } as any,
        jest.fn()
      );
    }

    Date.now = () => new Date('2021-01-02T00:01:00Z').getTime(); // 1 day and 1 minute later.

    await middleware(
      {
        request: {
          method: 'GET',
          url: '/some-api',
        },
      } as any,
      jest.fn()
    );

    expect(sendEvent).toHaveBeenCalledTimes(1001);
  });
});
</file>

<file path="src/services/metrics/__tests__/rate-limiter.test.ts">
import wrapWithRateLimiter from '../rate-limiter';

describe('Telemetry daily RateLimiter', () => {
  const originalDateNow = Date.now;

  afterEach(() => {
    Date.now = originalDateNow;
  });

  test('Passes event and payload to sender', async () => {
    const sender = jest.fn(() => Promise.resolve(true));

    const send = wrapWithRateLimiter(sender, { limitedEvents: ['testEvent'] });

    const payload = { key: 'value' };
    await send('notRestricted', payload as any);

    expect(sender).toHaveBeenCalledWith('notRestricted', payload);
  });

  test('Calls sender if event is not restricted', async () => {
    const sender = jest.fn(() => Promise.resolve(true));

    const send = wrapWithRateLimiter(sender, { limitedEvents: ['testEvent'] });

    await send('notRestricted');

    expect(sender).toHaveBeenCalledWith('notRestricted');
  });

  test('Calls the sender as many times as request when events is not restricted', async () => {
    const sender = jest.fn(() => Promise.resolve(true));

    const send = wrapWithRateLimiter(sender, { limitedEvents: ['testEvent'] });

    await send('notRestricted');
    await send('notRestricted');
    await send('notRestricted');

    expect(sender).toHaveBeenCalledTimes(3);
  });

  test('Calls the sender only once when event is restricted', async () => {
    const sender = jest.fn(() => Promise.resolve(true));

    const send = wrapWithRateLimiter(sender, { limitedEvents: ['restrictedEvent'] });

    await send('restrictedEvent');
    await send('restrictedEvent');
    await send('restrictedEvent');

    expect(sender).toHaveBeenCalledTimes(1);
  });

  test('Calls the sender again after 24 hours for restricted events', async () => {
    const sender = jest.fn(() => Promise.resolve(true));

    Date.now = () => new Date('2021-01-01T00:00:00Z').getTime();

    const send = wrapWithRateLimiter(sender, { limitedEvents: ['restrictedEvent'] });

    await send('restrictedEvent');
    await send('restrictedEvent');
    await send('restrictedEvent');

    expect(sender).toHaveBeenCalledTimes(1);

    Date.now = () => new Date('2021-01-02T00:01:00Z').getTime(); // 1 day and 1 minute later.

    await send('restrictedEvent');
    await send('restrictedEvent');
    await send('restrictedEvent');

    expect(sender).toHaveBeenCalledTimes(2);
  });
});
</file>

<file path="src/services/metrics/admin-user-hash.ts">
import crypto from 'crypto';
import type { Core } from '@strapi/types';

/**
 * Generate an admin user hash
 */
const generateAdminUserHash = (strapi: Core.Strapi) => {
  const ctx = strapi?.requestContext?.get();
  if (!ctx?.state?.user?.email) {
    return '';
  }
  return crypto.createHash('sha256').update(ctx.state.user.email).digest('hex');
};

export { generateAdminUserHash };
</file>

<file path="src/services/metrics/index.ts">
/**
 * Strapi telemetry package.
 * You can learn more at https://docs.strapi.io/developer-docs/latest/getting-started/usage-information.html
 */

import { Job, scheduleJob } from 'node-schedule';
import type { Core } from '@strapi/types';

import wrapWithRateLimit from './rate-limiter';
import createSender from './sender';
import createMiddleware from './middleware';
import isTruthy from './is-truthy';

const LIMITED_EVENTS = [
  'didSaveMediaWithAlternativeText',
  'didSaveMediaWithCaption',
  'didDisableResponsiveDimensions',
  'didEnableResponsiveDimensions',
  'didInitializePluginUpload',
];

const createTelemetryInstance = (strapi: Core.Strapi) => {
  const uuid = strapi.config.get('uuid');
  const telemetryDisabled = strapi.config.get('packageJsonStrapi.telemetryDisabled');
  const isDisabled =
    !uuid || isTruthy(process.env.STRAPI_TELEMETRY_DISABLED) || isTruthy(telemetryDisabled);

  const crons: Job[] = [];
  const sender = createSender(strapi);
  const sendEvent = wrapWithRateLimit(sender, { limitedEvents: LIMITED_EVENTS });

  return {
    get isDisabled() {
      return isDisabled;
    },

    register() {
      if (!isDisabled) {
        const pingCron = scheduleJob('0 0 12 * * *', () => sendEvent('ping'));
        crons.push(pingCron);

        strapi.server.use(createMiddleware({ sendEvent }));
      }
    },

    bootstrap() {},

    destroy() {
      // Clear open handles
      crons.forEach((cron) => cron.cancel());
    },

    async send(event: string, payload: Record<string, unknown> = {}) {
      if (isDisabled) return true;
      return sendEvent(event, payload);
    },
  };
};

export default createTelemetryInstance;
</file>

<file path="src/services/metrics/is-truthy.ts">
import _ from 'lodash';

const isTruthy = (val: any) => {
  return [1, true].includes(val) || ['true', '1'].includes(_.toLower(val));
};

export default isTruthy;
</file>

<file path="src/services/metrics/middleware.ts">
import type { Core } from '@strapi/types';
import type { Sender } from './sender';

interface State {
  expires: number;
  counter: number;
}

function nextResetDate(): number {
  return Date.now() + 24 * 60 * 60 * 1000; // Now + 24 hours.
}

const createMiddleware = ({ sendEvent }: { sendEvent: Sender }) => {
  const state: State = {
    expires: nextResetDate(),
    counter: 0,
  };

  const middleware: Core.MiddlewareHandler = async (ctx, next) => {
    const { url, method } = ctx.request;

    if (!url.includes('.') && ['GET', 'PUT', 'POST', 'DELETE'].includes(method)) {
      if (Date.now() > state.expires) {
        state.expires = nextResetDate();
        state.counter = 0;
      }

      // Send max. 1000 events per day.
      if (state.counter < 1000) {
        sendEvent('didReceiveRequest', { eventProperties: { url: ctx.request.url } });

        // Increase counter.
        state.counter += 1;
      }
    }

    await next();
  };

  return middleware;
};

export default createMiddleware;
</file>

<file path="src/services/metrics/rate-limiter.ts">
import type { Sender } from './sender';

interface Options {
  limitedEvents?: string[];
}

type TailParams<T extends (...args: any[]) => any> =
  Parameters<T> extends [unknown, ...infer U] ? U : never;

function nextResetDate(): number {
  return Date.now() + 24 * 60 * 60 * 1000; // Now + 24 hours.
}

export default (sender: Sender, { limitedEvents = [] }: Options = {}) => {
  let cacheExpiresAt = nextResetDate();
  const eventCache = new Map();

  return async (event: string, ...args: TailParams<Sender>) => {
    if (!limitedEvents.includes(event)) {
      return sender(event, ...args);
    }

    if (Date.now() > cacheExpiresAt) {
      eventCache.clear();
      cacheExpiresAt = nextResetDate();
    }

    if (eventCache.has(event)) {
      return false;
    }

    eventCache.set(event, true);
    return sender(event, ...args);
  };
};
</file>

<file path="src/services/metrics/sender.ts">
import os from 'os';
import path from 'path';
import _ from 'lodash';
import isDocker from 'is-docker';
import ciEnv from 'ci-info';
import tsUtils from '@strapi/typescript-utils';
import { env, machineID } from '@strapi/utils';
import type { Core } from '@strapi/types';
import { generateAdminUserHash } from './admin-user-hash';

export interface Payload {
  eventProperties?: Record<string, unknown>;
  userProperties?: Record<string, unknown>;
  groupProperties?: Record<string, unknown>;
}

export type Sender = (
  event: string,
  payload?: Payload,
  opts?: Record<string, unknown>
) => Promise<boolean>;

const defaultQueryOpts = {
  timeout: 1000,
  headers: { 'Content-Type': 'application/json' },
};

const ANALYTICS_URI = 'https://analytics.strapi.io';

/**
 * Add properties from the package.json strapi key in the metadata
 */
const addPackageJsonStrapiMetadata = (metadata: Record<string, unknown>, strapi: Core.Strapi) => {
  const { packageJsonStrapi = {} } = strapi.config;

  _.defaults(metadata, packageJsonStrapi);
};

/**
 * Create a send function for event with all the necessary metadata
 */
export default (strapi: Core.Strapi): Sender => {
  const { uuid } = strapi.config;
  const deviceId = machineID();

  const serverRootPath = strapi.dirs.app.root;
  const adminRootPath = path.join(strapi.dirs.app.root, 'src', 'admin');

  const anonymousUserProperties = {
    environment: strapi.config.environment,
    os: os.type(),
    osPlatform: os.platform(),
    osArch: os.arch(),
    osRelease: os.release(),
    nodeVersion: process.versions.node,
  };

  const anonymousGroupProperties = {
    docker: process.env.DOCKER || isDocker(),
    isCI: ciEnv.isCI,
    version: strapi.config.get('info.strapi'),
    useTypescriptOnServer: tsUtils.isUsingTypeScriptSync(serverRootPath),
    useTypescriptOnAdmin: tsUtils.isUsingTypeScriptSync(adminRootPath),
    projectId: uuid,
    isHostedOnStrapiCloud: env('STRAPI_HOSTING', null) === 'strapi.cloud',
  };

  addPackageJsonStrapiMetadata(anonymousGroupProperties, strapi);

  return async (event: string, payload: Payload = {}, opts = {}) => {
    const userId = generateAdminUserHash(strapi);

    const reqParams = {
      method: 'POST',
      body: JSON.stringify({
        event,
        userId,
        deviceId,
        eventProperties: payload.eventProperties,
        userProperties: userId ? { ...anonymousUserProperties, ...payload.userProperties } : {},
        groupProperties: {
          ...anonymousGroupProperties,
          projectType: strapi.EE ? 'Enterprise' : 'Community',
          ...payload.groupProperties,
        },
      }),
      ..._.merge({ headers: { 'X-Strapi-Event': event } }, defaultQueryOpts, opts),
    };

    try {
      const res = await strapi.fetch(`${ANALYTICS_URI}/api/v2/track`, reqParams);
      return res.ok;
    } catch (err) {
      return false;
    }
  };
};
</file>

<file path="src/services/server/admin-api.ts">
import type { Core } from '@strapi/types';
import { createAPI } from './api';

const createAdminAPI = (strapi: Core.Strapi) => {
  const opts = {
    prefix: '', // '/admin';
    type: 'admin',
  };

  return createAPI(strapi, opts);
};

export { createAdminAPI };
</file>

<file path="src/services/server/api.ts">
import Router from '@koa/router';
import type { Core } from '@strapi/types';

import { createRouteManager } from './routing';

interface Options {
  prefix?: string;
  type?: string;
}

const createAPI = (strapi: Core.Strapi, opts: Options = {}) => {
  const { prefix, type } = opts;

  const api = new Router({ prefix });

  const routeManager = createRouteManager(strapi, { type });

  return {
    listRoutes() {
      return [...api.stack];
    },

    use(fn: Router.Middleware) {
      api.use(fn);
      return this;
    },

    routes(routes: Core.Router | Core.Route[]) {
      routeManager.addRoutes(routes, api);
      return this;
    },

    mount(router: Router) {
      router.use(api.routes(), api.allowedMethods());
      return this;
    },
  };
};

export { createAPI };
</file>

<file path="src/services/server/compose-endpoint.ts">
import { toLower, castArray, trim, prop, isNil } from 'lodash/fp';
import type { Core, UID } from '@strapi/types';
import { errors } from '@strapi/utils';
import Router from '@koa/router';

import compose from 'koa-compose';
import { resolveRouteMiddlewares } from './middleware';
import { createPolicicesMiddleware } from './policy';

const getMethod = (route: Core.Route) => {
  return trim(toLower(route.method)) as Lowercase<Core.Route['method']>;
};

const getPath = (route: Core.Route) => trim(route.path);

const createRouteInfoMiddleware =
  (routeInfo: Core.Route): Core.MiddlewareHandler =>
  (ctx, next) => {
    const route = {
      ...routeInfo,
      config: routeInfo.config || {},
    };

    ctx.state.route = route;
    return next();
  };

const getAuthConfig = prop('config.auth');

const createAuthorizeMiddleware =
  (strapi: Core.Strapi): Core.MiddlewareHandler =>
  async (ctx, next) => {
    const { auth, route } = ctx.state;

    const authService = strapi.get('auth');

    try {
      await authService.verify(auth, getAuthConfig(route));

      return await next();
    } catch (error) {
      if (error instanceof errors.UnauthorizedError) {
        return ctx.unauthorized();
      }

      if (error instanceof errors.ForbiddenError) {
        // allow PolicyError as an exception to throw a publicly visible message in the API
        if (error instanceof errors.PolicyError) {
          throw error;
        }
        return ctx.forbidden();
      }

      throw error;
    }
  };

const createAuthenticateMiddleware =
  (strapi: Core.Strapi): Core.MiddlewareHandler =>
  async (ctx, next) => {
    return strapi.get('auth').authenticate(ctx, next);
  };

const returnBodyMiddleware: Core.MiddlewareHandler = async (ctx, next) => {
  const values = await next();

  if (isNil(ctx.body) && !isNil(values)) {
    ctx.body = values;
  }
};

export default (strapi: Core.Strapi) => {
  const authenticate = createAuthenticateMiddleware(strapi);
  const authorize = createAuthorizeMiddleware(strapi);

  return (route: Core.Route, { router }: { router: Router }) => {
    try {
      const method = getMethod(route);
      const path = getPath(route);

      const middlewares = resolveRouteMiddlewares(route, strapi);

      const action = getAction(route, strapi);

      const routeHandler = compose([
        createRouteInfoMiddleware(route),
        authenticate,
        authorize,
        createPolicicesMiddleware(route, strapi),
        ...middlewares,
        returnBodyMiddleware,
        ...castArray(action),
      ]);

      router[method](path, routeHandler);
    } catch (error) {
      if (error instanceof Error) {
        error.message = `Error creating endpoint ${route.method} ${route.path}: ${error.message}`;
      }

      throw error;
    }
  };
};

const getController = (
  name: string,
  { pluginName, apiName }: Core.RouteInfo,
  strapi: Core.Strapi
) => {
  let ctrl: Core.Controller | undefined;

  if (pluginName) {
    if (pluginName === 'admin') {
      ctrl = strapi.controller(`admin::${name}`);
    } else {
      ctrl = strapi.plugin(pluginName).controller(name);
    }
  } else if (apiName) {
    ctrl = strapi.controller(`api::${apiName}.${name}`);
  }

  if (!ctrl) {
    return strapi.controller(name as UID.Controller);
  }

  return ctrl;
};

const extractHandlerParts = (name: string) => {
  const controllerName = name.slice(0, name.lastIndexOf('.'));
  const actionName = name.slice(name.lastIndexOf('.') + 1);

  return { controllerName, actionName };
};

const getAction = (route: Core.Route, strapi: Core.Strapi) => {
  const { handler, info } = route;
  const { pluginName, apiName, type } = info ?? {};

  if (Array.isArray(handler) || typeof handler === 'function') {
    return handler;
  }

  const { controllerName, actionName } = extractHandlerParts(trim(handler));

  const controller = getController(controllerName, { pluginName, apiName, type }, strapi);

  if (typeof controller[actionName] !== 'function') {
    throw new Error(`Handler not found "${handler}"`);
  }

  if (Symbol.for('__type__') in controller[actionName]) {
    (controller[actionName] as any)[Symbol.for('__type__')].push(type);
  } else {
    (controller[actionName] as any)[Symbol.for('__type__')] = [type];
  }

  return controller[actionName].bind(controller);
};
</file>

<file path="src/services/server/content-api.ts">
import type { Core } from '@strapi/types';
import { createAPI } from './api';

const createContentAPI = (strapi: Core.Strapi) => {
  const opts = {
    prefix: strapi.config.get('api.rest.prefix', '/api'),
    type: 'content-api',
  };

  return createAPI(strapi, opts);
};

export { createContentAPI };
</file>

<file path="src/services/server/http-server.ts">
import http from 'http';
import type { Socket } from 'net';
import Koa from 'koa';
import type { Core } from '@strapi/types';

export interface Server extends http.Server {
  destroy: () => Promise<void>;
}

const createHTTPServer = (strapi: Core.Strapi, koaApp: Koa): Server => {
  const connections = new Set<Socket>();

  // lazy creation of the request listener
  let handler: http.RequestListener;
  const listener: http.RequestListener = function handleRequest(req, res) {
    if (!handler) {
      handler = koaApp.callback();
    }

    return handler(req, res);
  };

  const options = strapi.config.get<http.ServerOptions>('server.http.serverOptions', {});

  const server: http.Server = http.createServer(options, listener);

  server.on('connection', (connection) => {
    connections.add(connection);

    connection.on('close', () => {
      connections.delete(connection);
    });
  });

  // handle port in use cleanly
  server.on('error', (err) => {
    if ('code' in err && 'port' in err && err.code === 'EADDRINUSE') {
      return strapi.stopWithError(`The port ${err.port} is already used by another application.`);
    }

    strapi.log.error(err);
  });

  const destroy = async () => {
    for (const connection of connections) {
      connection.destroy();

      connections.delete(connection);
    }

    if (!server.listening) {
      return;
    }

    return new Promise<void>((resolve, reject) => {
      server.close((error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  };

  return Object.assign(server, { destroy });
};

export { createHTTPServer };
</file>

<file path="src/services/server/index.ts">
import Router from '@koa/router';
import type { Core, Modules } from '@strapi/types';

import { createHTTPServer } from './http-server';
import { createRouteManager } from './routing';
import { createAdminAPI } from './admin-api';
import { createContentAPI } from './content-api';
import registerAllRoutes from './register-routes';
import registerApplicationMiddlewares from './register-middlewares';
import createKoaApp from './koa';
import requestCtx from '../request-context';

const healthCheck: Core.MiddlewareHandler = async (ctx) => {
  ctx.set('strapi', 'You are so French!');
  ctx.status = 204;
};

const createServer = (strapi: Core.Strapi): Modules.Server.Server => {
  const app = createKoaApp({
    proxy: strapi.config.get('server.proxy.koa'),
    keys: strapi.config.get('server.app.keys'),
  });

  app.use((ctx, next) => requestCtx.run(ctx, () => next()));

  const router = new Router();

  const routeManager = createRouteManager(strapi);

  const httpServer = createHTTPServer(strapi, app);

  const apis = {
    'content-api': createContentAPI(strapi),
    admin: createAdminAPI(strapi),
  };

  // init health check
  router.all('/_health', healthCheck);

  const state = {
    mounted: false,
  };

  return {
    app,
    router,
    httpServer,

    api(name) {
      return apis[name];
    },

    use(...args) {
      app.use(...args);
      return this;
    },

    routes(routes: Core.Router | Omit<Core.Route, 'info'>[]) {
      if (!Array.isArray(routes) && routes.type) {
        const api = apis[routes.type];
        if (!api) {
          throw new Error(`API ${routes.type} not found. Possible APIs are ${Object.keys(apis)}`);
        }

        apis[routes.type].routes(routes);
        return this;
      }

      routeManager.addRoutes(routes, router);
      return this;
    },

    mount() {
      state.mounted = true;

      Object.values(apis).forEach((api) => api.mount(router));
      app.use(router.routes()).use(router.allowedMethods());

      return this;
    },

    initRouting() {
      registerAllRoutes(strapi);

      return this;
    },

    async initMiddlewares() {
      await registerApplicationMiddlewares(strapi);

      return this;
    },

    listRoutes() {
      return [...router.stack];
    },

    listen(...args: any[]) {
      if (!state.mounted) {
        this.mount();
      }

      return httpServer.listen(...args);
    },

    async destroy() {
      await httpServer.destroy();
    },
  };
};

export { createServer };
</file>

<file path="src/services/server/koa.ts">
import { isNil, camelCase } from 'lodash/fp';
import Koa from 'koa';
import createError from 'http-errors';
import delegate from 'delegates';
import statuses from 'statuses';
import { formatHttpError } from '../errors';

declare module 'koa' {
  interface BaseResponse {
    send: (data: any, status?: number) => void;
    created: (data: any) => void;
    deleted: (data: any) => void;
    _explicitStatus: boolean;
    [key: string]: (message: string, details?: unknown) => void;
  }
}

const addCustomMethods = (app: Koa) => {
  const delegator = delegate(app.context, 'response');

  /* errors */
  statuses.codes
    .filter((code) => code >= 400 && code < 600)
    .forEach((code) => {
      const name = statuses(code);

      const camelCasedName = camelCase(name);
      app.response[camelCasedName] = function responseCode(message = name, details = {}) {
        const httpError = createError(code, message, { details });
        const { status, body } = formatHttpError(httpError);
        this.status = status;
        this.body = body;
      };
      delegator.method(camelCasedName);
    });

  /* send, created, deleted */
  app.response.send = function send(data, status = 200) {
    this.status = status;
    this.body = data;
  };

  app.response.created = function created(data) {
    this.status = 201;
    this.body = data;
  };

  app.response.deleted = function deleted(data) {
    if (isNil(data)) {
      this.status = 204;
    } else {
      this.status = 200;
      this.body = data;
    }
  };

  delegator.method('send').method('created').method('deleted');

  return app;
};

const createKoaApp = ({ proxy, keys }: { proxy: boolean; keys: string[] }) => {
  const app = new Koa({ proxy });
  app.keys = keys;

  addCustomMethods(app);

  return app;
};

export default createKoaApp;
</file>

<file path="src/services/server/middleware.ts">
import path from 'path';
import { isArray } from 'lodash/fp';
import { importDefault } from '@strapi/utils';
import type { Core } from '@strapi/types';

const instantiateMiddleware = (
  middlewareFactory: Core.MiddlewareFactory,
  name: string,
  config: unknown,
  strapi: Core.Strapi
) => {
  try {
    return middlewareFactory(config, { strapi });
  } catch (e) {
    if (e instanceof Error) {
      throw new Error(`Middleware "${name}": ${e.message}`);
    }
  }
};

const resolveRouteMiddlewares = (route: Core.Route, strapi: Core.Strapi) => {
  const middlewaresConfig = route?.config?.middlewares ?? [];

  if (!isArray(middlewaresConfig)) {
    throw new Error('Route middlewares config must be an array');
  }

  const middlewares = resolveMiddlewares(middlewaresConfig, strapi);

  return middlewares.map(({ handler }) => handler);
};

const dummyMiddleware: Core.MiddlewareHandler = (_, next) => next();

/**
 * Initialize every configured middlewares
 */
const resolveMiddlewares = (
  config: Array<Core.MiddlewareName | Core.MiddlewareConfig | Core.MiddlewareHandler>,
  strapi: Core.Strapi
) => {
  const middlewares: {
    name: string | null;
    handler: Core.MiddlewareHandler;
  }[] = [];

  for (const item of config) {
    if (typeof item === 'function') {
      middlewares.push({
        name: null,
        handler: item,
      });

      continue;
    }

    if (typeof item === 'string') {
      const middlewareFactory = strapi.middleware(item);

      if (!middlewareFactory) {
        throw new Error(`Middleware ${item} not found.`);
      }

      middlewares.push({
        name: item,
        handler: instantiateMiddleware(middlewareFactory, item, {}, strapi) ?? dummyMiddleware,
      });

      continue;
    }

    if (typeof item === 'object' && item !== null) {
      const { name, resolve, config = {} } = item;

      if (name) {
        const middlewareFactory = strapi.middleware(name);
        middlewares.push({
          name,
          handler:
            instantiateMiddleware(middlewareFactory, name, config, strapi) ?? dummyMiddleware,
        });

        continue;
      }

      if (resolve) {
        const resolvedMiddlewareFactory = resolveCustomMiddleware(resolve, strapi);
        middlewares.push({
          name: resolve,
          handler:
            instantiateMiddleware(resolvedMiddlewareFactory, resolve, config, strapi) ??
            dummyMiddleware,
        });

        continue;
      }

      throw new Error('Invalid middleware configuration. Missing name or resolve properties.');
    }

    throw new Error(
      'Middleware config must either be a string or an object {name?: string, resolve?: string, config: any}.'
    );
  }

  return middlewares;
};

/**
 * Resolve middleware from package name or path
 */
const resolveCustomMiddleware = (resolve: string, strapi: Core.Strapi) => {
  let modulePath;

  try {
    modulePath = require.resolve(resolve);
  } catch (error) {
    if (error instanceof Error && 'code' in error && error.code === 'MODULE_NOT_FOUND') {
      modulePath = path.resolve(strapi.dirs.dist.root, resolve);
    } else {
      throw error;
    }
  }

  try {
    return importDefault(modulePath);
  } catch (err) {
    throw new Error(`Could not load middleware "${modulePath}".`);
  }
};

export { resolveRouteMiddlewares, resolveMiddlewares };
</file>

<file path="src/services/server/policy.ts">
import { policy as policyUtils, errors } from '@strapi/utils';
import type { Core } from '@strapi/types';

const createPolicicesMiddleware = (route: Core.Route, strapi: Core.Strapi) => {
  const policiesConfig = route?.config?.policies ?? [];
  const resolvedPolicies = strapi.get('policies').resolve(policiesConfig, route.info);

  const policiesMiddleware: Core.MiddlewareHandler = async (ctx, next) => {
    const context = policyUtils.createPolicyContext('koa', ctx);

    for (const { handler, config } of resolvedPolicies) {
      const result = await handler(context, config, { strapi });

      if (![true, undefined].includes(result)) {
        throw new errors.PolicyError();
      }
    }

    await next();
  };

  return policiesMiddleware;
};

export { createPolicicesMiddleware };
</file>

<file path="src/services/server/register-middlewares.ts">
import { yup } from '@strapi/utils';
import type { Core } from '@strapi/types';
import { resolveMiddlewares } from './middleware';

type MiddlewareConfig = (string | { name?: string; resolve?: string; config?: unknown })[];

const defaultConfig = [
  'strapi::logger',
  'strapi::errors',
  'strapi::security',
  'strapi::cors',
  'strapi::poweredBy',
  'strapi::session',
  'strapi::query',
  'strapi::body',
  'strapi::favicon',
  'strapi::public',
];

const requiredMiddlewares = [
  'strapi::errors',
  'strapi::security',
  'strapi::cors',
  'strapi::query',
  'strapi::body',
  'strapi::public',
  'strapi::favicon',
];

const middlewareConfigSchema = yup.array().of(
  yup.lazy((value) => {
    if (typeof value === 'string') {
      return yup.string().required();
    }

    if (typeof value === 'object') {
      return yup
        .object({
          name: yup.string(),
          resolve: yup.string(),
          config: yup.mixed(),
        })
        .required()
        .noUnknown();
    }

    return yup.mixed().test(() => false);
  }) as any // FIXME: yup v1
);

/**
 * Register middlewares in router
 */
const registerApplicationMiddlewares = async (strapi: Core.Strapi) => {
  const middlewareConfig: MiddlewareConfig = strapi.config.get('middlewares', defaultConfig);

  await validateMiddlewareConfig(middlewareConfig);

  const middlewares = await resolveMiddlewares(middlewareConfig, strapi);

  checkRequiredMiddlewares(middlewares);

  // NOTE: exclude middlewares that return nothing.
  // this is used for middlewares that only extend the app only need to be added in certain conditions
  for (const middleware of middlewares) {
    strapi.server.use(middleware.handler);
  }
};

/**
 *
 * @param {MiddlewaresConfig} config
 */
const validateMiddlewareConfig = async (config: MiddlewareConfig) => {
  try {
    await middlewareConfigSchema.validate(config, { strict: true, abortEarly: false });
  } catch (error) {
    throw new Error(
      'Invalid middleware configuration. Expected Array<string|{name?: string, resolve?: string, config: any}.'
    );
  }
};

/**
 * Check if some required middlewares are missing in configure middlewares
 * @param {Middlewares} middlewares
 */
const checkRequiredMiddlewares = (middlewares: { name: string | null }[]) => {
  const missingMiddlewares = requiredMiddlewares.filter((name) => {
    return middlewares.findIndex((mdl) => mdl.name === name) === -1;
  });

  if (missingMiddlewares.length > 0) {
    throw new Error(
      `Missing required middlewares in configuration. Add the following middlewares: "${missingMiddlewares.join(
        ', '
      )}".`
    );
  }
};

export default registerApplicationMiddlewares;
</file>

<file path="src/services/server/register-routes.ts">
import _ from 'lodash';
import type { Core } from '@strapi/types';

const createRouteScopeGenerator = (namespace: string) => (route: Core.RouteInput) => {
  const prefix = namespace.endsWith('::') ? namespace : `${namespace}.`;

  if (typeof route.handler === 'string') {
    _.defaultsDeep(route, {
      config: {
        auth: {
          scope: [`${route.handler.startsWith(prefix) ? '' : prefix}${route.handler}`],
        },
      },
    });
  }
};

/**
 * Register all routes
 */
export default (strapi: Core.Strapi) => {
  registerAdminRoutes(strapi);
  registerAPIRoutes(strapi);
  registerPluginRoutes(strapi);
};

/**
 * Register admin routes
 * @param {import('../../').Strapi} strapi
 */
const registerAdminRoutes = (strapi: Core.Strapi) => {
  const generateRouteScope = createRouteScopeGenerator(`admin::`);

  _.forEach(strapi.admin.routes, (router) => {
    router.type = router.type || 'admin';
    router.prefix = router.prefix || `/admin`;
    router.routes.forEach((route) => {
      generateRouteScope(route);
      route.info = { pluginName: 'admin' };
    });
    strapi.server.routes(router);
  });
};

/**
 * Register plugin routes
 * @param {import('../../').Strapi} strapi
 */
const registerPluginRoutes = (strapi: Core.Strapi) => {
  for (const pluginName of Object.keys(strapi.plugins)) {
    const plugin = strapi.plugins[pluginName];

    const generateRouteScope = createRouteScopeGenerator(`plugin::${pluginName}`);

    if (Array.isArray(plugin.routes)) {
      plugin.routes.forEach((route) => {
        generateRouteScope(route);
        route.info = { pluginName };
      });

      strapi.server.routes({
        type: 'admin',
        prefix: `/${pluginName}`,
        routes: plugin.routes,
      });
    } else {
      _.forEach(plugin.routes, (router) => {
        router.type = router.type || 'admin';
        router.prefix = router.prefix || `/${pluginName}`;
        router.routes.forEach((route) => {
          generateRouteScope(route);
          route.info = { pluginName };
        });

        strapi.server.routes(router);
      });
    }
  }
};

/**
 * Register api routes
 */
const registerAPIRoutes = (strapi: Core.Strapi) => {
  for (const apiName of Object.keys(strapi.apis)) {
    const api = strapi.api(apiName);

    const generateRouteScope = createRouteScopeGenerator(`api::${apiName}`);

    _.forEach(api.routes, (router) => {
      // TODO: remove once auth setup
      // pass meta down to compose endpoint
      router.type = 'content-api';
      router.routes?.forEach((route) => {
        generateRouteScope(route);
        route.info = { apiName };
      });

      return strapi.server.routes(router);
    });
  }
};
</file>

<file path="src/services/server/routing.ts">
import Router from '@koa/router';
import { has } from 'lodash/fp';
import { yup } from '@strapi/utils';
import type { Core } from '@strapi/types';

import createEndpointComposer from './compose-endpoint';

const policyOrMiddlewareSchema = yup.lazy((value) => {
  if (typeof value === 'string') {
    return yup.string().required();
  }

  if (typeof value === 'function') {
    return yup.mixed().isFunction();
  }

  return yup.object({
    name: yup.string().required(),
    options: yup.object().notRequired(), // any options
  });
});

const routeSchema = yup.object({
  method: yup.string().oneOf(['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'ALL']).required(),
  path: yup.string().required(),
  handler: yup.lazy((value) => {
    if (typeof value === 'string') {
      return yup.string().required();
    }

    if (Array.isArray(value)) {
      return yup.array().required();
    }

    return yup.mixed().isFunction().required();
  }),
  config: yup
    .object({
      auth: yup.lazy((value) => {
        if (value === false) {
          return yup.boolean().required();
        }

        return yup.object({
          scope: yup.array().of(yup.string()).required(),
        });
      }),
      policies: yup
        .array()
        // FIXME: fixed in yup v1
        .of(policyOrMiddlewareSchema as any)
        .notRequired(),
      middlewares: yup
        .array()
        // FIXME: fixed in yup v1
        .of(policyOrMiddlewareSchema as any)
        .notRequired(),
    })
    .notRequired(),
});

const validateRouteConfig = (routeConfig: Core.RouteInput) => {
  try {
    return routeSchema.validateSync(routeConfig, {
      strict: true,
      abortEarly: false,
      stripUnknown: true,
    });
  } catch (error) {
    if (error instanceof yup.ValidationError) {
      throw new Error(`Invalid route config ${error.message}`);
    }
  }
};

const createRouteManager = (strapi: Core.Strapi, opts: { type?: string } = {}) => {
  const { type } = opts;

  const composeEndpoint = createEndpointComposer(strapi);

  const createRoute = (route: Core.RouteInput, router: Router) => {
    validateRouteConfig(route);

    // NOTE: the router type is used to tag controller actions and for authentication / authorization so we need to pass this info down to the route level
    const routeWithInfo = Object.assign(route, {
      info: {
        ...(route.info ?? {}),
        type: type || 'api',
      },
    });

    composeEndpoint(routeWithInfo, { router });
  };

  const addRoutes = (routes: Core.Router | Core.RouteInput[], router: Router) => {
    if (Array.isArray(routes)) {
      routes.forEach((route) => createRoute(route, router));
    } else if (routes.routes) {
      const subRouter = new Router({ prefix: routes.prefix });

      routes.routes.forEach((route) => {
        const hasPrefix = has('prefix', route.config);
        createRoute(route, hasPrefix ? router : subRouter);
      });

      return router.use(subRouter.routes(), subRouter.allowedMethods());
    }
  };

  return {
    addRoutes,
  };
};

export { validateRouteConfig, createRouteManager };
</file>

<file path="src/services/utils/dynamic-zones.ts">
import { map, values, sumBy, pipe, flatMap } from 'lodash/fp';
import type { Schema, UID } from '@strapi/types';

const getNumberOfDynamicZones = () => {
  const contentTypes: Record<UID.ContentType, Schema.ContentType> = strapi.contentTypes;

  return pipe(
    map('attributes'),
    flatMap(values),
    sumBy((item) => {
      if (item.type === 'dynamiczone') {
        return 1;
      }
      return 0;
    })
  )(contentTypes);
};

export default getNumberOfDynamicZones;
</file>

<file path="src/services/config.ts">
import type { Core } from '@strapi/types';
import { get, set, has, isString, isNumber, isArray, type PropertyPath } from 'lodash';

type State = {
  config: Config;
};

type Config = Record<string, unknown>;

export const createConfigProvider = (
  initialConfig: Record<string, unknown> = {},
  strapi?: Core.Strapi
): Core.ConfigProvider => {
  const state: State = {
    config: { ...initialConfig }, // not deep clone because it would break some config
  };

  // Accessing model configs with dot (.) was deprecated between v4->v5, but to avoid a major breaking change
  // we will still support certain namespaces, currently only 'plugin.'
  const transformPathString = (path: string) => {
    if (path.startsWith('plugin.')) {
      const newPath = path.replace('plugin.', 'plugin::');

      // strapi logger may not be loaded yet, so fall back to console
      (strapi?.log?.warn ?? console.warn)(
        `Using dot notation for model config namespaces is deprecated, for example "plugin::myplugin" should be used instead of "plugin.myplugin". Modifying requested path ${path} to ${newPath}`
      );
      return newPath;
    }

    return path;
  };

  const transformDeprecatedPaths = (path: PropertyPath): PropertyPath => {
    if (isString(path)) {
      return transformPathString(path);
    }
    if (isArray(path)) {
      // if the path is not joinable, we won't apply our deprecation support
      if (path.some((part) => !(isString(part) || isNumber(part)))) {
        return path;
      }

      return transformPathString(path.join('.'));
    }

    return path;
  };

  return {
    ...state.config, // TODO: to remove
    get(path: PropertyPath, defaultValue?: unknown) {
      return get(state.config, transformDeprecatedPaths(path), defaultValue);
    },
    set(path: PropertyPath, val: unknown) {
      set(state.config, transformDeprecatedPaths(path), val);
      return this;
    },
    has(path: PropertyPath) {
      return has(state.config, transformDeprecatedPaths(path));
    },
  };
};
</file>

<file path="src/services/core-store.ts">
import { toString } from 'lodash/fp';
import type { Database, Model } from '@strapi/database';

const coreStoreModel: Model = {
  uid: 'strapi::core-store',
  singularName: 'strapi_core_store_settings',
  tableName: 'strapi_core_store_settings',
  attributes: {
    id: {
      type: 'increments',
    },
    key: {
      type: 'string',
    },
    value: {
      type: 'text',
    },
    type: {
      type: 'string',
    },
    environment: {
      type: 'string',
    },
    tag: {
      type: 'string',
    },
  },
};

type SetParams = {
  key: string;
  value: unknown;
  type?: string;
  environment?: string;
  name?: string;
  tag?: string;
};

type GetParams = {
  key: string;
  type?: string;
  environment?: string;
  name?: string;
  tag?: string;
};

type Params = SetParams & GetParams;

interface CoreStore {
  (defaultParams: Partial<Params>): {
    get(params: Partial<GetParams>): Promise<unknown>;
    set(params: Partial<SetParams>): Promise<void>;
    delete(params: Partial<GetParams>): Promise<void>;
  };
  get(params: GetParams): Promise<unknown>;
  set(params: SetParams): Promise<void>;
  delete(params: GetParams): Promise<void>;
}

const createCoreStore = ({ db }: { db: Database }) => {
  const mergeParams = (defaultParams: Partial<Params>, params: Params): Params => {
    return {
      ...defaultParams,
      ...params,
    };
  };

  const store: CoreStore = function (defaultParams: Partial<Params>) {
    return {
      get: (params: Params) => store.get(mergeParams(defaultParams, params)),
      set: (params: Params) => store.set(mergeParams(defaultParams, params)),
      delete: (params: Params) => store.delete(mergeParams(defaultParams, params)),
    };
  };

  /**
   * Get value from the core store
   */
  store.get = async (params) => {
    const { key, type = 'core', environment, name, tag } = params;

    const prefix = `${type}${name ? `_${name}` : ''}`;

    const where = {
      key: `${prefix}_${key}`,
      environment: environment || null,
      tag: tag || null,
    };

    const data = await db.query('strapi::core-store').findOne({ where });

    if (!data) {
      return null;
    }

    if (
      data.type === 'object' ||
      data.type === 'array' ||
      data.type === 'boolean' ||
      data.type === 'string'
    ) {
      try {
        return JSON.parse(data.value);
      } catch (err) {
        return new Date(data.value);
      }
    } else if (data.type === 'number') {
      return Number(data.value);
    } else {
      return null;
    }
  };

  /**
   * Set value in the core store
   * @param {Object} params
   * @returns {*}
   */
  store.set = async (params) => {
    const { key, value, type, environment, name, tag } = params;

    const prefix = `${type}${name ? `_${name}` : ''}`;

    const where = {
      key: `${prefix}_${key}`,
      environment: environment || null,
      tag: tag || null,
    };

    const data = await db.query('strapi::core-store').findOne({ where });

    if (data) {
      return db.query('strapi::core-store').update({
        where: { id: data.id },
        data: {
          value: JSON.stringify(value) || toString(value),
          type: typeof value,
        },
      });
    }

    return db.query('strapi::core-store').create({
      data: {
        ...where,
        value: JSON.stringify(value) || toString(value),
        type: typeof value,
      },
    });
  };

  /**
   * Deletes a value from the core store
   * @param {Object} params
   * @returns {*}
   */
  store.delete = async (params) => {
    const { key, environment, type, name, tag } = params;

    const prefix = `${type}${name ? `_${name}` : ''}`;

    const where = {
      key: `${prefix}_${key}`,
      environment: environment || null,
      tag: tag || null,
    };

    return db.query('strapi::core-store').delete({ where });
  };

  return store;
};

export { coreStoreModel, createCoreStore };
</file>

<file path="src/services/cron.ts">
import { Job, Spec } from 'node-schedule';
import { isFunction } from 'lodash/fp';
import type { Core } from '@strapi/types';

interface JobSpec {
  job: Job;
  options: Spec;
  name: string | null;
}

type TaskFn = ({ strapi }: { strapi: Core.Strapi }, ...args: unknown[]) => Promise<unknown>;

type Task =
  | TaskFn
  | {
      task: TaskFn;
      options: Spec;
    };

interface Tasks {
  [key: string]: Task;
}

const createCronService = () => {
  let jobsSpecs: JobSpec[] = [];
  let running = false;

  return {
    add(tasks: Tasks = {}) {
      for (const taskExpression of Object.keys(tasks)) {
        const taskValue = tasks[taskExpression];

        let fn: TaskFn;
        let options: Spec;
        let taskName: string | null;
        if (isFunction(taskValue)) {
          // don't use task name if key is the rule
          taskName = null;
          fn = taskValue.bind(tasks);
          options = taskExpression;
        } else if (isFunction(taskValue.task)) {
          // set task name if key is not the rule
          taskName = taskExpression;
          fn = taskValue.task.bind(taskValue);
          options = taskValue.options;
        } else {
          throw new Error(
            `Could not schedule a cron job for "${taskExpression}": no function found.`
          );
        }

        const fnWithStrapi = (...args: unknown[]) => fn({ strapi }, ...args);

        // const job = new Job(null, fnWithStrapi);
        const job = new Job(fnWithStrapi);
        jobsSpecs.push({ job, options, name: taskName });

        if (running) {
          job.schedule(options);
        }
      }
      return this;
    },

    remove(name: string) {
      if (!name) throw new Error('You must provide a name to remove a cron job.');
      const matchingJobsSpecs = jobsSpecs.filter(({ name: jobSpecName }, index) => {
        if (jobSpecName === name) {
          jobsSpecs.splice(index, 1);
          return true;
        }
        return false;
      });
      matchingJobsSpecs.forEach(({ job }) => job.cancel());
      return this;
    },

    start() {
      jobsSpecs.forEach(({ job, options }) => job.schedule(options));
      running = true;
      return this;
    },

    stop() {
      jobsSpecs.forEach(({ job }) => job.cancel());
      running = false;
      return this;
    },

    destroy() {
      this.stop();
      jobsSpecs = [];
      return this;
    },
    jobs: jobsSpecs,
  };
};

export default createCronService;
</file>

<file path="src/services/custom-fields.ts">
import type { Core, Modules } from '@strapi/types';

const createCustomFields = (strapi: Core.Strapi): Modules.CustomFields.CustomFields => {
  return {
    register(customField) {
      strapi.get('custom-fields').add(customField);
    },
  };
};

export default createCustomFields;
</file>

<file path="src/services/errors.ts">
import createError from 'http-errors';
import { errors } from '@strapi/utils';

const mapErrorsAndStatus = [
  {
    classError: errors.UnauthorizedError,
    status: 401,
  },
  {
    classError: errors.ForbiddenError,
    status: 403,
  },
  {
    classError: errors.NotFoundError,
    status: 404,
  },
  {
    classError: errors.PayloadTooLargeError,
    status: 413,
  },
  {
    classError: errors.RateLimitError,
    status: 429,
  },
  {
    classError: errors.NotImplementedError,
    status: 501,
  },
];

const formatApplicationError = (error: InstanceType<typeof errors.ApplicationError>) => {
  const errorAndStatus = mapErrorsAndStatus.find((pair) => error instanceof pair.classError);
  const status = errorAndStatus ? errorAndStatus.status : 400;

  return {
    status,
    body: {
      data: null,
      error: {
        status,
        name: error.name,
        message: error.message,
        details: error.details,
      },
    },
  };
};

const formatHttpError = (error: createError.HttpError) => {
  return {
    status: error.status,
    body: {
      data: null,
      error: {
        status: error.status,
        name: error.name,
        message: error.message,
        details: error.details,
      },
    },
  };
};

const formatInternalError = (error: unknown) => {
  if (!(error instanceof Error)) {
    return formatHttpError(createError(500));
  }

  const httpError = createError(error);

  if (httpError.expose) {
    return formatHttpError(httpError);
  }

  return formatHttpError(createError(httpError.status || 500));
};

export { formatApplicationError, formatHttpError, formatInternalError };
</file>

<file path="src/services/event-hub.ts">
export type Subscriber = (eventName: string, ...args: any[]) => Promise<void>;
export type Listener = (...args: any[]) => Promise<void>;

export interface EventHub {
  emit(eventName: string, ...args: unknown[]): Promise<void>;
  subscribe(subscriber: Subscriber): () => void;
  unsubscribe(subscriber: Subscriber): void;
  on(eventName: string, listener: Listener): () => void;
  off(eventName: string, listener: Listener): void;
  once(eventName: string, listener: Listener): () => void;
  destroy(): EventHub;
  removeListener(eventName: string, listener: Listener): void;
  removeAllListeners(): EventHub;
  removeAllSubscribers(): EventHub;
  addListener(eventName: string, listener: Listener): () => void;
}

/**
 * The event hub is Strapi's event control center.
 */
export default function createEventHub(): EventHub {
  const listeners = new Map();

  // Default subscriber to easily add listeners with the on() method
  const defaultSubscriber = async (eventName: string, ...args: unknown[]) => {
    if (listeners.has(eventName)) {
      for (const listener of listeners.get(eventName)) {
        await listener(...args);
      }
    }
  };

  // Store of subscribers that will be called when an event is emitted
  const subscribers = [defaultSubscriber];

  const eventHub: EventHub = {
    async emit(eventName, ...args) {
      for (const subscriber of subscribers) {
        await subscriber(eventName, ...args);
      }
    },

    subscribe(subscriber) {
      subscribers.push(subscriber);

      // Return a function to remove the subscriber
      return () => {
        eventHub.unsubscribe(subscriber);
      };
    },

    unsubscribe(subscriber) {
      const subscriberIndex = subscribers.indexOf(subscriber);

      // Only remove the subscriber if it exists
      if (subscriberIndex >= 0) {
        subscribers.splice(subscriberIndex, 1);
      }
    },

    on(eventName, listener) {
      if (!listeners.has(eventName)) {
        listeners.set(eventName, [listener]);
      } else {
        listeners.get(eventName).push(listener);
      }

      // Return a function to remove the listener
      return () => {
        eventHub.off(eventName, listener);
      };
    },

    off(eventName, listener) {
      listeners.get(eventName)?.splice(listeners.get(eventName).indexOf(listener), 1);
    },

    once(eventName, listener) {
      return eventHub.on(eventName, async (...args) => {
        eventHub.off(eventName, listener);
        return listener(...args);
      });
    },

    destroy() {
      this.removeAllListeners();
      this.removeAllSubscribers();
      return this;
    },

    removeListener(eventName, listener) {
      return eventHub.off(eventName, listener);
    },

    removeAllListeners() {
      listeners.clear();
      return this;
    },

    removeAllSubscribers() {
      subscribers.length = 0;
      return this;
    },

    addListener(eventName, listener) {
      return eventHub.on(eventName, listener);
    },
  };

  return eventHub;
}
</file>

<file path="src/services/features.ts">
/**
 * The features service is responsible for managing features within strapi,
 * including interacting with the feature configuration file to know
 * which are enabled and disabled.
 */

import type { Core, Modules } from '@strapi/types';

type FeatureName = keyof Modules.Features.FeaturesConfig['future'];

const createFeaturesService = (strapi: Core.Strapi): Modules.Features.FeaturesService => {
  const service: Modules.Features.FeaturesService = {
    get config() {
      return strapi.config.get<Modules.Features.FeaturesService['config']>('features');
    },
    future: {
      isEnabled(futureFlagName: string): boolean {
        return service.config?.future?.[futureFlagName as FeatureName] === true;
      },
    },
  };

  return service;
};

export { createFeaturesService };
export type FeaturesService = Modules.Features.FeaturesService;
</file>

<file path="src/services/fs.ts">
import path from 'path';
import fse from 'fs-extra';

import type { Core } from '@strapi/types';

interface StrapiFS {
  writeAppFile(optPath: string | string[], data: string): Promise<void>;
  writePluginFile(plugin: string, optPath: string | string[], data: string): Promise<void>;
  removeAppFile(optPath: string | string[]): Promise<void>;
  appendFile(optPath: string | string[], data: string): void;
}

/**
 * create strapi fs layer
 */
export default (strapi: Core.Strapi) => {
  function normalizePath(optPath: string | string[]) {
    const filePath = Array.isArray(optPath) ? optPath.join('/') : optPath;

    const normalizedPath = path.normalize(filePath).replace(/^\/?(\.\/|\.\.\/)+/, '');

    return path.resolve(strapi.dirs.app.root, normalizedPath);
  }

  const strapiFS: StrapiFS = {
    /**
     * Writes a file in a strapi app
     * @param {Array|string} optPath - file path
     * @param {string} data - content
     */
    writeAppFile(optPath, data) {
      const writePath = normalizePath(optPath);
      return fse.ensureFile(writePath).then(() => fse.writeFile(writePath, data));
    },

    /**
     * Writes a file in a plugin extensions folder
     * @param {string} plugin - plugin name
     * @param {Array|string} optPath - path to file
     * @param {string} data - content
     */
    writePluginFile(plugin, optPath, data) {
      const newPath = ['extensions', plugin].concat(optPath).join('/');
      return strapiFS.writeAppFile(newPath, data);
    },

    /**
     * Removes a file in strapi app
     */
    removeAppFile(optPath) {
      const removePath = normalizePath(optPath);
      return fse.remove(removePath);
    },

    /**
     * Appends a file in strapi app
     */
    appendFile(optPath, data) {
      const writePath = normalizePath(optPath);
      return fse.appendFileSync(writePath, data);
    },
  };

  return strapiFS;
};
</file>

<file path="src/services/query-params.ts">
import { queryParams } from '@strapi/utils';
import type { Core, UID } from '@strapi/types';

export default (strapi: Core.Strapi) => {
  const { transformQueryParams } = queryParams.createTransformer({
    getModel: (uid: string) => strapi.getModel(uid as UID.Schema),
  });

  return {
    transform: transformQueryParams,
  };
};
</file>

<file path="src/services/reloader.ts">
import type { Core } from '@strapi/types';

export const createReloader = (strapi: Core.Strapi) => {
  const state = {
    shouldReload: 0,
    isWatching: true,
  };

  function reload() {
    if (state.shouldReload > 0) {
      // Reset the reloading state
      state.shouldReload -= 1;
      reload.isReloading = false;
      return;
    }

    if (strapi.config.get('autoReload')) {
      process.send?.('reload');
    }
  }

  Object.defineProperty(reload, 'isWatching', {
    configurable: true,
    enumerable: true,
    set(value) {
      // Special state when the reloader is disabled temporarly (see GraphQL plugin example).
      if (state.isWatching === false && value === true) {
        state.shouldReload += 1;
      }
      state.isWatching = value;
    },
    get() {
      return state.isWatching;
    },
  });

  reload.isReloading = false;
  reload.isWatching = true;

  return reload;
};
</file>

<file path="src/services/request-context.ts">
import { AsyncLocalStorage } from 'async_hooks';
import type { ParameterizedContext } from 'koa';

const storage = new AsyncLocalStorage<ParameterizedContext>();

const requestCtx = {
  async run(store: ParameterizedContext, cb: () => Promise<void>) {
    return storage.run(store, cb);
  },

  get() {
    return storage.getStore();
  },
};

export default requestCtx;
</file>

<file path="src/services/webhook-runner.ts">
/**
 * The event hub is Strapi's event control center.
 */

import createdDebugger from 'debug';
import _ from 'lodash';
import type { Logger } from '@strapi/logger';

import type { Modules } from '@strapi/types';
import WorkerQueue from './worker-queue';
import type { EventHub } from './event-hub';
import type { Fetch } from '../utils/fetch';

type Webhook = Modules.WebhookStore.Webhook;

interface Config {
  defaultHeaders: Record<string, string>;
}

interface ConstructorParameters {
  eventHub: EventHub;
  logger: Logger;
  configuration?: Record<string, unknown>;
  fetch: Fetch;
}

interface Event {
  event: string;
  info: Record<string, unknown>;
}

type Listener = (info: Record<string, unknown>) => Promise<void>;

const debug = createdDebugger('strapi:webhook');

const defaultConfiguration: Config = {
  defaultHeaders: {},
};

class WebhookRunner {
  private eventHub: EventHub;

  private logger: Logger;

  private config: Config;

  private webhooksMap: Map<string, Webhook[]> = new Map();

  private listeners: Map<string, Listener> = new Map();

  private queue: WorkerQueue<Event, void>;

  private fetch: Fetch;

  constructor({ eventHub, logger, configuration = {}, fetch }: ConstructorParameters) {
    debug('Initialized webhook runner');
    this.eventHub = eventHub;
    this.logger = logger;
    this.fetch = fetch;

    if (typeof configuration !== 'object') {
      throw new Error(
        'Invalid configuration provided to the webhookRunner.\nCheck your server.json -> webhooks configuration'
      );
    }

    this.config = _.merge(defaultConfiguration, configuration);

    this.queue = new WorkerQueue({ logger, concurrency: 5 });

    this.queue.subscribe(this.executeListener.bind(this));
  }

  deleteListener(event: string) {
    debug(`Deleting listener for event '${event}'`);

    const fn = this.listeners.get(event);

    if (fn !== undefined) {
      this.eventHub.off(event, fn);
      this.listeners.delete(event);
    }
  }

  createListener(event: string) {
    debug(`Creating listener for event '${event}'`);
    if (this.listeners.has(event)) {
      this.logger.error(
        `The webhook runner is already listening for the event '${event}'. Did you mean to call .register() ?`
      );
    }

    const listen = async (info: Event['info']) => {
      this.queue.enqueue({ event, info });
    };

    this.listeners.set(event, listen);
    this.eventHub.on(event, listen);
  }

  async executeListener({ event, info }: Event) {
    debug(`Executing webhook for event '${event}'`);
    const webhooks = this.webhooksMap.get(event) || [];
    const activeWebhooks = webhooks.filter((webhook) => webhook.isEnabled === true);

    for (const webhook of activeWebhooks) {
      await this.run(webhook, event, info).catch((error: unknown) => {
        this.logger.error('Error running webhook');
        this.logger.error(error);
      });
    }
  }

  run(webhook: Webhook, event: string, info = {}) {
    const { url, headers } = webhook;

    return this.fetch(url, {
      method: 'post',
      body: JSON.stringify({
        event,
        createdAt: new Date(),
        ...info,
      }),
      headers: {
        ...this.config.defaultHeaders,
        ...headers,
        'X-Strapi-Event': event,
        'Content-Type': 'application/json',
      },
      signal: AbortSignal.timeout(10000),
    })
      .then(async (res) => {
        if (res.ok) {
          return {
            statusCode: res.status,
          };
        }

        return {
          statusCode: res.status,
          message: await res.text(),
        };
      })
      .catch((err) => {
        return {
          statusCode: 500,
          message: err.message,
        };
      });
  }

  add(webhook: Webhook) {
    debug(`Registering webhook '${webhook.id}'`);
    const { events } = webhook;

    events.forEach((event) => {
      if (this.webhooksMap.has(event)) {
        this.webhooksMap.get(event)?.push(webhook);
      } else {
        this.webhooksMap.set(event, [webhook]);
        this.createListener(event);
      }
    });
  }

  update(webhook: Webhook) {
    debug(`Refreshing webhook '${webhook.id}'`);
    this.remove(webhook);
    this.add(webhook);
  }

  remove(webhook: Webhook) {
    debug(`Unregistering webhook '${webhook.id}'`);

    this.webhooksMap.forEach((webhooks, event) => {
      const filteredWebhooks = webhooks.filter((value) => value.id !== webhook.id);

      // Cleanup hanging listeners
      if (filteredWebhooks.length === 0) {
        this.webhooksMap.delete(event);
        this.deleteListener(event);
      } else {
        this.webhooksMap.set(event, filteredWebhooks);
      }
    });
  }
}

/**
 * Expose a factory function instead of the class
 */
export default function createWebhookRunner(opts: ConstructorParameters): WebhookRunner {
  return new WebhookRunner(opts);
}

export type { WebhookRunner };
</file>

<file path="src/services/webhook-store.ts">
/**
 * Webhook store is the implementation of webhook storage over the core_store
 */

import { errors } from '@strapi/utils';
import type { Model, Database } from '@strapi/database';
import type { Modules } from '@strapi/types';

const { ValidationError } = errors;

const webhookModel: Model = {
  uid: 'strapi::webhook',
  singularName: 'strapi_webhooks',
  tableName: 'strapi_webhooks',
  attributes: {
    id: {
      type: 'increments',
    },
    name: {
      type: 'string',
    },
    url: {
      type: 'text',
    },
    headers: {
      type: 'json',
    },
    events: {
      type: 'json',
    },
    enabled: {
      type: 'boolean',
    },
  },
};

type Webhook = Modules.WebhookStore.Webhook;
type DBOutput = Omit<Webhook, 'id' | 'isEnabled'> & { id: string | number; enabled: boolean };
type DBInput = Omit<DBOutput, 'id'>;

const toDBObject = (data: Webhook): DBInput => {
  return {
    name: data.name,
    url: data.url,
    headers: data.headers,
    events: data.events,
    enabled: data.isEnabled,
  };
};

const fromDBObject = (row: DBOutput): Webhook => {
  return {
    id: typeof row.id === 'number' ? row.id.toString() : row.id,
    name: row.name,
    url: row.url,
    headers: row.headers,
    events: row.events,
    isEnabled: row.enabled,
  };
};

const webhookEventValidator = async (allowedEvents: Map<string, string>, events: string[]) => {
  const allowedValues = Array.from(allowedEvents.values());

  events.forEach((event) => {
    if (allowedValues.includes(event)) {
      return;
    }

    throw new ValidationError(`Webhook event ${event} is not supported`);
  });
};

export interface WebhookStore {
  allowedEvents: Map<string, string>;
  addAllowedEvent(key: string, value: string): void;
  removeAllowedEvent(key: string): void;
  listAllowedEvents(): string[];
  getAllowedEvent(key: string): string | undefined;
  findWebhooks(): Promise<Webhook[]>;
  findWebhook(id: string): Promise<Webhook | null>;
  createWebhook(data: Webhook): Promise<Webhook>;
  updateWebhook(id: string, data: Webhook): Promise<Webhook | null>;
  deleteWebhook(id: string): Promise<Webhook | null>;
}

const createWebhookStore = ({ db }: { db: Database }): WebhookStore => {
  return {
    allowedEvents: new Map([
      ['ENTRY_CREATE', 'entry.create'],
      ['ENTRY_UPDATE', 'entry.update'],
      ['ENTRY_DELETE', 'entry.delete'],
      ['ENTRY_PUBLISH', 'entry.publish'],
      ['ENTRY_UNPUBLISH', 'entry.unpublish'],
      ['ENTRY_DRAFT_DISCARD', 'entry.draft-discard'],
    ]),
    addAllowedEvent(key, value) {
      this.allowedEvents.set(key, value);
    },
    removeAllowedEvent(key) {
      this.allowedEvents.delete(key);
    },
    listAllowedEvents() {
      return Array.from(this.allowedEvents.keys());
    },
    getAllowedEvent(key) {
      return this.allowedEvents.get(key);
    },
    async findWebhooks() {
      const results = await db.query('strapi::webhook').findMany();

      return results.map(fromDBObject);
    },
    async findWebhook(id) {
      const result = await db.query('strapi::webhook').findOne({ where: { id } });
      return result ? fromDBObject(result) : null;
    },
    async createWebhook(data) {
      await webhookEventValidator(this.allowedEvents, data.events);

      return db
        .query('strapi::webhook')
        .create({
          data: toDBObject({ ...data, isEnabled: true }),
        })
        .then(fromDBObject);
    },
    async updateWebhook(id, data) {
      await webhookEventValidator(this.allowedEvents, data.events);

      const webhook = await db.query('strapi::webhook').update({
        where: { id },
        data: toDBObject(data),
      });

      return webhook ? fromDBObject(webhook) : null;
    },
    async deleteWebhook(id) {
      const webhook = await db.query('strapi::webhook').delete({ where: { id } });
      return webhook ? fromDBObject(webhook) : null;
    },
  };
};

export { webhookModel, createWebhookStore };
</file>

<file path="src/services/worker-queue.ts">
/**
 * Simple worker queue in memory
 */
import createDebugger from 'debug';
import type { Logger } from '@strapi/logger';
import type { Utils } from '@strapi/types';

const debug = createDebugger('strapi:worker-queue');

interface ConstructorParameters {
  logger: Logger;
  concurrency?: number;
}

type Worker<TPayload, TReturn> = (payload: TPayload) => Promise<TReturn> | TReturn;

const noop: Utils.Function.Any = () => {};

export default class WorkerQueue<TPayload, TReturn> {
  logger: Logger;

  worker: Worker<TPayload, TReturn>;

  concurrency: number;

  running: number;

  queue: TPayload[];

  constructor({ logger, concurrency = 5 }: ConstructorParameters) {
    debug('Initialize worker queue');

    this.logger = logger;
    this.worker = noop;

    this.concurrency = concurrency;
    this.running = 0;
    this.queue = [];
  }

  subscribe(worker: Worker<TPayload, TReturn>) {
    debug('Subscribe to worker queue');
    this.worker = worker;
  }

  enqueue(payload: TPayload) {
    debug('Enqueue event in worker queue');
    if (this.running < this.concurrency) {
      this.running += 1;
      this.execute(payload);
    } else {
      this.queue.unshift(payload);
    }
  }

  pop() {
    debug('Pop worker queue and execute');
    const payload = this.queue.pop();

    if (payload) {
      this.execute(payload);
    } else {
      this.running -= 1;
    }
  }

  async execute(payload: TPayload) {
    debug('Execute worker');
    try {
      await this.worker(payload);
    } catch (error) {
      this.logger.error(error);
    } finally {
      this.pop();
    }
  }
}
</file>

<file path="src/utils/__tests__/convert-custom-field-type.test.ts">
import { convertCustomFieldType } from '../convert-custom-field-type';

describe('format attributes', () => {
  it('replaces type customField with the underlying data type', () => {
    global.strapi = {
      // mock container.get('custom-fields')
      get: jest.fn(() => ({
        // mock container.get('custom-fields').get(uid)
        get: jest.fn(() => ({
          name: 'color',
          plugin: 'mycustomfields',
          type: 'text',
        })),
      })),

      contentTypes: {
        test: {
          attributes: {
            color: {
              type: 'customField',
              customField: 'plugin::mycustomfields.color',
            },
          },
        },
      },
      components: {
        'default.test': {
          attributes: {
            color: {
              type: 'customField',
              customField: 'plugin::mycustomfields.color',
            },
          },
        },
      },
    } as any;

    convertCustomFieldType(global.strapi);

    const expected = {
      ...global.strapi,
      contentTypes: {
        test: {
          attributes: {
            color: {
              type: 'text',
              customField: 'plugin::mycustomfields.color',
            },
          },
        },
      },
      components: {
        'default.test': {
          attributes: {
            color: {
              type: 'text',
              customField: 'plugin::mycustomfields.color',
            },
          },
        },
      },
    };

    expect(global.strapi).toEqual(expected);
  });
});
</file>

<file path="src/utils/__tests__/filepath-to-prop-path.test.ts">
import { filePathToPropPath } from '../filepath-to-prop-path';

const commonCases: [string, string[]][] = [
  ['./config/test.js', ['config', 'test']],
  ['./config/test.json', ['config', 'test']],
  ['./config/test.settings.js', ['config', 'test']],
  ['./config/test.settings.json', ['config', 'test']],
  ['config/test.settings.json', ['config', 'test']],
];

describe('filePathToPropPath', () => {
  test.each<[string, string[]]>(commonCases)('File %s becomes %p', (input, expected) => {
    expect(filePathToPropPath(input)).toEqual(expected);
  });

  // uses dots to create path
  test('Uses dots for key separation', () => {
    expect(filePathToPropPath('./config/file.key.js')).toEqual(['config', 'file', 'key']);

    expect(filePathToPropPath('./config/file.key.json')).toEqual(['config', 'file', 'key']);
  });

  // removes the last prop of the path
  test('Disable file name key', () => {
    expect(filePathToPropPath('./config/test.js', false)).toEqual(['config']);
    expect(filePathToPropPath('./config/test.key.js', false)).toEqual(['config', 'test']);
  });

  describe('Separators', () => {
    test('Win32 Separators', () => {
      expect(filePathToPropPath('config\\test.js')).toEqual(['config', 'test']);
      expect(filePathToPropPath('.\\config\\test.js')).toEqual(['config', 'test']);
    });

    test('Posix Separators', () => {
      expect(filePathToPropPath('config/test.js')).toEqual(['config', 'test']);
      expect(filePathToPropPath('./config/test.js')).toEqual(['config', 'test']);
    });

    test('Mixed Separators (win32 + posix)', () => {
      expect(filePathToPropPath('src\\config/test.js')).toEqual(['src', 'config', 'test']);
      expect(filePathToPropPath('.\\config/test.js')).toEqual(['config', 'test']);
    });
  });
});
</file>

<file path="src/utils/__tests__/transform-content-types-to-models.test.ts">
import { cloneDeep, merge } from 'lodash';
import { Database } from '@strapi/database';
import {
  LoadedContentTypeModel,
  transformContentTypesToModels,
} from '../transform-content-types-to-models';

const db = new Database({
  settings: {
    migrations: {
      dir: 'fakedir',
    },
  },
  connection: {
    client: 'sqlite',
    useNullAsDefault: true,
    connection: {
      filename: 'fake.db',
    },
  },
});

const identifiers = db.metadata.identifiers;

// We want to match exactly with the exception that document_id.default should be any function
expect.extend({
  toMatchModels(received, expected) {
    const replaceFunctionInDocumentIdDefault = (obj: any) => {
      const defaultFunction = obj?.attributes?.documentId?.default;
      if (typeof defaultFunction === 'function') {
        return {
          ...obj,
          attributes: {
            ...obj.attributes,
            documentId: { ...obj.attributes.documentId, default: expect.any(Function) },
          },
        };
      }
      return obj;
    };

    const pass =
      JSON.stringify(received) === JSON.stringify(replaceFunctionInDocumentIdDefault(expected));

    return {
      message: () =>
        `expected \r\n ${JSON.stringify(received)} ${
          pass ? 'not ' : ''
        } \r\n to be equal to \r\n ${JSON.stringify(expected)}`,
      pass,
    };
  },
});

const contentTypes: LoadedContentTypeModel[] = [
  {
    attributes: {
      name: {
        default: 'my name',
        type: 'string',
      },
      categories: {
        type: 'relation',
        relation: 'oneToMany',
        target: 'api::category.category',
      },
      comp: {
        component: 'default.comp',
        type: 'component',
        required: true,
      },
      compRepeatable: {
        component: 'default.comp',
        type: 'component',
        repeatable: true,
      },
      singleImage: {
        type: 'media',
        multiple: false,
      },
      repeatableImage: {
        type: 'media',
        multiple: true,
      },
      dz: {
        type: 'dynamiczone',
        components: ['text_block', 'image_block'],
      },
    },
    collectionName: 'countries',
    uid: 'api::countries.countries',
    modelType: 'contentType',
    kind: 'collectionType',
    info: {
      singularName: 'country',
      pluralName: 'countries',
      displayName: 'My Country',
    },
    modelName: 'country',
    globalId: 'country',
  },
  {
    attributes: {
      name: {
        type: 'string',
      },
    },
    collectionName: 'categories',
    modelType: 'contentType',
    kind: 'collectionType',
    uid: 'api::categories.categories',
    info: {
      displayName: 'Category',
      singularName: 'category',
      pluralName: 'categories',
    },
    modelName: 'category',
    globalId: 'category',
  },
  {
    attributes: undefined,
    collectionName: 'empty',
    modelType: 'component',
    kind: 'collectionType',
    uid: 'api::empty.empty',
    info: {
      displayName: 'Empty',
      singularName: 'empty',
      pluralName: 'empties',
    },
    modelName: 'empty',
    globalId: 'empty',
  },
];

const expectedModels = [
  {
    singularName: 'countries_components',
    uid: 'countries_components',
    tableName: 'countries_components',
    attributes: {
      id: { type: 'increments' },
      entity_id: { type: 'integer', column: { unsigned: true } },
      component_id: { type: 'integer', column: { unsigned: true } },
      component_type: { type: 'string' },
      field: { type: 'string' },
      order: { type: 'float', column: { unsigned: true, defaultTo: null } },
    },
    indexes: [
      { name: 'countries_field_index', columns: ['field'] },
      { name: 'countries_component_type_index', columns: ['component_type'] },
      { name: 'countries_entity_fk', columns: ['entity_id'] },
      {
        name: 'countries_unique',
        columns: ['entity_id', 'component_id', 'field', 'component_type'],
        type: 'unique',
      },
    ],
    foreignKeys: [
      {
        name: 'countries_entity_fk',
        columns: ['entity_id'],
        referencedColumns: ['id'],
        referencedTable: 'countries',
        onDelete: 'CASCADE',
      },
    ],
  },
  {
    uid: 'api::countries.countries',
    singularName: 'country',
    tableName: 'countries',
    attributes: {
      id: { type: 'increments' },
      documentId: { type: 'string' },
      name: { default: 'my name', type: 'string' },
      categories: { type: 'relation', relation: 'oneToMany', target: 'api::category.category' },
      comp: {
        type: 'relation',
        relation: 'oneToOne',
        target: 'default.comp',
        joinTable: {
          name: 'countries_components',
          joinColumn: { name: 'entity_id', referencedColumn: 'id' },
          inverseJoinColumn: { name: 'component_id', referencedColumn: 'id' },
          on: { field: 'comp' },
          orderColumnName: 'order',
          orderBy: { order: 'asc' },
          pivotColumns: ['entity_id', 'component_id', 'field', 'component_type'],
        },
      },
      compRepeatable: {
        type: 'relation',
        relation: 'oneToMany',
        target: 'default.comp',
        joinTable: {
          name: 'countries_components',
          joinColumn: { name: 'entity_id', referencedColumn: 'id' },
          inverseJoinColumn: { name: 'component_id', referencedColumn: 'id' },
          on: { field: 'compRepeatable' },
          orderColumnName: 'order',
          orderBy: { order: 'asc' },
          pivotColumns: ['entity_id', 'component_id', 'field', 'component_type'],
        },
      },
      singleImage: {
        type: 'relation',
        relation: 'morphOne',
        target: 'plugin::upload.file',
        morphBy: 'related',
      },
      repeatableImage: {
        type: 'relation',
        relation: 'morphMany',
        target: 'plugin::upload.file',
        morphBy: 'related',
      },
      dz: {
        type: 'relation',
        relation: 'morphToMany',
        joinTable: {
          name: 'countries_components',
          joinColumn: { name: 'entity_id', referencedColumn: 'id' },
          morphColumn: {
            idColumn: { name: 'component_id', referencedColumn: 'id' },
            typeColumn: { name: 'component_type' },
            typeField: '__component',
          },
          on: { field: 'dz' },
          orderBy: { order: 'asc' },
          pivotColumns: ['entity_id', 'component_id', 'field', 'component_type'],
        },
      },
    },
    indexes: [
      {
        name: 'countries_documents_index',
        columns: ['document_id'],
      },
    ],
    lifecycles: {},
  },
  {
    uid: 'api::categories.categories',
    singularName: 'category',
    tableName: 'categories',
    attributes: {
      id: { type: 'increments' },
      documentId: { type: 'string' },
      name: { type: 'string' },
    },
    indexes: [
      {
        name: 'categories_documents_index',
        columns: ['document_id'],
      },
    ],
    lifecycles: {},
  },
  {
    uid: 'api::empty.empty',
    singularName: 'empty',
    tableName: 'empty',
    attributes: { id: { type: 'increments' } },
    lifecycles: {},
  },
];

type AttributeChange = {
  [key: string]: {
    type: string;
  };
};

type ContentTypeChange = Partial<Omit<LoadedContentTypeModel, 'attributes'>> & {
  attributes?: AttributeChange;
};

function mergeContentType(
  contentType: LoadedContentTypeModel,
  changes: ContentTypeChange
): LoadedContentTypeModel {
  // Deep clone the original object to avoid modifying it
  const clonedContentType = cloneDeep(contentType);
  return merge(clonedContentType, changes);
}

function patchContentTypes(
  collectionName: string,
  changes: ContentTypeChange
): LoadedContentTypeModel[] {
  return contentTypes.map((ct) => {
    if (ct.collectionName === collectionName) {
      return mergeContentType(ct, changes);
    }
    return ct;
  });
}

describe('transformContentTypesToModels', () => {
  describe('full length identifiers', () => {
    // mock the options so that the 'global' identifiers created for use by createMetadata uses 0 for maxLength
    Object.defineProperty(identifiers, 'options', {
      get: jest.fn(() => ({ maxLength: 0 })),
    });

    test('converts valid content types to models', () => {
      const models = transformContentTypesToModels(contentTypes, identifiers);

      expect(models).toMatchModels(expectedModels);
    });

    test.each(['id', 'document_id', 'ID', 'documentId'])(
      'throws on restricted attribute name: %s',
      (restrictedName) => {
        const changes = {
          attributes: {
            [restrictedName]: {
              type: 'string',
            },
          },
        };
        const modifiedContentTypes = patchContentTypes('countries', changes);

        expect(() => transformContentTypesToModels(modifiedContentTypes, identifiers)).toThrow(
          `The attribute "${restrictedName}" is reserved`
        );
      }
    );

    test.each(['collectionName', 'uid', 'modelName'])(
      'throws on missing name: %s',
      (restrictedName) => {
        const changes = {
          [restrictedName]: null,
        };
        const modifiedContentTypes = patchContentTypes('countries', changes);

        expect(() => transformContentTypesToModels(modifiedContentTypes, identifiers)).toThrow(
          `"${restrictedName}" is required`
        );
      }
    );
  });
});
</file>

<file path="src/utils/update-notifier/index.ts">
import path from 'path';
import packageJson from 'package-json';
import Configstore from 'configstore';
import semver from 'semver';
import boxen from 'boxen';
import chalk from 'chalk';
import { env } from '@strapi/utils';
import type { Core } from '@strapi/types';

import pkg from '../../../package.json';

const CHECK_INTERVAL = 1000 * 60 * 60 * 24 * 1; // 1 day
const NOTIF_INTERVAL = 1000 * 60 * 60 * 24 * 7; // 1 week
const boxenOptions: boxen.Options = {
  padding: 1,
  margin: 1,
  align: 'center',
  borderColor: 'yellow',
  borderStyle: 'round',
};

const getUpdateMessage = (newVersion: string, currentVersion: string) => {
  const currentVersionLog = chalk.dim(currentVersion);
  const newVersionLog = chalk.green(newVersion);
  const releaseLink = chalk.bold('https://github.com/strapi/strapi/releases');

  return `
A new version of Strapi is available ${currentVersionLog} → ${newVersionLog}
Check out the new releases at: ${releaseLink}
`.trim();
};

export const createUpdateNotifier = (strapi: Core.Strapi) => {
  let config: InstanceType<typeof Configstore>;

  try {
    config = new Configstore(
      pkg.name,
      {},
      { configPath: path.join(strapi.dirs.app.root, '.strapi-updater.json') }
    );
  } catch {
    // we don't have write access to the file system
    // we silence the error
    return;
  }

  const checkUpdate = async (checkInterval: number) => {
    const now = Date.now();
    const lastUpdateCheck = config.get('lastUpdateCheck') || 0;
    if (lastUpdateCheck + checkInterval > now) {
      return;
    }

    try {
      const res = await packageJson(pkg.name);
      if (res.version) {
        config.set('latest', res.version);
        config.set('lastUpdateCheck', now);
      }
    } catch {
      // silence error if offline
    }
  };

  const display = (notifInterval: number) => {
    const now = Date.now();
    const latestVersion = config.get('latest');
    const lastNotification = config.get('lastNotification') || 0;

    if (
      !process.stdout.isTTY ||
      lastNotification + notifInterval > now ||
      !semver.valid(latestVersion) ||
      !semver.valid(pkg.version) ||
      semver.lte(latestVersion, pkg.version)
    ) {
      return;
    }

    const message = boxen(getUpdateMessage(latestVersion, pkg.version), boxenOptions);
    config.set('lastNotification', now);
    console.log(message);
  };

  // TODO v6: Remove this warning
  if (env.bool('STRAPI_DISABLE_UPDATE_NOTIFICATION', false)) {
    strapi.log.warn(
      'STRAPI_DISABLE_UPDATE_NOTIFICATION is no longer supported. Instead, set logger.updates.enabled to false in your server configuration.'
    );
  }

  if (!strapi.config.get('server.logger.updates.enabled') || !config) {
    return;
  }

  display(NOTIF_INTERVAL);
  checkUpdate(CHECK_INTERVAL); // doesn't need to await
};
</file>

<file path="src/utils/convert-custom-field-type.ts">
import type { Core } from '@strapi/types';

type InputAttributes = {
  [key: string]: {
    type: string;
    customField?: string;
  };
};

export const convertCustomFieldType = (strapi: Core.Strapi) => {
  const allContentTypeSchemaAttributes = Object.values(strapi.contentTypes).map(
    (schema) => schema.attributes
  );

  const allComponentSchemaAttributes = Object.values(strapi.components).map(
    (schema) => schema.attributes
  );
  const allSchemasAttributes: InputAttributes[] = [
    ...allContentTypeSchemaAttributes,
    ...allComponentSchemaAttributes,
  ];

  for (const schemaAttrbutes of allSchemasAttributes) {
    for (const attribute of Object.values(schemaAttrbutes)) {
      if (attribute.type === 'customField') {
        const customField = strapi.get('custom-fields').get(attribute.customField);
        attribute.type = customField.type;
      }
    }
  }
};
</file>

<file path="src/utils/cron.ts">
import { isEmpty, negate } from 'lodash/fp';

const DATE_FUNCTIONS = [
  'getSeconds',
  'getMinutes',
  'getHours',
  'getDate',
  'getMonth',
  'getDay',
] as const;

const INTEGER_REGEX = /^\d+$/;
const STEP_REGEX = /^\*\/\d+$/;
const COMPONENTS: {
  limit: number;
  zeroBasedIndices: boolean;
  functionName: (typeof DATE_FUNCTIONS)[number];
}[] = [
  { limit: 60, zeroBasedIndices: true, functionName: 'getSeconds' },
  { limit: 60, zeroBasedIndices: true, functionName: 'getMinutes' },
  { limit: 24, zeroBasedIndices: true, functionName: 'getHours' },
  { limit: 31, zeroBasedIndices: false, functionName: 'getDate' },
  { limit: 12, zeroBasedIndices: false, functionName: 'getMonth' },
  { limit: 7, zeroBasedIndices: true, functionName: 'getDay' },
];

const shift = (component: string, index: number, date: Date) => {
  if (component === '*') {
    return '*';
  }

  const { limit, zeroBasedIndices, functionName } = COMPONENTS[index];
  const offset = +!zeroBasedIndices;
  const currentValue = date[functionName]();

  if (INTEGER_REGEX.test(component)) {
    return ((Number.parseInt(component, 10) + currentValue) % limit) + offset;
  }

  if (STEP_REGEX.test(component)) {
    const [, step] = component.split('/');
    const frequency = Math.floor(limit / Number(step));
    const list = Array.from({ length: frequency }, (_, index) => index * Number(step));
    return list.map((value) => ((value + currentValue) % limit) + offset).sort((a, b) => a - b);
  }

  // Unsupported syntax
  return component;
};

/**
 * Simulate an interval by shifting a cron expression using the specified date.
 * @param {string} rule A cron expression you want to shift.
 * @param {Date} date The date that's gonna be used as the start of the "interval", it defaults to now.
 * @returns The shifted cron expression.
 */
export const shiftCronExpression = (rule: string, date = new Date()) => {
  const components = rule.trim().split(' ').filter(negate(isEmpty));
  const secondsIncluded = components.length === 6;
  return components
    .map((component, index) => shift(component, secondsIncluded ? index : index + 1, date))
    .join(' ');
};
</file>

<file path="src/utils/ee.ts">
export { default as ee } from '../ee';
</file>

<file path="src/utils/fetch.ts">
import type { Core, Modules } from '@strapi/types';
import { ProxyAgent } from 'undici';

// TODO: once core Node exposes a stable way to create a ProxyAgent we will use that instead of undici

// Create a wrapper for Node's Fetch API that applies a global proxy
export const createStrapiFetch = (strapi: Core.Strapi): Modules.Fetch.Fetch => {
  function strapiFetch(url: RequestInfo | URL, options?: RequestInit) {
    const fetchOptions = {
      ...(strapiFetch.dispatcher ? { dispatcher: strapiFetch.dispatcher } : {}),
      ...options,
    };
    strapi.log.debug(`Making request for ${url}`);
    return fetch(url, fetchOptions);
  }

  const proxy =
    strapi.config.get<ConstructorParameters<typeof ProxyAgent>[0]>('server.proxy.fetch') ||
    strapi.config.get<string>('server.proxy.global');

  if (proxy) {
    strapi.log.info(`Using proxy for Fetch requests: ${proxy}`);
    strapiFetch.dispatcher = new ProxyAgent(proxy);
  }

  return strapiFetch;
};

export type Fetch = Modules.Fetch.Fetch;
</file>

<file path="src/utils/filepath-to-prop-path.ts">
import path from 'node:path';
import fp from 'lodash/fp';

/**
 * Returns a path (as an array) from a file path
 */
export const filePathToPropPath = (
  entryPath: string,
  useFileNameAsKey: boolean = true
): string[] => {
  const transform = fp.pipe(
    // Remove the relative path prefixes: './' for posix (and some win32) and ".\" for win32
    removeRelativePrefix,
    // Remove the path metadata and extensions
    fp.replace(/(\.settings|\.json|\.js)/g, ''),
    // Transform to lowercase
    // Note: We're using fp.toLower instead of fp.lowercase as the latest removes special characters such as "/"
    fp.toLower,
    // Split the cleaned path by matching every possible separator (either "/" or "\" depending on the OS)
    fp.split(new RegExp(`[\\${path.win32.sep}|${path.posix.sep}]`, 'g')),
    // Make sure to remove leading '.' from the different path parts
    fp.map(fp.trimCharsStart('.')),
    // join + split in case some '.' characters are still present in different parts of the path
    fp.join('.'),
    fp.split('.'),
    // Remove the last portion of the path array if the file name shouldn't be used as a key
    useFileNameAsKey ? fp.identity : fp.slice(0, -1)
  );

  return transform(entryPath) as string[];
};

const removeRelativePrefix = (filePath: string) => {
  return filePath.startsWith(`.${path.win32.sep}`) || filePath.startsWith(`.${path.posix.sep}`)
    ? filePath.slice(2)
    : filePath;
};
</file>

<file path="src/utils/index.ts">
export { openBrowser } from './open-browser';
export { isInitialized } from './is-initialized';
export { getDirs } from '../configuration/get-dirs';
export { ee } from './ee';
export { createUpdateNotifier } from './update-notifier';
export { createStrapiFetch, Fetch } from './fetch';
export { convertCustomFieldType } from './convert-custom-field-type';
export { createStartupLogger } from './startup-logger';
export { transformContentTypesToModels } from './transform-content-types-to-models';
export { destroyOnSignal } from './signals';
export { LIFECYCLES } from './lifecycles';
export { resolveWorkingDirectories } from './resolve-working-dirs';
</file>

<file path="src/utils/is-initialized.ts">
import { isEmpty, isNil } from 'lodash/fp';

import type { Core } from '@strapi/types';

/**
 * Test if the strapi application is considered as initialized (1st user has been created)
 */
export const isInitialized = async (strapi: Core.Strapi): Promise<boolean> => {
  try {
    if (isEmpty(strapi.admin)) {
      return true;
    }

    // test if there is at least one admin
    const anyAdministrator = await strapi.db.query('admin::user').findOne({ select: ['id'] });

    return !isNil(anyAdministrator);
  } catch (err) {
    strapi.stopWithError(err);
  }
};
</file>

<file path="src/utils/lifecycles.ts">
export const LIFECYCLES = {
  REGISTER: 'register',
  BOOTSTRAP: 'bootstrap',
  DESTROY: 'destroy',
} as const;
</file>

<file path="src/utils/load-config-file.ts">
import path from 'path';
import fs from 'fs';
import { env, importDefault } from '@strapi/utils';

const loadJsFile = (file: string) => {
  try {
    const jsModule = importDefault(file);

    // call if function
    if (typeof jsModule === 'function') {
      return jsModule({ env });
    }

    return jsModule;
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Could not load js config file ${file}: ${error.message}`);
    }

    throw new Error('Unknown error');
  }
};

const loadJSONFile = (file: string) => {
  try {
    return JSON.parse(fs.readFileSync(file).toString());
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Could not load json config file ${file}: ${error.message}`);
    }

    throw new Error('Unknown error');
  }
};

export const loadConfigFile = (file: string) => {
  const ext = path.extname(file);

  switch (ext) {
    case '.js':
      return loadJsFile(file);
    case '.json':
      return loadJSONFile(file);
    default:
      return {};
  }
};
</file>

<file path="src/utils/load-files.ts">
import path from 'path';
import _ from 'lodash';
import fse from 'fs-extra';

import { importDefault } from '@strapi/utils';
import { glob } from 'glob';
import { filePathToPropPath } from './filepath-to-prop-path';

/**
 * Returns an Object build from a list of files matching a glob pattern in a directory
 * It builds a tree structure resembling the folder structure in dir
 */
export const loadFiles = async <T extends object>(
  dir: string,
  pattern: string,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  { requireFn = importDefault, shouldUseFileNameAsKey = (_: any) => true, globArgs = {} } = {}
): Promise<T> => {
  const root = {};
  const files = await glob(pattern, { cwd: dir, ...globArgs });

  for (const file of files) {
    const absolutePath = path.resolve(dir, file);

    // load module
    delete require.cache[absolutePath];
    let mod;

    if (path.extname(absolutePath) === '.json') {
      mod = await fse.readJson(absolutePath);
    } else {
      mod = requireFn(absolutePath);
    }

    Object.defineProperty(mod, '__filename__', {
      enumerable: true,
      configurable: false,
      writable: false,
      value: path.basename(file),
    });

    const propPath = filePathToPropPath(file, shouldUseFileNameAsKey(file));

    if (propPath.length === 0) _.merge(root, mod);
    _.merge(root, _.setWith({}, propPath, mod, Object));
  }

  return root as T;
};
</file>

<file path="src/utils/open-browser.ts">
import open from 'open';

import type { Core } from '@strapi/types';

export const openBrowser = async (config: Core.ConfigProvider) => {
  const url = config.get<string>('admin.absoluteUrl');

  return open(url);
};
</file>

<file path="src/utils/resolve-working-dirs.ts">
import path from 'node:path';

/**
 * Resolve the working directories based on the instance options.
 *
 * Behavior:
 * - `appDir` is the directory where Strapi will write every file (schemas, generated APIs, controllers or services)
 * - `distDir` is the directory where Strapi will read configurations, schemas and any compiled code
 *
 * Default values:
 * - If `appDir` is `undefined`, it'll be set to `process.cwd()`
 * - If `distDir` is `undefined`, it'll be set to `appDir`
 */
export const resolveWorkingDirectories = (opts: { appDir?: string; distDir?: string }) => {
  const cwd = process.cwd();

  const appDir = opts.appDir ? path.resolve(cwd, opts.appDir) : cwd;
  const distDir = opts.distDir ? path.resolve(cwd, opts.distDir) : appDir;

  return { appDir, distDir };
};
</file>

<file path="src/utils/signals.ts">
import type { Core } from '@strapi/types';

export const destroyOnSignal = (strapi: Core.Strapi) => {
  let signalReceived = false;

  // For unknown reasons, we receive signals 2 times.
  // As a temporary fix, we ignore the signals received after the first one.

  const terminateStrapi = async () => {
    if (!signalReceived) {
      signalReceived = true;
      await strapi.destroy();
      process.exit();
    }
  };

  ['SIGTERM', 'SIGINT'].forEach((signal) => {
    process.on(signal, terminateStrapi);
  });
};
</file>

<file path="src/utils/startup-logger.ts">
import chalk from 'chalk';
import CLITable from 'cli-table3';
import _ from 'lodash/fp';

import type { Core } from '@strapi/types';

export const createStartupLogger = (app: Core.Strapi) => {
  return {
    logStats() {
      const columns = Math.min(process.stderr.columns, 80) - 2;
      console.log();
      console.log(chalk.black.bgWhite(_.padEnd(columns, ' Project information')));
      console.log();

      const infoTable = new CLITable({
        colWidths: [20, 50],
        chars: { mid: '', 'left-mid': '', 'mid-mid': '', 'right-mid': '' },
      });

      const dbInfo = app.db?.getInfo();

      infoTable.push(
        [chalk.blue('Time'), `${new Date()}`],
        [chalk.blue('Launched in'), `${Date.now() - app.config.launchedAt} ms`],
        [chalk.blue('Environment'), app.config.environment],
        [chalk.blue('Process PID'), process.pid],
        [chalk.blue('Version'), `${app.config.info.strapi} (node ${process.version})`],
        [chalk.blue('Edition'), app.EE ? 'Enterprise' : 'Community'],
        [chalk.blue('Database'), dbInfo?.client],
        [chalk.blue('Database name'), dbInfo?.displayName]
      );

      if (dbInfo?.schema) {
        infoTable.push([chalk.blue('Database schema'), dbInfo.schema]);
      }

      console.log(infoTable.toString());
      console.log();
      console.log(chalk.black.bgWhite(_.padEnd(columns, ' Actions available')));
      console.log();
    },

    logFirstStartupMessage() {
      if (!strapi.config.get('server.logger.startup.enabled')) {
        return;
      }

      this.logStats();

      console.log(chalk.bold('One more thing...'));
      console.log(
        chalk.grey('Create your first administrator 💻 by going to the administration panel at:')
      );
      console.log();

      const addressTable = new CLITable();

      const adminUrl = strapi.config.get('admin.absoluteUrl');
      addressTable.push([chalk.bold(adminUrl)]);

      console.log(`${addressTable.toString()}`);
      console.log();
    },

    logDefaultStartupMessage() {
      if (!strapi.config.get('server.logger.startup.enabled')) {
        return;
      }
      this.logStats();

      console.log(chalk.bold('Welcome back!'));

      if (app.config.get('admin.serveAdminPanel') === true) {
        console.log(chalk.grey('To manage your project 🚀, go to the administration panel at:'));
        const adminUrl = strapi.config.get('admin.absoluteUrl');
        console.log(chalk.bold(adminUrl));
        console.log();
      }

      console.log(chalk.grey('To access the server ⚡️, go to:'));
      const serverUrl = strapi.config.get('server.absoluteUrl');
      console.log(chalk.bold(serverUrl));
      console.log();
    },

    logStartupMessage({ isInitialized }: { isInitialized: boolean }) {
      if (!strapi.config.get('server.logger.startup.enabled')) {
        return;
      }
      if (!isInitialized) {
        this.logFirstStartupMessage();
      } else {
        this.logDefaultStartupMessage();
      }
    },
  };
};
</file>

<file path="src/utils/transform-content-types-to-models.ts">
import { type Model, type Identifiers } from '@strapi/database';
import type { Struct, Schema } from '@strapi/types';
import { createId } from '@paralleldrive/cuid2';
import assert from 'node:assert';
import _ from 'lodash/fp';

/**
 * Because strapi/database models don't know about things like components or dynamic zones, we use this file to convert them
 * to a relations format that it recognizes
 *
 * Therefore we have to keep an additional set of helpers/extensions to the database naming methods
 *
 * IMPORTANT!
 * If we use short versions of anything, we MUST call getNameFromTokens directly; attempting to shorten them ourselves
 * prevents the unshortened name map from being filled properly, so for example it will think that the short name
 * 'collection4f3a_cmps' maps to the unshortened 'collectionname_cmps' rather than 'collectionname_components'
 * Therefore, we only use the identifiers helpers in cases where we do not do any of our own shortening
 */

export const getComponentJoinTableName = (collectionName: string, identifiers: Identifiers) => {
  return identifiers.getNameFromTokens([
    { name: collectionName, compressible: true },
    { name: 'components', shortName: 'cmps', compressible: false },
  ]);
};

export const getDzJoinTableName = (collectionName: string, identifiers: Identifiers) => {
  return identifiers.getNameFromTokens([
    { name: collectionName, compressible: true },
    { name: 'components', shortName: 'cmps', compressible: false },
  ]);
};

export const getComponentJoinColumnEntityName = (identifiers: Identifiers) => {
  return identifiers.getNameFromTokens([
    { name: 'entity', compressible: false },
    { name: 'id', compressible: false },
  ]);
};

export const getComponentJoinColumnInverseName = (identifiers: Identifiers) => {
  return identifiers.getNameFromTokens([
    { name: 'component', shortName: 'cmp', compressible: false },
    { name: 'id', compressible: false },
  ]);
};

export const getComponentTypeColumn = (identifiers: Identifiers) => {
  return identifiers.getNameFromTokens([{ name: 'component_type', compressible: false }]);
};

export const getComponentFkIndexName = (contentType: string, identifiers: Identifiers) => {
  return identifiers.getNameFromTokens([
    { name: contentType, compressible: true },
    { name: 'entity', compressible: false },
    { name: 'fk', compressible: false },
  ]);
};

// const { ID_COLUMN: id, FIELD_COLUMN: field, ORDER_COLUMN: order } = identifiers;

export type LoadedContentTypeModel = Struct.ContentTypeSchema &
  Required<Pick<Struct.ContentTypeSchema, 'collectionName' | 'uid' | 'modelName'>> &
  Pick<Model, 'lifecycles'>;

// Transforms an attribute (particularly for relation types) into the format that strapi/database accepts
export const transformAttribute = (
  name: string,
  attribute: Schema.Attribute.AnyAttribute,
  contentType: LoadedContentTypeModel,
  identifiers: Identifiers
) => {
  switch (attribute.type) {
    case 'media': {
      return {
        type: 'relation',
        relation: attribute.multiple === true ? 'morphMany' : 'morphOne',
        target: 'plugin::upload.file',
        morphBy: 'related',
      };
    }
    case 'component': {
      const joinTableName = getComponentJoinTableName(contentType.collectionName, identifiers);
      const joinColumnEntityName = getComponentJoinColumnEntityName(identifiers);
      const joinColumnInverseName = getComponentJoinColumnInverseName(identifiers);
      const compTypeColumn = getComponentTypeColumn(identifiers);
      return {
        type: 'relation',
        relation: attribute.repeatable === true ? 'oneToMany' : 'oneToOne',
        target: attribute.component,

        // We need the join table name to be deterministic,
        // We need to allow passing the join table name as an option
        joinTable: {
          name: joinTableName,
          joinColumn: {
            name: joinColumnEntityName,
            referencedColumn: identifiers.ID_COLUMN,
          },
          inverseJoinColumn: {
            name: joinColumnInverseName,
            referencedColumn: identifiers.ID_COLUMN,
          },
          on: {
            field: name,
          },
          orderColumnName: identifiers.ORDER_COLUMN,
          orderBy: {
            order: 'asc',
          },
          pivotColumns: [
            joinColumnEntityName,
            joinColumnInverseName,
            identifiers.FIELD_COLUMN,
            compTypeColumn,
          ],
        },
      };
    }
    case 'dynamiczone': {
      const joinTableName = getDzJoinTableName(contentType.collectionName, identifiers);
      const joinColumnEntityName = getComponentJoinColumnEntityName(identifiers);
      const joinColumnInverseName = getComponentJoinColumnInverseName(identifiers);
      const compTypeColumn = getComponentTypeColumn(identifiers);

      return {
        type: 'relation',
        relation: 'morphToMany',
        // TODO: handle restrictions at some point
        // target: attribute.components,
        joinTable: {
          name: joinTableName,
          joinColumn: {
            name: joinColumnEntityName,
            referencedColumn: identifiers.ID_COLUMN,
          },
          morphColumn: {
            idColumn: {
              name: joinColumnInverseName,
              referencedColumn: identifiers.ID_COLUMN,
            },
            typeColumn: {
              name: compTypeColumn,
            },
            typeField: '__component',
          },
          on: {
            field: name,
          },
          orderBy: {
            order: 'asc',
          },
          pivotColumns: [
            joinColumnEntityName,
            joinColumnInverseName,
            identifiers.FIELD_COLUMN,
            compTypeColumn,
          ],
        },
      };
    }
    default: {
      return attribute;
    }
  }
};

export const transformAttributes = (
  contentType: LoadedContentTypeModel,
  identifiers: Identifiers
) => {
  return Object.keys(contentType.attributes! || {}).reduce((attrs, attrName) => {
    return {
      ...attrs,
      [attrName]: transformAttribute(
        attrName,
        contentType.attributes[attrName]!,
        contentType,
        identifiers
      ),
    };
  }, {});
};

export const hasComponentsOrDz = (
  contentType: LoadedContentTypeModel
): contentType is LoadedContentTypeModel & { type: 'dynamiczone' | 'component' } => {
  return Object.values(contentType.attributes || {}).some(
    (({ type }: { type: string }) => type === 'dynamiczone' || type === 'component') as any
  );
};

export const createDocumentId = createId;

const createCompoLinkModel = (
  contentType: LoadedContentTypeModel,
  identifiers: Identifiers
): Model => {
  const name = getComponentJoinTableName(contentType.collectionName, identifiers);

  const entityId = getComponentJoinColumnEntityName(identifiers);
  const componentId = getComponentJoinColumnInverseName(identifiers);
  const compTypeColumn = getComponentTypeColumn(identifiers);
  const fkIndex = getComponentFkIndexName(contentType.collectionName, identifiers);

  return {
    // TODO: make sure there can't be any conflicts with a prefix
    singularName: name,
    uid: name,
    tableName: name,
    attributes: {
      [identifiers.ID_COLUMN]: {
        type: 'increments',
      },
      [entityId]: {
        type: 'integer',
        column: {
          unsigned: true,
        },
      },
      [componentId]: {
        type: 'integer',
        column: {
          unsigned: true,
        },
      },
      [compTypeColumn]: {
        type: 'string',
      },
      [identifiers.FIELD_COLUMN]: {
        type: 'string',
      },
      [identifiers.ORDER_COLUMN]: {
        type: 'float',
        column: {
          unsigned: true,
          defaultTo: null,
        },
      },
    },
    indexes: [
      {
        name: identifiers.getIndexName([contentType.collectionName, identifiers.FIELD_COLUMN]),
        columns: [identifiers.FIELD_COLUMN],
      },
      {
        name: identifiers.getIndexName([contentType.collectionName, compTypeColumn]),
        columns: [compTypeColumn],
      },
      {
        name: fkIndex,
        columns: [entityId],
      },
      {
        // NOTE: since we don't include attribute names, we need to be careful not to create another unique index
        name: identifiers.getUniqueIndexName([contentType.collectionName]),
        columns: [entityId, componentId, identifiers.FIELD_COLUMN, compTypeColumn],
        type: 'unique',
      },
    ],
    foreignKeys: [
      {
        name: fkIndex,
        columns: [entityId],
        referencedColumns: [identifiers.ID_COLUMN],
        referencedTable: identifiers.getTableName(contentType.collectionName),
        onDelete: 'CASCADE',
      },
    ],
  };
};

export const transformContentTypesToModels = (
  contentTypes: LoadedContentTypeModel[],
  identifiers: Identifiers
): Model[] => {
  const models: Model[] = [];

  contentTypes.forEach((contentType) => {
    assert(contentType.collectionName, 'Content type "collectionName" is required');
    assert(contentType.modelName, 'Content type "modelName" is required');
    assert(contentType.uid, 'Content type "uid" is required');

    // Add document id to content types
    // as it is not documented
    const documentIdAttribute: Record<string, Schema.Attribute.AnyAttribute> =
      contentType.modelType === 'contentType'
        ? { documentId: { type: 'string', default: createDocumentId } }
        : {};

    // TODO: this needs to be combined with getReservedNames, we should not be maintaining two lists
    // Prevent user from creating a documentId attribute
    const reservedAttributeNames = ['document_id', identifiers.ID_COLUMN];
    Object.keys(contentType.attributes || {}).forEach((attributeName) => {
      const snakeCasedAttributeName = _.snakeCase(attributeName);
      if (reservedAttributeNames.includes(snakeCasedAttributeName)) {
        throw new Error(
          `The attribute "${attributeName}" is reserved and cannot be used in a model. Please rename "${contentType.modelName}" attribute "${attributeName}" to something else.`
        );
      }
    });

    if (hasComponentsOrDz(contentType)) {
      const compoLinkModel = createCompoLinkModel(contentType, identifiers);
      models.push(compoLinkModel);
    }

    const model: Model = {
      uid: contentType.uid,
      singularName: contentType.modelName,
      tableName: contentType.collectionName, // This gets shortened in metadata.loadModels(), so we don't shorten here or it will happen twice
      attributes: {
        [identifiers.ID_COLUMN]: {
          type: 'increments',
        },
        ...documentIdAttribute,
        ...transformAttributes(contentType, identifiers),
      },
      indexes: contentType.indexes as Model['indexes'],
      foreignKeys: contentType.foreignKeys as Model['foreignKeys'],
      lifecycles: contentType?.lifecycles ?? {},
    };

    // Add indexes to model
    if (contentType.modelType === 'contentType') {
      model.indexes = [
        ...(model.indexes || []),
        {
          name: identifiers.getIndexName([contentType.collectionName, 'documents']),
          // Filter attributes that are not in the schema
          columns: ['documentId', 'locale', 'publishedAt']
            .filter((n) => model.attributes[n])
            .map((name) => identifiers.getColumnName(_.snakeCase(name))),
        },
      ];
    }

    models.push(model);
  });

  return models;
};
</file>

<file path="src/compile.ts">
import tsUtils from '@strapi/typescript-utils';

interface Options {
  appDir?: string;
  ignoreDiagnostics?: boolean;
}

export default async function compile(options?: Options) {
  const { appDir = process.cwd(), ignoreDiagnostics = false } = options ?? {};
  const isTSProject = await tsUtils.isUsingTypeScript(appDir);
  const outDir = await tsUtils.resolveOutDir(appDir);

  if (isTSProject) {
    await tsUtils.compile(appDir, {
      configOptions: { options: { incremental: true }, ignoreDiagnostics },
    });
  }

  const distDir = isTSProject ? outDir : appDir;

  return { appDir, distDir };
}
</file>

<file path="src/container.ts">
import type { Core } from '@strapi/types';

export class Container implements Core.Container {
  private registerMap = new Map<string, unknown>();

  private serviceMap = new Map();

  add(name: string, resolver: unknown) {
    if (this.registerMap.has(name)) {
      throw new Error(`Cannot register already registered service ${name}`);
    }

    this.registerMap.set(name, resolver);
    return this;
  }

  get(name: string, args?: unknown) {
    // TODO: handle singleton vs instantiation everytime
    if (this.serviceMap.has(name)) {
      return this.serviceMap.get(name);
    }

    if (this.registerMap.has(name)) {
      const resolver = this.registerMap.get(name);

      if (typeof resolver === 'function') {
        this.serviceMap.set(name, resolver(this, args));
      } else {
        this.serviceMap.set(name, resolver);
      }

      return this.serviceMap.get(name);
    }

    throw new Error(`Could not resolve service ${name}`);
  }
}
</file>

<file path="src/factories.ts">
import { pipe, omit, pick } from 'lodash/fp';
import type { Core, UID, Utils } from '@strapi/types';

import { createController } from './core-api/controller';
import { createService } from './core-api/service';
import { createRoutes } from './core-api/routes';

const symbols = {
  CustomController: Symbol('StrapiCustomCoreController'),
} as const;

type WithStrapiCallback<T> = T | (<S extends { strapi: Core.Strapi }>(params: S) => T);

const createCoreController = <
  TUID extends UID.ContentType,
  TController extends Core.CoreAPI.Controller.Extendable<TUID>,
>(
  uid: TUID,
  cfg?: WithStrapiCallback<
    Utils.PartialWithThis<Core.CoreAPI.Controller.Extendable<TUID> & TController>
  >
) => {
  return ({
    strapi,
  }: {
    strapi: Core.Strapi;
  }): TController & Core.CoreAPI.Controller.ContentType<TUID> => {
    const baseController = createController({ contentType: strapi.contentType(uid) });

    const userCtrl = typeof cfg === 'function' ? cfg({ strapi }) : (cfg ?? ({} as any));

    for (const methodName of Object.keys(baseController) as Array<keyof typeof baseController>) {
      if (userCtrl[methodName] === undefined) {
        userCtrl[methodName] = baseController[methodName];
      }
    }

    Object.setPrototypeOf(userCtrl, baseController);

    const isCustom = typeof cfg !== 'undefined';
    if (isCustom) {
      Object.defineProperty(userCtrl, symbols.CustomController, {
        writable: false,
        configurable: false,
        enumerable: false,
      });
    }

    return userCtrl;
  };
};

function createCoreService<
  TUID extends UID.ContentType,
  TService extends Core.CoreAPI.Service.Extendable<TUID>,
>(
  uid: TUID,
  cfg?: WithStrapiCallback<Utils.PartialWithThis<Core.CoreAPI.Service.Extendable<TUID> & TService>>
) {
  return ({
    strapi,
  }: {
    strapi: Core.Strapi;
  }): TService & Core.CoreAPI.Service.ContentType<TUID> => {
    const baseService = createService({ contentType: strapi.contentType(uid) });

    const userService = typeof cfg === 'function' ? cfg({ strapi }) : (cfg ?? ({} as any));

    for (const methodName of Object.keys(baseService) as Array<keyof typeof baseService>) {
      if (userService[methodName] === undefined) {
        userService[methodName] = baseService[methodName];
      }
    }

    Object.setPrototypeOf(userService, baseService);
    return userService;
  };
}

function createCoreRouter<T extends UID.ContentType>(
  uid: T,
  cfg?: Core.CoreAPI.Router.RouterConfig<T>
): Core.CoreAPI.Router.Router {
  const { prefix, config = {}, only, except, type = 'content-api' } = cfg ?? {};
  let routes: Core.CoreAPI.Router.Route[];

  return {
    type,
    prefix,
    get routes() {
      if (!routes) {
        const contentType = strapi.contentType(uid);

        const defaultRoutes = createRoutes({ contentType });
        const keys = Object.keys(defaultRoutes) as Array<keyof typeof defaultRoutes>;

        keys.forEach((routeName) => {
          const defaultRoute = defaultRoutes[routeName];

          Object.assign(defaultRoute.config, config[routeName] || {});
        });

        const selectedRoutes = pipe(
          (routes) => (except ? omit(except, routes) : routes),
          (routes) => (only ? pick(only, routes) : routes)
        )(defaultRoutes);

        routes = Object.values(selectedRoutes);
      }

      return routes;
    },
  };
}

const isCustomController = <T extends Core.Controller>(controller: T): boolean => {
  return symbols.CustomController in controller;
};

export { createCoreController, createCoreService, createCoreRouter, isCustomController };
</file>

<file path="src/index.ts">
import * as qs from 'qs';
import type { Core } from '@strapi/types';

import Strapi, { type StrapiOptions } from './Strapi';
import { destroyOnSignal, resolveWorkingDirectories, createUpdateNotifier } from './utils';

export { default as compileStrapi } from './compile';
export * as factories from './factories';

export const createStrapi = (options: Partial<StrapiOptions> = {}): Core.Strapi => {
  const strapi = new Strapi({
    ...options,
    ...resolveWorkingDirectories(options),
  });

  destroyOnSignal(strapi);
  createUpdateNotifier(strapi);

  // TODO: deprecate and remove in next major
  global.strapi = strapi;

  return strapi;
};

// Augment Koa query type based on Strapi query middleware

declare module 'koa' {
  type ParsedQuery = ReturnType<typeof qs.parse>;

  export interface BaseRequest {
    _querycache?: ParsedQuery;

    get query(): ParsedQuery;
    set query(obj: any);
  }

  export interface BaseContext {
    _querycache?: ParsedQuery;

    get query(): ParsedQuery;
    set query(obj: any);
  }
}
</file>

<file path="src/modules.d.ts">
declare module 'koa-favicon' {
  import type Koa from 'koa';

  export default function favicon(
    path: string,
    options?: { maxAge?: number; mime?: string }
  ): Koa.Middleware;
}
</file>

<file path="src/Strapi.ts">
import * as globalAgent from 'global-agent';
import path from 'path';
import _ from 'lodash';
import { isFunction } from 'lodash/fp';
import { Logger, createLogger } from '@strapi/logger';
import { Database } from '@strapi/database';

import type { Core, Modules, UID, Schema } from '@strapi/types';

import tsUtils from '@strapi/typescript-utils';
import { loadConfiguration } from './configuration';

import * as factories from './factories';

import * as utils from './utils';
import { Container } from './container';
import createStrapiFs from './services/fs';
import createEventHub from './services/event-hub';
import { createServer } from './services/server';
import { createReloader } from './services/reloader';

import { providers } from './providers';
import createEntityService from './services/entity-service';
import createQueryParamService from './services/query-params';

import entityValidator from './services/entity-validator';
import requestContext from './services/request-context';
import createAuth from './services/auth';
import createCustomFields from './services/custom-fields';
import createContentAPI from './services/content-api';
import getNumberOfDynamicZones from './services/utils/dynamic-zones';
import { FeaturesService, createFeaturesService } from './services/features';
import { createDocumentService } from './services/document-service';

import { coreStoreModel } from './services/core-store';
import { createConfigProvider } from './services/config';

class Strapi extends Container implements Core.Strapi {
  app: any;

  isLoaded: boolean = false;

  internal_config: Record<string, unknown> = {};

  constructor(opts: StrapiOptions) {
    super();

    this.internal_config = loadConfiguration(opts);

    this.registerInternalServices();

    for (const provider of providers) {
      provider.init?.(this);
    }
  }

  get admin(): Core.Module {
    return this.get('admin');
  }

  get EE(): boolean {
    return utils.ee.isEE;
  }

  get ee(): Core.Strapi['ee'] {
    return utils.ee;
  }

  get dirs(): Core.StrapiDirectories {
    return this.config.get('dirs');
  }

  get reload(): Core.Reloader {
    return this.get('reload');
  }

  get db(): Database {
    return this.get('db');
  }

  get requestContext(): Modules.RequestContext.RequestContext {
    return this.get('requestContext');
  }

  get customFields(): Modules.CustomFields.CustomFields {
    return this.get('customFields');
  }

  get entityValidator(): Modules.EntityValidator.EntityValidator {
    return this.get('entityValidator');
  }

  /**
   * @deprecated `strapi.entityService` will be removed in the next major version
   */
  get entityService(): Modules.EntityService.EntityService {
    return this.get('entityService');
  }

  get documents(): Modules.Documents.Service {
    return this.get('documents');
  }

  get features(): FeaturesService {
    return this.get('features');
  }

  get fetch(): Modules.Fetch.Fetch {
    return this.get('fetch');
  }

  get cron(): Modules.Cron.CronService {
    return this.get('cron');
  }

  get log(): Logger {
    return this.get('logger');
  }

  get startupLogger(): Core.StartupLogger {
    return this.get('startupLogger');
  }

  get eventHub(): Modules.EventHub.EventHub {
    return this.get('eventHub');
  }

  get fs(): Core.StrapiFS {
    return this.get('fs');
  }

  get server(): Modules.Server.Server {
    return this.get('server');
  }

  get telemetry(): Modules.Metrics.TelemetryService {
    return this.get('telemetry');
  }

  get store(): Modules.CoreStore.CoreStore {
    return this.get('coreStore');
  }

  get config() {
    return this.get('config');
  }

  get services() {
    return this.get('services').getAll();
  }

  service(uid: UID.Service) {
    return this.get('services').get(uid);
  }

  get controllers() {
    return this.get('controllers').getAll();
  }

  controller(uid: UID.Controller) {
    return this.get('controllers').get(uid);
  }

  get contentTypes(): Schema.ContentTypes {
    return this.get('content-types').getAll();
  }

  contentType(name: UID.ContentType) {
    return this.get('content-types').get(name);
  }

  get components(): Schema.Components {
    return this.get('components').getAll();
  }

  get policies() {
    return this.get('policies').getAll();
  }

  policy(name: string) {
    return this.get('policies').get(name);
  }

  get middlewares() {
    return this.get('middlewares').getAll();
  }

  middleware(name: string) {
    return this.get('middlewares').get(name);
  }

  get plugins(): Record<string, Core.Plugin> {
    return this.get('plugins').getAll();
  }

  plugin(name: string): Core.Plugin {
    return this.get('plugins').get(name);
  }

  get hooks() {
    return this.get('hooks').getAll();
  }

  hook(name: string) {
    return this.get('hooks').get(name);
  }

  get apis() {
    return this.get('apis').getAll();
  }

  api(name: string): Core.Module {
    return this.get('apis').get(name);
  }

  get auth() {
    return this.get('auth');
  }

  get contentAPI() {
    return this.get('content-api');
  }

  get sanitizers() {
    return this.get('sanitizers');
  }

  get validators() {
    return this.get('validators');
  }

  async start() {
    try {
      if (!this.isLoaded) {
        await this.load();
      }

      await this.listen();

      return this;
    } catch (error) {
      return this.stopWithError(error);
    }
  }

  // TODO: split into more providers
  registerInternalServices() {
    const config = createConfigProvider(this.internal_config, this);

    const logger = createLogger({
      level: 'http', // Strapi defaults to level 'http'
      ...config.get('logger'), // DEPRECATED
      ...config.get('server.logger.config'),
    });

    // Instantiate the Strapi container
    this.add('config', () => config)
      .add('query-params', createQueryParamService(this))
      .add('content-api', createContentAPI(this))
      .add('auth', createAuth())
      .add('server', () => createServer(this))
      .add('fs', () => createStrapiFs(this))
      .add('eventHub', () => createEventHub())
      .add('startupLogger', () => utils.createStartupLogger(this))
      .add('logger', () => logger)
      .add('fetch', () => utils.createStrapiFetch(this))
      .add('features', () => createFeaturesService(this))
      .add('requestContext', requestContext)
      .add('customFields', createCustomFields(this))
      .add('entityValidator', entityValidator)
      .add('entityService', () => createEntityService({ strapi: this, db: this.db }))
      .add('documents', () => createDocumentService(this))
      .add('db', () => {
        const tsDir = tsUtils.resolveOutDirSync(this.dirs.app.root);
        const tsMigrationsEnabled =
          this.config.get('database.settings.useTypescriptMigrations') === true && tsDir;
        const projectDir = tsMigrationsEnabled ? tsDir : this.dirs.app.root;
        return new Database(
          _.merge(this.config.get('database'), {
            logger,
            settings: {
              migrations: {
                dir: path.join(projectDir, 'database/migrations'),
              },
            },
          })
        );
      })
      .add('reload', () => createReloader(this));
  }

  sendStartupTelemetry() {
    // Emit started event.
    // do not await to avoid slower startup
    // This event is anonymous
    this.telemetry
      .send('didStartServer', {
        groupProperties: {
          database: this.config.get('database.connection.client'),
          plugins: Object.keys(this.plugins),
          numberOfAllContentTypes: _.size(this.contentTypes), // TODO: V5: This event should be renamed numberOfContentTypes in V5 as the name is already taken to describe the number of content types using i18n.
          numberOfComponents: _.size(this.components),
          numberOfDynamicZones: getNumberOfDynamicZones(),
          numberOfCustomControllers: Object.values<Core.Controller>(this.controllers).filter(
            // TODO: Fix this at the content API loader level to prevent future types issues
            (controller) => controller !== undefined && factories.isCustomController(controller)
          ).length,
          environment: this.config.environment,
          // TODO: to add back
          // providers: this.config.installedProviders,
        },
      })
      .catch(this.log.error);
  }

  async openAdmin({ isInitialized }: { isInitialized: boolean }) {
    const shouldOpenAdmin =
      this.config.get('environment') === 'development' &&
      this.config.get('admin.autoOpen', true) !== false;

    if (shouldOpenAdmin && !isInitialized) {
      try {
        await utils.openBrowser(this.config);
        this.telemetry.send('didOpenTab');
      } catch (e) {
        this.telemetry.send('didNotOpenTab');
      }
    }
  }

  async postListen() {
    const isInitialized = await utils.isInitialized(this);

    this.startupLogger.logStartupMessage({ isInitialized });

    this.log.info('Strapi started successfully');
    this.sendStartupTelemetry();
    this.openAdmin({ isInitialized });
  }

  /**
   * Add behaviors to the server
   */
  async listen() {
    return new Promise<void>((resolve, reject) => {
      const onListen = async () => {
        try {
          await this.postListen();

          resolve();
        } catch (error) {
          reject(error);
        }
      };

      const listenSocket = this.config.get('server.socket');

      if (listenSocket) {
        this.server.listen(listenSocket, onListen);
      } else {
        const { host, port } = this.config.get('server');

        this.server.listen(port, host, onListen);
      }
    });
  }

  stopWithError(err: unknown, customMessage?: string): never {
    this.log.debug(`⛔️ Server wasn't able to start properly.`);
    if (customMessage) {
      this.log.error(customMessage);
    }

    this.log.error(err);
    return this.stop();
  }

  stop(exitCode = 1): never {
    this.destroy();

    if (this.config.get('autoReload')) {
      process.send?.('stop');
    }

    // Kill process
    process.exit(exitCode);
  }

  async load() {
    await this.register();
    await this.bootstrap();

    this.isLoaded = true;

    return this;
  }

  async register() {
    // @ts-expect-error: init is internal
    this.ee.init(this.dirs.app.root, this.log);

    for (const provider of providers) {
      await provider.register?.(this);
    }

    await this.runPluginsLifecycles(utils.LIFECYCLES.REGISTER);
    await this.runUserLifecycles(utils.LIFECYCLES.REGISTER);

    // NOTE: Swap type customField for underlying data type
    utils.convertCustomFieldType(this);

    return this;
  }

  async bootstrap() {
    this.configureGlobalProxy();

    const models = [
      ...utils.transformContentTypesToModels(
        [...Object.values(this.contentTypes), ...Object.values(this.components)],
        this.db.metadata.identifiers
      ),
      ...this.get('models').get(),
    ];

    await this.db.init({ models });

    let oldContentTypes;
    if (await this.db.getSchemaConnection().hasTable(coreStoreModel.tableName)) {
      oldContentTypes = await this.store.get({
        type: 'strapi',
        name: 'content_types',
        key: 'schema',
      });
    }

    await this.hook('strapi::content-types.beforeSync').call({
      oldContentTypes,
      contentTypes: this.contentTypes,
    });

    const status = await this.db.schema.sync();

    // if schemas have changed, run repairs
    if (status === 'CHANGED') {
      await this.db.repair.removeOrphanMorphType({ pivot: 'component_type' });
    }

    if (this.EE) {
      await utils.ee.checkLicense({ strapi: this });
    }

    await this.hook('strapi::content-types.afterSync').call({
      oldContentTypes,
      contentTypes: this.contentTypes,
    });

    await this.store.set({
      type: 'strapi',
      name: 'content_types',
      key: 'schema',
      value: this.contentTypes,
    });

    await this.server.initMiddlewares();
    this.server.initRouting();

    await this.contentAPI.permissions.registerActions();

    await this.runPluginsLifecycles(utils.LIFECYCLES.BOOTSTRAP);

    for (const provider of providers) {
      await provider.bootstrap?.(this);
    }

    await this.runUserLifecycles(utils.LIFECYCLES.BOOTSTRAP);

    return this;
  }

  configureGlobalProxy() {
    const globalProxy = this.config.get('server.proxy.global');
    const httpProxy = this.config.get('server.proxy.http') || globalProxy;
    const httpsProxy = this.config.get('server.proxy.https') || globalProxy;

    if (!httpProxy && !httpsProxy) {
      return;
    }

    globalAgent.bootstrap();

    if (httpProxy) {
      this.log.info(`Using HTTP proxy: ${httpProxy}`);
      (global as any).GLOBAL_AGENT.HTTP_PROXY = httpProxy;
    }

    if (httpsProxy) {
      this.log.info(`Using HTTPS proxy: ${httpsProxy}`);
      (global as any).GLOBAL_AGENT.HTTPS_PROXY = httpsProxy;
    }
  }

  async destroy() {
    this.log.info('Shutting down Strapi');
    await this.runPluginsLifecycles(utils.LIFECYCLES.DESTROY);

    for (const provider of providers) {
      await provider.destroy?.(this);
    }

    await this.runUserLifecycles(utils.LIFECYCLES.DESTROY);

    await this.server.destroy();

    this.eventHub.destroy();

    await this.db?.destroy();

    process.removeAllListeners();

    // @ts-expect-error: Allow clean delete of global.strapi to allow re-instanciation
    delete global.strapi;

    this.log.info('Strapi has been shut down');
  }

  async runPluginsLifecycles(lifecycleName: 'register' | 'bootstrap' | 'destroy') {
    // plugins
    await this.get('modules')[lifecycleName]();
  }

  async runUserLifecycles(lifecycleName: 'register' | 'bootstrap' | 'destroy') {
    // user
    const userLifecycleFunction = this.app && this.app[lifecycleName];
    if (isFunction(userLifecycleFunction)) {
      await userLifecycleFunction({ strapi: this });
    }
  }

  getModel(uid: UID.ContentType): Schema.ContentType;
  getModel(uid: UID.Component): Schema.Component;
  getModel<TUID extends UID.Schema>(uid: TUID): Schema.ContentType | Schema.Component | undefined {
    if (uid in this.contentTypes) {
      return this.contentTypes[uid as UID.ContentType];
    }

    if (uid in this.components) {
      return this.components[uid as UID.Component];
    }
  }

  /**
   * @deprecated Use `strapi.db.query` instead
   */
  query(uid: UID.Schema) {
    return this.db.query(uid);
  }
}

export interface StrapiOptions {
  appDir: string;
  distDir: string;
  autoReload?: boolean;
  serveAdminPanel?: boolean;
}

export default Strapi;
</file>

<file path=".eslintrc.js">
module.exports = {
  root: true,
  extends: ['custom/back/typescript'],
  overrides: [
    {
      files: ['**/*.test.ts'],
      rules: {
        'import/no-relative-packages': 'warn',
      },
    },
  ],
};
</file>

<file path="jest.config.js">
'use strict';

module.exports = {
  preset: '../../../jest-preset.unit.js',
  transform: {
    '^.+\\.ts$': ['@swc/jest'],
  },
  testMatch: ['<rootDir>/**/*.test.ts'],
  displayName: 'Core Strapi',
};
</file>

<file path="README.md">
# `@strapi/core`
</file>

</files>
